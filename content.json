{"meta":{"title":"mhy-blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"书单","date":"2022-03-29T01:43:16.376Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-03-29T01:43:16.348Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-29T01:43:16.416Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-29T01:43:16.403Z","updated":"2022-03-25T10:27:57.833Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-03-29T01:43:16.389Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-03-29T01:43:16.362Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"标签","date":"2022-03-29T01:43:16.429Z","updated":"2022-03-25T10:27:57.834Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mybatis_dao层实现原理","slug":"Mybatis-dao层实现原理","date":"2022-05-18T06:49:33.000Z","updated":"2022-05-19T15:28:09.333Z","comments":true,"path":"2022/05/18/Mybatis-dao层实现原理/","link":"","permalink":"http://example.com/2022/05/18/Mybatis-dao%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"1.Mybatis的Dao层实现1.1 传统开发方式1.1.1编写UserDao接口123public interface UserDao &#123; List&lt;User&gt; findAll() throws IOException;&#125; 1.1.2.编写UserDaoImpl实现123456789101112public class UserDaoImpl implements UserDao &#123; public List&lt;User&gt; findAll() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); sqlSession.close(); return userList; &#125;&#125; 1.1.3 测试传统方式123456@Testpublic void testTraditionDao() throws IOException &#123; UserDao userDao = new UserDaoImpl(); List&lt;User&gt; all = userDao.findAll(); System.out.println(all);&#125; 1.2 代理开发方式1.2.1 代理开发方式介绍采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。 Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper 接口开发需要遵循以下规范： 1) Mapper.xml文件中的namespace与mapper接口的全限定名相同 2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同 4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 1.2.2 编写UserMapper接口 1.2.3测试代理方式1234567891011@Testpublic void testProxyDao() throws IOException &#123; InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream); SqlSession sqlSession = sqlSessionFactory.openSession(); //获得MyBatis框架生成的UserMapper接口的实现类 UserMapper userMapper = sqlSession.getMapper(UserMapper.class);//输入接口类型 User user = userMapper.findById(1); System.out.println(user); sqlSession.close();&#125; 1.3 知识小结MyBatis的Dao层实现的两种方式： 手动对Dao进行实现：传统开发方式 代理方式对Dao进行实现： 1UserMapper userMapper = sqlSession.getMapper(UserMapper.class); 2.MyBatis映射文件深入2.1 动态sql语句2.1.1动态sql语句概述Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。 参考的官方文档，描述如下： 2.1.2动态 SQL 之&lt;if&gt;我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。 1234567891011&lt;select id=&quot;findByCondition&quot; parameterType=&quot;user&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt;//where相当于1=1的条件 &lt;if test=&quot;id!=0&quot;&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username!=null&quot;&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 当查询条件id和username都存在时，控制台打印的sql语句如下： 123456//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User condition = new User(); condition.setId(1); condition.setUsername(&quot;lucy&quot;); User user = userMapper.findByCondition(condition); ![](https://mhypicgo.oss-cn-beijing.aliyuncs.com/img/截屏 3.png) 当查询条件只有id存在时，控制台打印的sql语句如下： 12345//获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);User condition = new User();condition.setId(1);User user = userMapper.findByCondition(condition); 2.1.3 动态 SQL 之&lt;foreach&gt;循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。 12345678&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select * from User &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试代码片段如下： 12345 //获得MyBatis框架生成的UserMapper接口的实现类UserMapper userMapper = sqlSession.getMapper(UserMapper.class);int[] ids = new int[]&#123;2,5&#125;;List&lt;User&gt; userList = userMapper.findByIds(ids);System.out.println(userList); foreach标签的属性含义如下： &lt;foreach&gt;标签用于遍历集合，它的属性： •collection：代表要遍历的集合元素，注意编写时不要写#{} •open：代表语句的开始部分 •close：代表结束部分 •item：代表遍历集合的每个元素，生成的变量名 •sperator：代表分隔符 2.2 SQL片段抽取Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的 12345678910111213&lt;!--抽取sql片段简化编写--&gt;&lt;sql id=&quot;selectUser&quot; select * from User&lt;/sql&gt;&lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; where id=#&#123;id&#125;&lt;/select&gt;&lt;select id=&quot;findByIds&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; &lt;include refid=&quot;selectUser&quot;&gt;&lt;/include&gt; &lt;where&gt; &lt;foreach collection=&quot;array&quot; open=&quot;id in(&quot; close=&quot;)&quot; item=&quot;id&quot; separator=&quot;,&quot;&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 2.3 知识小结MyBatis映射文件配置： &lt;select&gt;：查询 &lt;insert&gt;：插入 &lt;update&gt;：修改 &lt;delete&gt;：删除 &lt;where&gt;：where条件 &lt;if&gt;：if判断 &lt;foreach&gt;：循环 &lt;sql&gt;：sql片段抽取 3.MyBatis核心配置文件深入3.1typeHandlers标签无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。 你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。 开发步骤： ①定义转换类继承类BaseTypeHandler&lt;T&gt; ②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法 ③在MyBatis核心配置文件中进行注册 测试转换是否正确 1234567891011121314public class MyDateTypeHandler extends BaseTypeHandler&lt;Date&gt; &#123; public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) &#123; preparedStatement.setString(i,date.getTime()+&quot;&quot;); &#125; public Date getNullableResult(ResultSet resultSet, String s) throws SQLException &#123; return new Date(resultSet.getLong(s)); &#125; public Date getNullableResult(ResultSet resultSet, int i) throws SQLException &#123; return new Date(resultSet.getLong(i)); &#125; public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException &#123; return callableStatement.getDate(i); &#125;&#125; 12345//在核心配置文件中&lt;!--注册类型自定义转换器--&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=&quot;com.itheima.typeHandlers.MyDateTypeHandler&quot;&gt;&lt;/typeHandler&gt;&lt;/typeHandlers&gt; 数据库中添加一列数据 剩下没什么不同 3.2 plugins标签MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据 开发步骤： ①导入通用PageHelper的坐标 ②在mybatis核心配置文件中配置PageHelper插件 ③测试分页数据获取 先要设置一个查询全部的方法findAll() 在使用findAll()方法前使用plugins设置 ①导入通用PageHelper坐标1234567891011&lt;!-- 分页助手 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;3.7.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; ②在mybatis核心配置文件中配置PageHelper插件12345&lt;!-- 注意：分页助手的插件 配置在通用馆mapper之前 --&gt;&lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 指定方言 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;&lt;/plugin&gt; ③测试分页代码实现12345678910@Testpublic void testPageHelper()&#123; //设置分页参数 PageHelper.startPage(1,2); List&lt;User&gt; select = userMapper2.select(null); for(User user : select)&#123; System.out.println(user); &#125;&#125; 获得分页相关的其他参数 12345678//其他分页的数据PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;User&gt;(select);System.out.println(&quot;总条数：&quot;+pageInfo.getTotal());System.out.println(&quot;总页数：&quot;+pageInfo.getPages());System.out.println(&quot;当前页：&quot;+pageInfo.getPageNum());System.out.println(&quot;每页显示长度：&quot;+pageInfo.getPageSize());System.out.println(&quot;是否第一页：&quot;+pageInfo.isIsFirstPage());System.out.println(&quot;是否最后一页：&quot;+pageInfo.isIsLastPage()); 3.3 知识小结MyBatis核心配置文件常用标签： 1、properties标签：该标签可以加载外部的properties文件 2、typeAliases标签：设置类型别名 3、environments标签：数据源环境配置标签 4、typeHandlers标签：配置自定义类型处理器 5、plugins标签：配置MyBatis的插件","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/tags/Mybatis/"}]},{"title":"Mybatis入门","slug":"Mybatis入门","date":"2022-05-17T04:40:06.000Z","updated":"2022-05-18T11:00:17.116Z","comments":true,"path":"2022/05/17/Mybatis入门/","link":"","permalink":"http://example.com/2022/05/17/Mybatis%E5%85%A5%E9%97%A8/","excerpt":"","text":"1.Mybatis简介1.1原始jdbc操作（查询数据） 1.2原始jdbc操作（插入数据） 1.3 原始jdbc操作的分析原始jdbc开发存在的问题如下： ①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能 ②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。 ③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置 应对上述问题给出的解决方案： ①使用数据库连接池初始化连接资源 ②将sql语句抽取到xml配置文件中 ③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射 1.4 什么是Mybatis(dao层框架)mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。 最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节 ，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。 2.Mybatis的快速入门2.1 MyBatis开发步骤MyBatis官网地址：http://www.mybatis.org/mybatis-3/ MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 2.2 环境搭建 导入MyBatis的坐标和其他相关坐标 1234567891011121314151617181920212223242526&lt;!--mybatis坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql驱动坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--单元测试坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--日志坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 创建user数据表 编写User实体 123456public class User &#123; private int id; private String username; private String password; //省略get个set方法&#125; 编写UserMapper映射文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt;&lt;/mapper&gt; 编写MyBatis核心文件 12345678910111213141516171819&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN“ &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt;//默认使用环境 &lt;environment id=&quot;development&quot;&gt;//环境之一 &lt;transactionManager type=&quot;JDBC&quot;/&gt;//事物管理器 &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///test&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--加载映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/itheima/mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.3 编写测试代码12345678910111213//加载核心配置文件InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);//获得sqlSession工厂对象SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);//获得sqlSession对象SqlSession sqlSession = sqlSessionFactory.openSession();//执行sql语句List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);//打印结果System.out.println(userList);//释放资源sqlSession.close(); 2.4 知识小结MyBatis开发步骤： ①添加MyBatis的坐标 ②创建user数据表 ③编写User实体类 ④编写映射文件UserMapper.xml(主要描述sql语句) ⑤编写核心文件SqlMapConfig.xml ⑥编写测试类 3. MyBatis的映射文件概述 4. MyBatis的增删改查操作4.1 MyBatis的插入数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt;//需输入的类型 &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写插入实体User的代码 123456789InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int insert = sqlSession.insert(&quot;userMapper.add&quot;, user);System.out.println(insert);//提交事务 mybatis默认事物不提交sqlSession.commit();sqlSession.close(); 插入操作注意问题 • 插入语句使用insert标签 • 在映射文件中使用parameterType属性指定要插入的数据类型 •Sql语句中使用#{实体属性名}方式引用实体中的属性值 •插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象); •插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() 4.2 MyBatis的修改数据操作 编写UserMapper映射文件 12345&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt;&lt;/mapper&gt; 编写修改实体User的代码 12345678910InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int update = sqlSession.update(&quot;userMapper.update&quot;, user);System.out.println(update);sqlSession.commit();sqlSession.close(); 修改操作注意问题 • 修改语句使用update标签 • 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象); 4.3 MyBatis的删除数据操作 编写UserMapper映射文件 123456&lt;mapper namespace=&quot;userMapper&quot;&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt;//当你传type为一个参数且为简单类型 #写什么都行 编写删除数据的代码 12345678910InputStream resourceAsStream = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);SqlSession sqlSession = sqlSessionFactory.openSession();int delete = sqlSession.delete(&quot;userMapper.delete&quot;,3);System.out.println(delete);sqlSession.commit();sqlSession.close(); 删除操作注意问题 • 删除语句使用delete标签 •Sql语句中使用#{任意字符串}方式引用传递的单个参数 •删除操作使用的API是sqlSession.delete(“命名空间.id”,Object); 4.4 知识小结123456789101112131415161718192021222324增删改查映射配置与API：查询数据： List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;); &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.domain.User&quot;&gt; select * from User &lt;/select&gt; 添加数据： sqlSession.insert(&quot;userMapper.add&quot;, user); &lt;insert id=&quot;add&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt; 修改数据： sqlSession.update(&quot;userMapper.update&quot;, user); &lt;update id=&quot;update&quot; parameterType=&quot;com.itheima.domain.User&quot;&gt; update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125; &lt;/update&gt; 删除数据： sqlSession.delete(&quot;userMapper.delete&quot;,3); &lt;delete id=&quot;delete&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; 5. MyBatis核心配置文件概述5.1 MyBatis核心配置文件层级关系 5.2 MyBatis常用配置解析 environments标签 数据库环境的配置，支持多环境配置 其中，事务管理器（transactionManager）类型有两种： •JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。 •MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。 其中，数据源（dataSource）类型有三种： •UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。 •POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 •JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 mapper标签 该标签的作用是加载映射的，加载方式有如下几种： •使用相对于类路径的资源引用，例如： &lt;mapper resource&#x3D;”org&#x2F;mybatis&#x2F;builder&#x2F;AuthorMapper.xml”&#x2F;&gt; •使用完全限定资源定位符（URL），例如： &lt;mapper url&#x3D;”file:&#x2F;&#x2F;&#x2F;var&#x2F;mappers&#x2F;AuthorMapper.xml”&#x2F;&gt; •使用映射器接口实现类的完全限定类名，例如： &lt;mapper class&#x3D;”org.mybatis.builder.AuthorMapper”&#x2F;&gt; •将包内的映射器接口实现全部注册为映射器，例如： &lt;package name&#x3D;”org.mybatis.builder”&#x2F;&gt; Properties标签 实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件 typeAliases标签 类型别名是为Java 类型设置一个短的名字。 配置typeAliases，为com.itheima.domain.User定义别名为user 上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名 别名 数据类型 string String long Long int Integer double Double boolean Boolean 5.3 知识小结核心配置文件常用配置： properties标签：该标签可以加载外部的properties文件 1&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; typeAliases标签：设置类型别名 1&lt;typeAlias type=&quot;com.itheima.domain.User&quot; alias=&quot;user&quot;&gt;&lt;/typeAlias&gt; mappers标签：加载映射配置 1&lt;mapper resource=&quot;com/itheima/mapper/UserMapping.xml&quot;&gt;&lt;/mapper&gt; environments标签：数据源环境配置标签 6.MyBatis相应API6.1 SqlSession工厂构建器SqlSessionFactoryBuilder常用API：SqlSessionFactory build(InputStream inputStream) 通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象 1234String resource = &quot;org/mybatis/builder/mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(inputStream); 其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。 6.2 SqlSession工厂对象SqlSessionFactorySqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个： 方法 解释 openSession() 会默认开启一个事物，但事物不会自动提交，需要手动提交，更新操作才会持久化到数据库中 openSession(boolean autoCommit) 参数为是否自动提交，如果设置为true，那么不需要手动提交事物 6.3 SqlSession会话对象SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。 执行语句的方法主要有： 12345&lt;T&gt; T selectOne(String statement, Object parameter) &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter) int insert(String statement, Object parameter) int update(String statement, Object parameter) int delete(String statement, Object parameter) 操作事务的方法主要有： 12void commit() void rollback()","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/tags/Mybatis/"}]},{"title":"Type 'java.awt.List' does not have type parameters","slug":"Type-java-awt-List-does-not-have-type-parameters","date":"2022-05-13T09:06:08.000Z","updated":"2022-05-13T09:23:48.485Z","comments":true,"path":"2022/05/13/Type-java-awt-List-does-not-have-type-parameters/","link":"","permalink":"http://example.com/2022/05/13/Type-java-awt-List-does-not-have-type-parameters/","excerpt":"","text":"在写Spring案例中 写service层时 1234public List&lt;Role&gt; list() &#123; List&lt;Role&gt; roleList = roleDao.findAll();//出现错误 return roleList; &#125; 出现错误 Type ‘java.awt.List’ does not have type parameters1List&lt;Role&gt; roleList = roleDao.findAll(); 在使用 List 类的时候会报一个错误，如上所示，这个错误是因为导错了包，将 1import java.awt.List; 改为 1import java.util.List; 但改完后 有出现错误 Incompatible types. Found: ‘java.awt.List&lt;com.itheima.domain.Role&gt;’, required: ‘java.util.List&lt;com.itheima.domain.Role&gt;’可推断出是由类型不匹配导致，idea用强转可以解决问题 最后发现是相关返回没有修改 仔细修改相关返回 知识扩展java.util.List;与 java.awt.List; 的区别 java.util.*与java.awt.都是java的标准库包，其中表示java.util和java.awt包里的所有类。 java.util.*包含的是一些工具类，如集合类中List、Map、HashMap、Set等. java.awt .*则封装的是和图形绘制相关的类，如点Point、线Line等。","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"Spring案例","slug":"Spring案例","date":"2022-05-13T02:35:44.000Z","updated":"2022-05-14T09:54:08.258Z","comments":true,"path":"2022/05/13/Spring案例/","link":"","permalink":"http://example.com/2022/05/13/Spring%E6%A1%88%E4%BE%8B/","excerpt":"","text":"Spring练习01-Spring练习-环境搭建步骤分析(理解)案例环境搭建步骤： ①创建工程（Project&amp;Module） ②导入静态页面（见资料jsp页面） ③导入需要坐标（见资料中的pom.xml） ④创建包结构（controller、service、dao、domain、utils） ⑤导入数据库脚本（见资料test.sql） ⑥创建POJO类（见资料User.java和Role.java） 创建配置文件（applicationContext.xml,spring-mvc.xml,jdbc.properties,log4j.properties） 02-Spring练习-环境搭建实现1(应用)创建工程,导入jsp，添加项目依赖 创建包结构，导入数据库脚本，导入POJO 03-Spring练习-环境搭建实现2(应用)创建Spring的核心配置文件applicationContext.xml 创建SpringMVC核心配置文件spring-mvc.xml 创建数据库配置文件jdbc.properties 拷贝日志配置文件log4j.properties 配置web.xml如下： 1234567891011121314151617181920212223&lt;!--全局的初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--SpringMVC的前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 04-Spring练习-环境搭建实现3(应用)配置springm-mvc.xml：注解驱动，视图解析器，静态资源的开放 配置如下： 1234567891011&lt;!--1、mvc注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2、配置视图解析器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--3、静态资源权限开放--&gt; &lt;mvc:default-servlet-handler/&gt; 05-Spring练习-环境搭建实现4(应用)配置applicationContext.xml：加载propertiest,配置数据源对象，配置JdbcTemplate对象 配置如下： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;!--1、加载jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--2、配置数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--3、配置JdbcTemplate对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 06-Spring练习-用户表和角色表的分析(理解)分析用户和角色在数据库设计中的表关系：多对多关系 07-Spring练习-角色列表展示分析(理解)需求：角色列表展示， 完成该功能的思路和步骤为： ①点击角色管理菜单发送请求到服务器端（修改角色管理菜单的url地址） ②创建RoleController和list()方法 ③创建RoleService和list()方法 ④创建RoleDao和findAll()方法 ⑤使用JdbcTemplate完成查询操作 ⑥将查询数据存储到modelAndView中 ⑦转发到role-list.jsp页面进行展示 08-Spring练习-角色列表展示-controller层实现(应用)1：修改左侧菜单链接地址 123456789101112131415&lt;ul class=&quot;treeview-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/list&quot;&gt; &lt;i class=&quot;fa fa-circle-o&quot;&gt;&lt;/i&gt; 用户管理 &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/role/list&quot;&gt; &lt;i class=&quot;fa fa-circle-o&quot;&gt;&lt;/i&gt; 角色管理 &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/pages/syslog-list.jsp&quot;&gt; &lt;i class=&quot;fa fa-circle-o&quot;&gt;&lt;/i&gt; 访问日志 &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; Controller层代码： 12345678910111213141516171819@RequestMapping(&quot;/role&quot;)@Controllerpublic class RoleController &#123; @Autowired private RoleService roleService; @RequestMapping(&quot;/list&quot;) public ModelAndView list()&#123; ModelAndView modelAndView = new ModelAndView(); List&lt;Role&gt; roleList = roleService.list(); //设置模型 modelAndView.addObject(&quot;roleList&quot;,roleList); //设置视图 modelAndView.setViewName(&quot;role-list&quot;); System.out.println(roleList); return modelAndView; &#125;&#125; 09-Spring练习-角色列表展示-service和dao层实现(应用)service层代码： 123456789101112public class RoleServiceImpl implements RoleService &#123; private RoleDao roleDao; public void setRoleDao(RoleDao roleDao) &#123; this.roleDao = roleDao; &#125; public List&lt;Role&gt; list() &#123; List&lt;Role&gt; roleList = roleDao.findAll(); return roleList; &#125;&#125; dao层代码： 123456789101112public class RoleDaoImpl implements RoleDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; public List&lt;Role&gt; findAll() &#123; List&lt;Role&gt; roleList = jdbcTemplate.query(&quot;select * from sys_role&quot;, new BeanPropertyRowMapper&lt;Role&gt;(Role.class)); return roleList; &#125;&#125; 10-Spring练习-角色列表展示-配置实现(应用)配置spring-mvc.xml 12&lt;!--4、组件扫描 扫描Controller--&gt; &lt;context:component-scan base-package=&quot;com.itheima.controller&quot;/&gt; 配置applicationContext.xml 12345678&lt;!--配置RoleService--&gt; &lt;bean id=&quot;roleService&quot; class=&quot;com.itheima.service.impl.RoleServiceImpl&quot;&gt; &lt;property name=&quot;roleDao&quot; ref=&quot;roleDao&quot;/&gt; &lt;/bean&gt; &lt;!--配置RoleDao--&gt; &lt;bean id=&quot;roleDao&quot; class=&quot;com.itheima.dao.impl.RoleDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt; &lt;/bean&gt; 11-Spring练习-角色列表展示-页面展示(应用)添加命名空间 1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 在role-list.jsp中将数据取出来并展示,核心代码如下： 1234567891011&lt;c:forEach items=&quot;$&#123;roleList&#125;&quot; var=&quot;role&quot;&gt;&lt;tr&gt; &lt;td&gt;&lt;input name=&quot;ids&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;role.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;role.roleName&#125;&lt;/td&gt; &lt;td&gt;$&#123;role.roleDesc&#125;&lt;/td&gt; &lt;td class=&quot;text-center&quot;&gt; &lt;a href=&quot;javascript:void(0);&quot; class=&quot;btn bg-olive btn-xs&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt; 12-Spring练习-角色的添加操作(应用)需求：添加角色 操作步骤如下： ①点击列表页面新建按钮跳转到角色添加页面 ②输入角色信息，点击保存按钮，表单数据提交服务器 ③编写RoleController的save()方法 ④编写RoleService的save()方法 ⑤编写RoleDao的save()方法 ⑥使用JdbcTemplate保存Role数据到sys_role ⑦跳转回角色列表页面 controller代码如下： 12345@RequestMapping(&quot;/save&quot;) public String save(Role role)&#123; roleService.save(role); return &quot;redirect:/role/list&quot;; &#125; service代码如下： 123public void save(Role role) &#123; roleDao.save(role); &#125; dao代码如下： 123public void save(Role role) &#123; jdbcTemplate.update(&quot;insert into sys_role values(?,?,?)&quot;,null,role.getRoleName(),role.getRoleDesc()); &#125; 为了解决post提交中文乱码问题，需要在web.xml中配置全局乱码过滤器 12345678910111213&lt;!--解决乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 测试，完成该功能。 13-Spring练习-用户列表展示1(应用)需求：查询用户列表 完成该功能的操作步骤： ①点击用户管理菜单发送请求到服务器端（修改用户管理菜单的url地址） ②创建UserController和list()方法 ③创建UserService和list()方法 ④创建UserDao和findAll()方法 ⑤使用JdbcTemplate完成查询操作 ⑥将查询数据存储到modelAndView中 ⑦转发到user-list.jsp页面进行展示 跟查询角色列表一样，查询用户列表，创建UserController,UserService,UserDao,User实体等结构，编写各层代码并配置 用户列表Controller,service,dao层代码如下： controller 12345678@RequestMapping(&quot;/list&quot;) public ModelAndView list()&#123; List&lt;User&gt; userList = userService.list(); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;userList&quot;,userList); modelAndView.setViewName(&quot;user-list&quot;); return modelAndView; &#125; service: 12345public List&lt;User&gt; list() &#123; List&lt;User&gt; userList = userDao.findAll(); //封装userList中的每一个User的roles数据 return userList; &#125; dao: 1234public List&lt;User&gt; findAll() &#123; List&lt;User&gt; userList = jdbcTemplate.query(&quot;select * from sys_user&quot;, new BeanPropertyRowMapper&lt;User&gt;(User.class)); return userList; &#125; 14-Spring练习-用户列表展示2(应用)查询用户的时候关联查询出该用户所具有的所有角色信息,需要完善查询用户的service层代码 1，在角色的dao中添加方法，根据用户id查询角色列表 123456//在角色dao中根据用户id查询用户具有的角色信息 public List&lt;Role&gt; findRoleByUserId(Long id) &#123; List&lt;Role&gt; roles = jdbcTemplate.query(&quot;select * from sys_user_role ur,sys_role r where ur.roleId=r.id and ur.userId=?&quot;, new BeanPropertyRowMapper&lt;Role&gt;(Role.class), id); return roles; &#125; 完善userservcie层代码如下： 12345678910111213//在查询用户的service中关联查询用户具有的角色public List&lt;User&gt; list() &#123; List&lt;User&gt; userList = userDao.findAll(); //封装userList中的每一个User的roles数据 for (User user : userList) &#123; //获得user的id Long id = user.getId(); //将id作为参数 查询当前userId对应的Role集合数据 List&lt;Role&gt; roles = roleDao.findRoleByUserId(id); user.setRoles(roles); &#125; return userList; &#125; 查询用户的时候关联查询出该用户所具有的所有角色信息，前端jsp页面核心代码 1234567891011121314151617&lt;c:forEach items=&quot;$&#123;userList&#125;&quot; var=&quot;user&quot;&gt;&lt;tr&gt; &lt;td&gt;&lt;input name=&quot;ids&quot; type=&quot;checkbox&quot;&gt;&lt;/td&gt; &lt;td&gt;$&#123;user.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.phoneNum&#125;&lt;/td&gt; &lt;td class=&quot;text-center&quot;&gt; &lt;c:forEach items=&quot;$&#123;user.roles&#125;&quot; var=&quot;role&quot;&gt; &amp;nbsp;&amp;nbsp;$&#123;role.roleName&#125; &lt;/c:forEach&gt; &lt;/td&gt; &lt;td class=&quot;text-center&quot;&gt; &lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;delUser(&#x27;$&#123;user.id&#125;&#x27;)&quot; class=&quot;btn bg-olive btn-xs&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt; 15-Spring练习-用户添加操作-添加页面展示(应用)需求：添加用户 新建用户时，点击新建按钮先去到添加用户的页面user-add.jsp,在添加用户页面需要展示可供选择的角色信息，因此来到添加页面时需要查询所有的角色信息并展示 去到user-add.jsp页面时先查询所有角色信息的controller代码 12345678@RequestMapping(&quot;/saveUI&quot;) public ModelAndView saveUI()&#123; ModelAndView modelAndView = new ModelAndView(); List&lt;Role&gt; roleList = roleService.list(); modelAndView.addObject(&quot;roleList&quot;,roleList); modelAndView.setViewName(&quot;user-add&quot;); return modelAndView; &#125; 因为查询所有角色信息的service层和dao层代码在之前角色列表展示功能的时候已经写了，因此只需调用即可， 在user-add.jsp页面展示所有角色信息的核心代码 12345&lt;div class=&quot;col-md-10 data&quot;&gt; &lt;c:forEach items=&quot;$&#123;roleList&#125;&quot; var=&quot;role&quot;&gt; &lt;input class=&quot;&quot; type=&quot;checkbox&quot; name=&quot;roleIds&quot; value=&quot;$&#123;role.id&#125;&quot;&gt;$&#123;role.roleName&#125;&lt;/c:forEach&gt;&lt;/div&gt; 16-Spring练习-用户添加操作-添加数据到数据库(应用)","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"Springmvc文件上传&异常处理","slug":"Springmvc文件上传-异常处理","date":"2022-05-12T01:47:42.000Z","updated":"2022-05-12T15:06:00.942Z","comments":true,"path":"2022/05/12/Springmvc文件上传-异常处理/","link":"","permalink":"http://example.com/2022/05/12/Springmvc%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"SpringMVC的文件上传1-SpringMVC的请求-文件上传-客户端表单实现(应用)文件上传客户端表单需要满足： 表单项type&#x3D;“file” 表单的提交方式是post 表单的enctype属性是多部分表单形式，及enctype&#x3D;“multipart&#x2F;form-data” 12345&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/quick22&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 2-SpringMVC的请求-文件上传-文件上传的原理(理解)![截屏2022-05-12 09.56.09](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;Springmvc文件上传-异常处理&#x2F;截屏2022-05-12 09.56.09.png) 3-SpringMVC的请求-文件上传-单文件上传的代码实现1(应用)添加依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; 配置多媒体解析器 12345&lt;!--配置文件上传解析器--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UYF-8&quot;/&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;500000&quot;/&gt; &lt;/bean&gt; 后台程序 123456@RequestMapping(value=&quot;/quick22&quot;) @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException &#123; System.out.println(username); System.out.println(uploadFile); &#125; 4-SpringMVC的请求-文件上传-单文件上传的代码实现2(应用)完成文件上传 12345678@RequestMapping(value=&quot;/quick22&quot;) @ResponseBody public void save22(String username, MultipartFile uploadFile) throws IOException &#123; System.out.println(username); //获得上传文件的名称 String originalFilename = uploadFile.getOriginalFilename(); uploadFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); &#125; 5-SpringMVC的请求-文件上传-多文件上传的代码实现(应用)多文件上传，只需要将页面修改为多个文件上传项，将方法参数MultipartFile类型修改为MultipartFile[]即可 123456&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/quick23&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 名称&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 文件1&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; 文件2&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 123456789@RequestMapping(value=&quot;/quick23&quot;) @ResponseBody public void save23(String username, MultipartFile[] uploadFile) throws IOException &#123; System.out.println(username); for (MultipartFile multipartFile : uploadFile) &#123; String originalFilename = multipartFile.getOriginalFilename(); multipartFile.transferTo(new File(&quot;C:\\\\upload\\\\&quot;+originalFilename)); &#125; &#125; 6-SpringMVC的请求-知识要点(理解，记忆)MVC实现数据请求方式 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 MVC获取数据细节 中文乱码问题 @RequestParam和@PathVariable 自定义类型转换器 获得Servlet相关API @RequestHeader和@CookieValue 文件上传 SpringMVC的拦截器01-SpringMVC拦截器-拦截器的作用(理解)Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。 将拦截器按一定的顺序联结成一条链，这条链称为拦截器链（InterceptorChain）。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。拦截器也是AOP思想的具体实现。 02-SpringMVC拦截器-interceptor和filter区别(理解，记忆)关于interceptor和filter的区别，如图所示： 区别 过滤器 拦截器 使用范围 是 servlet 规范中的一部分，任何Java Web 工程都可以使用 是 SpringMVC 框架自己的，只有使用了SpringMVC 框架的工程才能用 拦截范围 在 url-pattern 中配置了&#x2F;*之后，可以对所有要访问的资源拦截 只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者 js 是不会进行拦截的 03-SpringMVC拦截器-快速入门(应用)自定义拦截器很简单，只有如下三步： ①创建拦截器类实现HandlerInterceptor接口 ②配置拦截器 ③测试拦截器的拦截效果 编写拦截器： 1234567891011121314public class MyInterceptor1 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; System.out.println(&quot;preHandle.....&quot;);&#125; //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123;System.out.println(&quot;postHandle...&quot;); &#125; //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(&quot;afterCompletion....&quot;); &#125;&#125; 配置：在SpringMVC的配置文件中配置 12345678&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 编写测试程序测试： 编写Controller,发请求到controller,跳转页面 12345678910111213@Controllerpublic class TargetController &#123; @RequestMapping(&quot;/target&quot;) public ModelAndView show()&#123; System.out.println(&quot;目标资源执行......&quot;); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;name&quot;,&quot;itcast&quot;); modelAndView.setViewName(&quot;index&quot;); return modelAndView; &#125;&#125; 页面 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World! $&#123;name&#125;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 04-SpringMVC拦截器-快速入门详解(应用)拦截器在预处理后什么情况下会执行目标资源，什么情况下不执行目标资源，以及在有多个拦截器的情况下拦截器的执行顺序是什么? 再编写一个拦截器2 1234567891011121314151617public class MyInterceptor2 implements HandlerInterceptor &#123; //在目标方法执行之前 执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException &#123; System.out.println(&quot;preHandle22222.....&quot;); return true; &#125; //在目标方法执行之后 视图对象返回之前执行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; System.out.println(&quot;postHandle2222...&quot;); &#125; //在流程都执行完毕后 执行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println(&quot;afterCompletion2222....&quot;); &#125;&#125; 配置拦截器2 12345678910111213&lt;!--配置拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor2&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;!--对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.MyInterceptor1&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 结论： 当拦截器的preHandle方法返回true则会执行目标资源，如果返回false则不执行目标资源 多个拦截器情况下，配置在前的先执行，配置在后的后执行 拦截器中的方法执行顺序是：preHandler——-目标资源—-postHandle—- afterCompletion 05-SpringMVC拦截器-知识小结(记忆)拦截器中的方法说明如下 方法名 说明 preHandle() 方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的，当它返回为false时，表示请求结束，后续的Interceptor 和Controller 都不会再执行；当返回值为true时就会继续调用下一个Interceptor 的preHandle 方法 postHandle() 该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为true 时才能被调用，且它会在DispatcherServlet 进行视图返回渲染之前被调用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象进行操作 afterCompletion() 该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行，前提是preHandle 方法的返回值为true 时才能被调用 06-SpringMVC拦截器-用户登录权限控制分析(理解)在day06-Spring练习案例的基础之上：用户没有登录的情况下，不能对后台菜单进行访问操作，点击菜单跳转到登录页面，只有用户登录成功后才能进行后台功能的操作 07-SpringMVC拦截器-用户登录权限控制代码实现1(应用)判断用户是否登录 本质：判断session中有没有user，如果没有登陆则先去登陆，如果已经登陆则直接放行访问目标资源 先编写拦截器如下： 1234567891011121314public class PrivilegeInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws IOException &#123; //逻辑：判断用户是否登录 本质：判断session中有没有user HttpSession session = request.getSession(); User user = (User) session.getAttribute(&quot;user&quot;); if(user==null)&#123; //没有登录 response.sendRedirect(request.getContextPath()+&quot;/login.jsp&quot;); return false; &#125; //放行 访问目标资源 return true; &#125;&#125; 然后配置该拦截器：找到项目案例的spring-mvc.xml，添加如下配置： 12345678&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 08-SpringMVC拦截器-用户登录权限控制代码实现2(应用)在登陆页面输入用户名密码，点击登陆，通过用户名密码进行查询，如果登陆成功，则将用户信息实体存入session，然后跳转到首页，如果登陆失败则继续回到登陆页面 在UserController中编写登陆逻辑 12345678910@RequestMapping(&quot;/login&quot;) public String login(String username,String password,HttpSession session)&#123; User user = userService.login(username,password); if(user!=null)&#123; //登录成功 将user存储到session session.setAttribute(&quot;user&quot;,user); return &quot;redirect:/index.jsp&quot;; &#125; return &quot;redirect:/login.jsp&quot;; &#125; service层代码如下： 12345//service层public User login(String username, String password) &#123; User user = userDao.findByUsernameAndPassword(username,password); return user;&#125; dao层代码如下： 12345//dao层 public User findByUsernameAndPassword(String username, String password) throws EmptyResultDataAccessException&#123; User user = jdbcTemplate.queryForObject(&quot;select * from sys_user where username=? and password=?&quot;, new BeanPropertyRowMapper&lt;User&gt;(User.class), username, password); return user; &#125; 此时仍然登陆不上，因为我们需要将登陆请求url让拦截器放行,添加资源排除的配置 12345678910&lt;!--配置权限拦截器--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--配置对哪些资源执行拦截操作--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--配置哪些资源排除拦截操作--&gt; &lt;mvc:exclude-mapping path=&quot;/user/login&quot;/&gt; &lt;bean class=&quot;com.itheima.interceptor.PrivilegeInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 09-SpringMVC拦截器-用户登录权限控制代码实现3(应用)JdbcTemplate.queryForObject对象如果查询不到数据会抛异常，导致程序无法达到预期效果，如何来解决该问题？ 在业务层处理来自dao层的异常，如果出现异常service层返回null,而不是将异常抛给controller 因此改造登陆的业务层代码,添加异常的控制 12345678public User login(String username, String password) &#123; try &#123; User user = userDao.findByUsernameAndPassword(username,password); return user; &#125;catch (EmptyResultDataAccessException e)&#123; return null; &#125; &#125; 1. SpringMVC异常处理机制1.1 异常处理的思路系统中异常包括两类：预期异常和运行时异常RuntimeException，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。 系统的Dao、Service、Controller出现都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图： 1.2 异常处理两种方式① 使用Spring MVC提供的简单异常处理器SimpleMappingExceptionResolver ② 实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器 ![截屏2022-05-12 22.39.15](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;Springmvc文件上传-异常处理&#x2F;截屏2022-05-12 22.39.15.png) 1.3 简单异常处理器SimpleMappingExceptionResolverSpringMVC已经定义好了该类型转换器，在使用时可以根据项目情况进行相应异常与视图的映射配置 123456789&lt;!--配置简单映射异常处理器--&gt; &lt;bean class=“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”&gt; &lt;property name=“defaultErrorView” value=“error”/&gt; 默认错误视图 &lt;property name=“exceptionMappings”&gt; &lt;map&gt; 异常类型 错误视图 &lt;entry key=&quot;com.itheima.exception.MyException&quot; value=&quot;error&quot;/&gt; &lt;entry key=&quot;java.lang.ClassCastException&quot; value=&quot;error&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 1.4 自定义异常处理步骤①创建异常处理器类实现HandlerExceptionResolver 1234567891011public class MyExceptionResolver implements HandlerExceptionResolver &#123;@Overridepublic ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //处理异常的代码实现 //创建ModelAndView对象 ModelAndView modelAndView = new ModelAndView(); modelAndView.setViewName(&quot;exceptionPage&quot;); return modelAndView; &#125;&#125; ②配置异常处理器 12&lt;bean id=&quot;exceptionResolver&quot; class=&quot;com.itheima.exception.MyExceptionResolver&quot;/&gt; ③编写异常页面 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是一个最终异常的显示页面&lt;/body&gt;&lt;/html&gt; ④测试异常跳转 123456@RequestMapping(&quot;/quick22&quot;)@ResponseBodypublic void quickMethod22() throws IOException, ParseException &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); simpleDateFormat.parse(&quot;abcde&quot;);&#125; 1.5 知识要点异常处理方式 配置简单异常处理器SimpleMappingExceptionResolver 自定义异常处理器 自定义异常处理步骤 创建异常处理器类实现HandlerExceptionResolver 配置异常处理器 编写异常页面 测试异常跳转","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"SpringMVC的请求和响应","slug":"SpringMVC的请求和响应","date":"2022-05-10T03:08:13.000Z","updated":"2022-05-12T14:19:04.747Z","comments":true,"path":"2022/05/10/SpringMVC的请求和响应/","link":"","permalink":"http://example.com/2022/05/10/SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/","excerpt":"","text":"SpringMVC的请求和响应SpringMVC的数据响应01-SpringMVC的数据响应-数据响应方式(理解)页面跳转直接返回字符串 通过ModelAndView对象返回 回写数据直接返回字符串 返回对象或集合 02-SpringMVC的数据响应-页面跳转-返回字符串形式（应用）![截屏2022-05-11 09.18.37](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;SpringMVC的请求和响应&#x2F;截屏2022-05-11 09.18.37.png) 03-SpringMVC的数据响应-页面跳转-返回ModelAndView形式1(应用)在Controller中方法返回ModelAndView对象，并且设置视图名称 1234567891011121314@RequestMapping(value=&quot;/quick2&quot;) public ModelAndView save2()&#123; /* Model:模型 作用封装数据 View：视图 作用展示数据 */ ModelAndView modelAndView = new ModelAndView(); //设置模型数据 modelAndView.addObject(&quot;username&quot;,&quot;itcast&quot;); //设置视图名称 modelAndView.setViewName(&quot;success&quot;); return modelAndView; &#125; 04-SpringMVC的数据响应-页面跳转-返回ModelAndView形式2(应用)n在Controller中方法形参上直接声明ModelAndView，无需在方法中自己创建，在方法中直接使用该对象设置视图，同样可以跳转页面 1234567891011@RequestMapping(value=&quot;/quick3&quot;) public ModelAndView save3(ModelAndView modelAndView)&#123; modelAndView.addObject(&quot;username&quot;,&quot;itheima&quot;); modelAndView.setViewName(&quot;success&quot;); return modelAndView; &#125;@RequestMapping(value=&quot;/quick4&quot;) public String save4(Model model)&#123; model.addAttribute(&quot;username&quot;,&quot;博学谷&quot;); return &quot;success&quot;; &#125; 05-SpringMVC的数据响应-页面跳转-返回ModelAndView3(应用)在Controller方法的形参上可以直接使用原生的HttpServeltRequest对象，只需声明即可 12345@RequestMapping(value=&quot;/quick5&quot;) public String save5(HttpServletRequest request)&#123; request.setAttribute(&quot;username&quot;,&quot;酷丁鱼&quot;); return &quot;success&quot;; &#125; 06-SpringMVC的数据响应-回写数据-直接回写字符串(应用)通过SpringMVC框架注入的response对象，使用response.getWriter().print(“hello world”) 回写数据，此时不需要视图跳转，业务方法返回值为void 将需要回写的字符串直接返回，但此时需要通过@ResponseBody注解告知SpringMVC框架，方法返回的字符串不是跳转是直接在http响应体中返回 12345678910@RequestMapping(value=&quot;/quick7&quot;) @ResponseBody //告知SpringMVC框架 不进行视图跳转 直接进行数据响应 public String save7() throws IOException &#123; return &quot;hello itheima&quot;; &#125; @RequestMapping(value=&quot;/quick6&quot;) public void save6(HttpServletResponse response) throws IOException &#123; response.getWriter().print(&quot;hello itcast&quot;); &#125; 07-SpringMVC的数据响应-回写数据-直接回写json格式字符串(应用)12345@RequestMapping(value=&quot;/quick8&quot;) @ResponseBody public String save8() throws IOException &#123; return &quot;&#123;\\&quot;username\\&quot;:\\&quot;zhangsan\\&quot;,\\&quot;age\\&quot;:18&#125;&quot;; &#125; 手动拼接json格式字符串的方式很麻烦，开发中往往要将复杂的java对象转换成json格式的字符串，我们可以使用web阶段学习过的json转换工具jackson进行转换,通过jackson转换json格式字符串，回写字符串 123456789101112@RequestMapping(value=&quot;/quick9&quot;) @ResponseBody public String save9() throws IOException &#123; User user = new User(); user.setUsername(&quot;lisi&quot;); user.setAge(30); //使用json的转换工具将对象转换成json格式字符串在返回 ObjectMapper objectMapper = new ObjectMapper(); String json = objectMapper.writeValueAsString(user); return json; &#125; 08-SpringMVC的数据响应-回写数据-返回对象或集合(应用)通过SpringMVC帮助我们对对象或集合进行json字符串的转换并回写，为处理器适配器配置消息转换参数，指定使用jackson进行对象或集合的转换，因此需要在spring-mvc.xml中进行如下配置： 1234567&lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 123456789@RequestMapping(value=&quot;/quick10&quot;) @ResponseBody //期望SpringMVC自动将User转换成json格式的字符串 public User save10() throws IOException &#123; User user = new User(); user.setUsername(&quot;lisi2&quot;); user.setAge(32); return user; &#125; 09-SpringMVC的数据响应-回写数据-返回对象或集合2(应用)在方法上添加@ResponseBody就可以返回json格式的字符串，但是这样配置比较麻烦，配置的代码比较多，因此，我们可以使用mvc的注解驱动代替上述配置 1&lt;mvc:annotation-driven/&gt; 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 使用&lt;mvc:annotation-driven /&gt;自动加载 RequestMappingHandlerMapping（处理映射器）和 RequestMappingHandlerAdapter（ 处 理 适 配 器 ），可用在Spring-xml.xml配置文件中使用 &lt;mvc:annotation-driven /&gt;替代注解处理器和适配器的配置。 同时使用&lt;mvc:annotation-driven /&gt; 默认底层就会集成jackson进行对象或集合的json格式字符串的转换 10-SpringMVC的数据响应-知识要点小结(理解，记忆)1） 页面跳转 直接返回字符串 通过ModelAndView对象返回 2） 回写数据 直接返回字符串 HttpServletResponse 对象直接写回数据，HttpServletRequest对象带回数据，Model对象带回数据或者@ResponseBody将字符串数据写回 返回对象或集合 @ResponseBody+&lt;mvc:annotation-driven/&gt; SpringMVC的请求11-SpringMVC的请求-获得请求参数-请求参数类型(理解)客户端请求参数的格式是：name&#x3D;value&amp;name&#x3D;value…… 服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数 基本类型参数 POJO类型参数 数组类型参数 集合类型参数 12-SpringMVC的请求-获得请求参数-获得基本类型参数(应用)Controller中的业务方法的参数名称要与请求参数的name一致，参数值会自动映射匹配。并且能自动做类型转换； 自动的类型转换是指从String向其他类型的转换 http://localhost:8080/itheima_springmvc1/quick9?username=zhangsan&amp;age=12 123456@RequestMapping(value=&quot;/quick11&quot;) @ResponseBody//不就行页面跳转 public void save11(String username,int age) throws IOException &#123; System.out.println(username); System.out.println(age); &#125; 13-SpringMVC的请求-获得请求参数-获得POJO类型参数(应用)Controller中的业务方法的POJO参数的属性名与请求参数的name一致，参数值会自动映射匹配。 12345678910111213141516171819202122232425262728293031package com.itheima.domain;public class User &#123; private String username; private int age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 12345@RequestMapping(value=&quot;/quick12&quot;) @ResponseBody public void save12(User user) throws IOException &#123; System.out.println(user); &#125; 14-SpringMVC的请求-获得请求参数-获得数组类型参数(应用)Controller中的业务方法数组名称与请求参数的name一致，参数值会自动映射匹配。 http://localhost:8080/itheima_springmvc1/quick13?strs=111&amp;strs=222&amp;strs=333 12345@RequestMapping(value=&quot;/quick13&quot;) @ResponseBody public void save13(String[] strs) throws IOException &#123; System.out.println(Arrays.asList(strs)); &#125; 15-SpringMVC的请求-获得请求参数-获得集合类型参数1(应用)获得集合参数时，要将集合参数包装到一个POJO中才可以。 12345678&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/quick14&quot; method=&quot;post&quot;&gt; &lt;%--表明是第一个User对象的username age--%&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[0].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].username&quot;&gt;&lt;br/&gt; &lt;input type=&quot;text&quot; name=&quot;userList[1].age&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 1234567891011121314151617181920212223package com.itheima.domain;import java.util.List;public class VO &#123; private List&lt;User&gt; userList; public List&lt;User&gt; getUserList() &#123; return userList; &#125; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public String toString() &#123; return &quot;VO&#123;&quot; + &quot;userList=&quot; + userList + &#x27;&#125;&#x27;; &#125;&#125; 12345@RequestMapping(value=&quot;/quick14&quot;) @ResponseBody public void save14(VO vo) throws IOException &#123; System.out.println(vo); &#125; 16-SpringMVC的请求-获得请求参数-获得集合类型参数2(应用)当使用ajax提交时，可以指定contentType为json形式，那么在方法参数位置使用@RequestBody可以直接接收集合数据而无需使用POJO进行包装 1234567891011121314&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var userList = new Array(); userList.push(&#123;username:&quot;zhangsan&quot;,age:18&#125;); userList.push(&#123;username:&quot;lisi&quot;,age:28&#125;); $.ajax(&#123; type:&quot;POST&quot;, url:&quot;$&#123;pageContext.request.contextPath&#125;/user/quick15&quot;, data:JSON.stringify(userList), contentType:&quot;application/json;charset=utf-8&quot; &#125;); &lt;/script&gt; 12345@RequestMapping(value=&quot;/quick15&quot;) @ResponseBody public void save15(@RequestBody List&lt;User&gt; userList) throws IOException &#123; System.out.println(userList); &#125; 在spring-mvc.xml文件中 1&lt;mvc:default-servlet-handler/&gt; 17-SpringMVC的请求-获得请求参数-静态资源访问的开启(应用)当有静态资源需要加载时，比如jquery文件，通过谷歌开发者工具抓包发现，没有加载到jquery文件，原因是SpringMVC的前端控制器DispatcherServlet的url-pattern配置的是&#x2F;,代表对所有的资源都进行过滤操作，我们可以通过以下两种方式指定放行静态资源： 在spring-mvc.xml配置文件中指定放行的资源 &lt;mvc:resources mapping=&quot;/js/**&quot;location=&quot;/js/&quot;/&gt; 使用&lt;mvc:default-servlet-handler/&gt;标签 交给原始的容器tomcat帮你找静态资源 12345&lt;!--开发资源的访问--&gt; &lt;!--&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot;/&gt; &lt;mvc:resources mapping=&quot;/img/**&quot; location=&quot;/img/&quot;/&gt;--&gt; &lt;mvc:default-servlet-handler/&gt; 18-SpringMVC的请求-获得请求参数-配置全局乱码过滤器(应用)当post请求时，数据会出现乱码，我们可以设置一个过滤器来进行编码的过滤。 12345678910111213&lt;!--配置全局过滤的filter--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 19-SpringMVC的请求-获得请求参数-参数绑定注解@RequestParam(应用)当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过@RequestParam注解显示的绑定 还有以下参数 value：与请求参数名称 required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错 defaultValue：当没有指定请求参数时，则使用指定的默认值赋值 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/quick16&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;&lt;/form&gt; 12345@RequestMapping(value=&quot;/quick16&quot;) @ResponseBody public void save16(@RequestParam(value=&quot;name&quot;,required = false,defaultValue = &quot;itcast&quot;) String username) throws IOException &#123; System.out.println(username); &#125; 20-SpringMVC的请求-获得请求参数-Restful风格的参数的获取(应用)Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。 Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下： GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 例如： &#x2F;user&#x2F;1 GET ： 得到 id &#x3D; 1 的 user &#x2F;user&#x2F;1 DELETE： 删除 id &#x3D; 1 的 user &#x2F;user&#x2F;1 PUT： 更新 id &#x3D; 1 的 user &#x2F;user POST： 新增 user 上述url地址&#x2F;user&#x2F;1中的1就是要获得的请求参数，在SpringMVC中可以使用占位符进行参数绑定。地址&#x2F;user&#x2F;1可以写成&#x2F;user&#x2F;{id}，占位符{id}对应的就是1的值。在业务方法中我们可以使用@PathVariable注解进行占位符的匹配获取工作。 http://localhost:8080/itheima_springmvc1/quick17/zhangsan 12345@RequestMapping(value=&quot;/quick17/&#123;name&#125;&quot;)@ResponseBody public void save17(@PathVariable(value=&quot;name&quot;) String username) throws IOException &#123; System.out.println(username); &#125; 21-SpringMVC的请求-获得请求参数-自定义类型转换器(应用)SpringMVC 默认已经提供了一些常用的类型转换器，例如客户端提交的字符串转换成int型进行参数设置。 但是不是所有的数据类型都提供了转换器，没有提供的就需要自定义转换器，例如：日期类型的数据就需要自定义转换器。 自定义类型转换器的开发步骤： 定义转换器类实现Converter接口 在配置文件中声明转换器 在&lt;annotation-driven&gt;中引用转换器 12345678910111213public class DateConverter implements Converter&lt;String, Date&gt; &#123; public Date convert(String dateStr) &#123; //将日期字符串转换成日期对象 返回 SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date date = null; try &#123; date = format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125;&#125; 12345@RequestMapping(value=&quot;/quick18&quot;) @ResponseBody public void save18(Date date) throws IOException &#123; System.out.println(date); &#125; 12345678&lt;bean id=&quot;converterService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.converter.DateConverter&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 1&lt;mvc:annotation-driven conversion service=&quot;converterService&quot;/&gt; 22-SpringMVC的请求-获得请求参数-获得Servlet相关API(应用)SpringMVC支持使用原始ServletAPI对象作为控制器方法的参数进行注入，常用的对象如下： HttpServletRequest HttpServletResponse HttpSession 1234567@RequestMapping(value=&quot;/quick19&quot;) @ResponseBody public void save19(HttpServletRequest request, HttpServletResponse response, HttpSession session) throws IOException &#123; System.out.println(request); System.out.println(response); System.out.println(session); &#125; 23-SpringMVC的请求-获得请求参数-获得请求头信息(应用)使用@RequestHeader可以获得请求头信息，相当于web阶段学习的request.getHeader(name) @RequestHeader注解的属性如下： value：请求头的名称 required：是否必须携带此请求头 12345@RequestMapping(value=&quot;/quick20&quot;) @ResponseBody public void save20(@RequestHeader(value = &quot;User-Agent&quot;,required = false) String user_agent) throws IOException &#123; System.out.println(user_agent); &#125; 使用@CookieValue可以获得指定Cookie的值 @CookieValue注解的属性如下： value：指定cookie的名称 required：是否必须携带此cookie 12345@RequestMapping(value=&quot;/quick21&quot;) @ResponseBody public void save21(@CookieValue(value = &quot;JSESSIONID&quot;) String jsessionId) throws IOException &#123; System.out.println(jsessionId); &#125;","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"小程序-视图与逻辑","slug":"小程序-视图与逻辑","date":"2022-05-09T12:55:12.000Z","updated":"2022-05-09T14:55:09.818Z","comments":true,"path":"2022/05/09/小程序-视图与逻辑/","link":"","permalink":"http://example.com/2022/05/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%A7%86%E5%9B%BE%E4%B8%8E%E9%80%BB%E8%BE%91/","excerpt":"","text":"目录 页面导航 页面事件 生命周期 WXS 脚本 案例 - 本地生活（列表页面） 页面导航什么是页面导航页面导航指的是页面之间的相互跳转。例如，浏览器中实现页面导航的方式有如下两种： &lt;a&gt; 链接 location.href 小程序中实现页面导航的两种方式 声明式导航 在页面上声明一个 &lt;navigator&gt; 导航组件 通过点击 &lt;navigator&gt; 组件实现页面跳转 编程式导航 调用小程序的导航 API，实现页面的跳转 页面导航 - 声明式导航导航到 tabBar 页面tabBar 页面指的是被配置为 tabBar 的页面。 在使用 &lt;navigator&gt; 组件跳转到指定的 tabBar 页面时，需要指定 url 属性和 open-type 属性，其中： url 表示要跳转的页面的地址，必须以 &#x2F; 开头 open-type 表示跳转的方式，必须为 switchTab 1&lt;navigator url=&quot;/pages/home/home&quot; open-type=&quot;switchTab&quot;&gt;导航到主页&lt;/navigator&gt; 导航到非 tabBar 页面非 tabBar 页面指的是没有被配置为 tabBar 的页面。 在使用&lt;navigator&gt; 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 open-type 属性，其中： url 表示要跳转的页面的地址，必须以 &#x2F; 开头 open-type 表示跳转的方式，必须为 navigate 1&lt;navigator url=&quot;/pages/home/home&quot; open-type=&quot;navigate&quot;&gt;导航到主页&lt;/navigator&gt; 注意：为了简便，在导航到非 tabBar 页面时，open-type&#x3D;”navigate” 属性可以省略。 后退导航如果要后退到上一页面或多级页面，则需要指定 open-type 属性和 delta 属性，其中： open-type 的值必须是 navigateBack，表示要进行后退导航 delta 的值必须是数字，表示要后退的层级 1&lt;navigator open-type=&quot;navigateBack&quot; delta=&quot;1&quot;&gt;返回上一页&lt;/navigator&gt; 注意：为了简便，如果只是后退到上一页面，则可以省略 delta 属性，因为其默认值就是 1。 页面导航 - 编程式导航导航到 tabBar 页面调用 wx.switchTab(Object object) 方法，可以跳转到 tabBar 页面。其中 Object 参数对象的属性列表如下： 属性 类型 是否必须 说明 url string 是 需要跳转的 tabBar 页面的路径，路径后不能带参数 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 代码1&lt;button bindtap=&quot;gotoHome&quot;&gt;跳转到home页面&lt;/button&gt; 12345gotoHome() &#123; wx.switchTab(&#123; url: &#x27;/pages/home/home&#x27;, &#125;) &#125;, 导航到非 tabBar 页面调用 wx.navigateTo(Object object) 方法，可以跳转到非 tabBar 的页面。其中 Object 参数对象的属性列表 属性 类型 是否必选 说明 url string 是 需要跳转到的非 tabBar 页面的路径，路径后可以带参数 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 代码1&lt;button bindtap=&quot;gotoInfo&quot;&gt;跳转到home页面&lt;/button&gt; 12345gotoHome() &#123; wx.navigateTo(&#123; url: &#x27;/pages/info/info&#x27;, &#125;) &#125;, 后退导航调用 wx.navigateBack(Object object) 方法，可以返回上一页面或多级页面。其中 Object 参数对象可选的 属性 类型 默认值 是否必选 说明 delta number 1 否 返回的页面数，如果 delta 大于现有页面数，则返回到首页 success function 否 接口调用成功的回调函数 fail function 否 接口调用失败的回调函数 complete function 否 接口调用结束的回调函数（调用成功、失败都会执行） 代码1&lt;button bindtap=&quot;gotoBack&quot;&gt;后退&lt;/button&gt; 123gotoBack() &#123; wx.navigateBack()&#125; 页面导航 - 导航传参声明式导航传参navigator 组件的 url 属性用来指定将要跳转到的页面的路径。同时，路径的后面还可以携带参数： 参数与路径之间使用 ? 分隔 参数键与参数值用 &#x3D; 相连 不同参数用 &amp; 分隔 1&lt;navigator url=&quot;/pages/info/info?name=mhy&amp;age=20&quot;&gt;跳转到info页面&lt;/navigator&gt; 注意：不能跳转到tabBar页面 编程式导航传参调用 wx.navigateTo(Object object) 方法跳转页面时，也可以携带参数 1&lt;button bindtap=&quot;gotoinfo2&quot;&gt;跳转到info&lt;/button&gt; 12345gotoinfo2() &#123; wx.navigateTo(&#123; url: &#x27;/pages/info/info?name=ls&amp;gender=男&#x27; &#125;)&#125; 在 onLoad 中接收导航参数通过声明式导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 事件中直接获取到","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Spring集成web开发环境","slug":"Spring集成web开发环境","date":"2022-05-09T00:40:41.000Z","updated":"2022-05-09T07:41:31.206Z","comments":true,"path":"2022/05/09/Spring集成web开发环境/","link":"","permalink":"http://example.com/2022/05/09/Spring%E9%9B%86%E6%88%90web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/","excerpt":"","text":"1. Spring与Web环境集成1.1 ApplicationContext应用上下文获取方式应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 方式获取的，但是每次从容器中获得Bean时都要编写new ClasspathXmlApplicationContext(spring配置文件) ，这样的弊端是配置文件加载多次，应用上下文对象创建多次。 在Web项目中，可以使用ServletContextListener监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。 1.2 Spring提供获取应用上下文的工具上面的分析不用手动实现，Spring提供了一个监听器ContextLoaderListener就是对上述功能的封装，该监听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具WebApplicationContextUtils供使用者获得应用上下文对象。 所以我们需要做的只有两件事： ①在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） ②使用WebApplicationContextUtils获得应用上下文对象ApplicationContext 1.3 导入Spring集成web的坐标12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.4 配置ContextLoaderListener监听器1234567891011&lt;!--全局参数--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--Spring的监听器--&gt;&lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; 1.5 通过工具获得应用上下文对象123ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext); Object obj = applicationContext.getBean(&quot;id&quot;); 知识要点 Spring集成web环境步骤 ​ ①配置ContextLoaderListener监听器 ​ ②使用WebApplicationContextUtils获得应用上下文 2. SpringMVC的简介2.1 SpringMVC概述SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于SpringFrameWork 的后续产品，已经融合在 Spring Web Flow 中。 SpringMVC 已经成为目前最主流的MVC框架之一，并且随着Spring3.0 的发布，全面超越 Struts2，成为最优秀的 MVC 框架。它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。 2.3 SpringMVC快速入门需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。 开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet（前端控制器） ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml(配置组件扫描) ⑥客户端发起请求测试 代码实现 ①导入Spring和SpringMVC的坐标、导入Servlet和Jsp的坐标 123456789101112131415161718192021222324 &lt;!--Spring坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;!--Servlet坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jsp坐标--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt;&lt;/dependency&gt; ②在web.xml配置SpringMVC的核心控制器 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ③创建Controller和业务方法 123456public class QuickController &#123; public String quickMethod()&#123; System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; &#125;&#125; ③创建视图页面index.jsp 12345&lt;html&gt;&lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; ④配置注解 12345678@Controllerpublic class QuickController &#123; @RequestMapping(&quot;/quick&quot;) public String quickMethod()&#123; System.out.println(&quot;quickMethod running.....&quot;); return &quot;index&quot;; &#125;&#125; ⑤创建spring-mvc.xml 12345678910111213&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解扫描--&gt; &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;/beans&gt; ⑥访问测试地址 1http://localhost:8080/itheima_springmvc1/quick 2.3 SpringMVC流程图示![截屏2022-05-09 14.48.28](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;Spring集成web开发环境&#x2F;截屏2022-05-09 14.48.28.png) 2.4 知识要点SpringMVC的开发步骤 ①导入SpringMVC相关坐标 ②配置SpringMVC核心控制器DispathcerServlet ③创建Controller类和视图页面 ④使用注解配置Controller类中业务方法的映射地址 ⑤配置SpringMVC核心文件 spring-mvc.xml ⑥客户端发起请求测试 3. SpringMVC的组件解析3.1 SpringMVC的执行流程![截屏2022-05-09 14.55.29](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;Spring集成web开发环境&#x2F;截屏2022-05-09 14.55.29.png)①用户发送请求至前端控制器DispatcherServlet。 ②DispatcherServlet收到请求调用HandlerMapping处理器映射器。 ③处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 ④DispatcherServlet调用HandlerAdapter处理器适配器。 ⑤HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 ⑥Controller执行完成返回ModelAndView。 ⑦HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。 ⑧DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ⑨ViewReslover解析后返回具体View。 ⑩DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户。 3.2 SpringMVC组件解析 前端控制器：DispatcherServlet ​ 用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器：HandlerMapping ​ HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器适配器：HandlerAdapter ​ 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 处理器：Handler ​ 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 视图解析器：View Resolver ​ View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 视图：View ​ SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面 3.3 SpringMVC注解解析@RequestMapping 作用：用于建立请求 URL 和处理请求方法之间的对应关系 位置： ​ 类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 ​ 方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径 属性： ​ value：用于指定请求的URL。它和path属性的作用是一样的 ​ method：用于指定请求的方式 ​ params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 例如： ​ params &#x3D; {“accountName”}，表示请求参数必须有accountName ​ params &#x3D; {“moeny!100”}，表示请求参数中money不能是100 1.mvc命名空间引入 123456命名空间：xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;约束地址：http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd 组件扫描 SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用&lt;context:component-scan base-package&#x3D;“com.itheima.controller”&#x2F;&gt;进行组件扫描。 3.4 SpringMVC的XML配置解析SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址org&#x2F;springframework&#x2F;web&#x2F;servlet&#x2F;DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下： 1org.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolver 翻看该解析器源码，可以看到该解析器的默认设置，如下： 1234REDIRECT_URL_PREFIX = &quot;redirect:&quot; --重定向前缀FORWARD_URL_PREFIX = &quot;forward:&quot; --转发前缀（默认值）prefix = &quot;&quot;; --视图名称前缀suffix = &quot;&quot;; --视图名称后缀 视图解析器 我们可以通过属性注入的方式修改视图的的前后缀 12345&lt;!--配置内部资源视图解析器--&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3.5 知识要点SpringMVC的相关组件 前端控制器：DispatcherServlet 处理器映射器：HandlerMapping 处理器适配器：HandlerAdapter 处理器：Handler 视图解析器：View Resolver 视图：View SpringMVC的注解和配置 请求映射注解：@RequestMapping 视图解析器配置： REDIRECT_URL_PREFIX &#x3D; “redirect:” FORWARD_URL_PREFIX &#x3D; “forward:” prefix &#x3D; “”; suffix &#x3D; “”;","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"spring jdbcTemplate","slug":"spring-jdbcTemplate","date":"2022-05-08T02:40:58.000Z","updated":"2022-05-08T14:26:36.828Z","comments":true,"path":"2022/05/08/spring-jdbcTemplate/","link":"","permalink":"http://example.com/2022/05/08/spring-jdbcTemplate/","excerpt":"","text":"JdbcTemplate基本使用01-JdbcTemplate基本使用-概述(了解)JdbcTemplate是spring框架中提供的一个对象，是对原始繁琐的Jdbc API对象的简单封装。spring框架为我们提供了很多的操作模板类。例如：操作关系型数据的JdbcTemplate和HibernateTemplate，操作nosql数据库的RedisTemplate，操作消息队列的JmsTemplate等等。 02-JdbcTemplate基本使用-开发步骤(理解)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 ④执行数据库操作 03-JdbcTemplate基本使用-快速入门代码实现(应用)导入spring-jdbc和spring-tx坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;itheima_spring_jdbc&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;itheima_spring_jdbc Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建数据库表和实体 12345678910111213141516171819202122232425262728293031package com.itheima.domain;public class Account &#123; private String name; private double money; public String getNa me() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getMoney() &#123; return money; &#125; public void setMoney(double money) &#123; this.money = money; &#125; @Override public String toString() &#123; return &quot;Account&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, money=&quot; + money + &#x27;&#125;&#x27;; &#125;&#125; 创建JdbcTemplate对象 执行数据库操作 123456789101112131415161718@Test //测试JdbcTemplate开发步骤 public void test1() throws PropertyVetoException &#123; //创建数据源对象 ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); JdbcTemplate jdbcTemplate = new JdbcTemplate(); //设置数据源对象 知道数据库在哪 jdbcTemplate.setDataSource(dataSource); //执行操作 int row = jdbcTemplate.update(&quot;insert into account values(?,?)&quot;, &quot;tom&quot;, 5000); System.out.println(row); &#125; 04-JdbcTemplate基本使用-spring产生模板对象分析(理解)我们可以将JdbcTemplate的创建权交给Spring，将数据源DataSource的创建权也交给Spring，在Spring容器内部将数据源DataSource注入到JdbcTemplate模版对象中,然后通过Spring容器获得JdbcTemplate对象来执行操作。 05-JdbcTemplate基本使用-spring产生模板对象代码实现(应用)配置如下： 123456789101112&lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///test&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 测试代码 12345678@Test //测试Spring产生jdbcTemplate对象 public void test2() throws PropertyVetoException &#123; ApplicationContext app = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); JdbcTemplate jdbcTemplate = app.getBean(JdbcTemplate.class); int row = jdbcTemplate.update(&quot;insert into account values(?,?)&quot;, &quot;lisi&quot;, 5000); System.out.println(row); &#125; 06-JdbcTemplate基本使用-spring产生模板对象代码实现（抽取jdbc.properties）(应用)将数据库的连接信息抽取到外部配置文件中，和spring的配置文件分离开，有利于后期维护 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 配置文件修改为: 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--加载jdbc.properties--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--数据源对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!--jdbc模板对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 07-JdbcTemplate基本使用-常用操作-更新操作(应用)1234567891011121314151617181920212223242526272829303132package com.itheima.test;import com.itheima.domain.Account;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class JdbcTemplateCRUDTest &#123; @Autowired private JdbcTemplate jdbcTemplate; //修改更新 @Test public void testUpdate()&#123; jdbcTemplate.update(&quot;update account set money=? where name=?&quot;,10000,&quot;tom&quot;); &#125; //删除 @Test public void testDelete()&#123; jdbcTemplate.update(&quot;delete from account where name=?&quot;,&quot;tom&quot;); &#125;&#125; 08-JdbcTemplate基本使用-常用操作-查询操作(应用)12345678910111213141516171819202122232425262728293031323334353637383940package com.itheima.test;import com.itheima.domain.Account;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.util.List;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class JdbcTemplateCRUDTest &#123; @Autowired private JdbcTemplate jdbcTemplate; //聚合查询 @Test public void testQueryCount()&#123; Long count = jdbcTemplate.queryForObject(&quot;select count(*) from account&quot;, Long.class); System.out.println(count); &#125; //查询一个 @Test public void testQueryOne()&#123; Account account = jdbcTemplate.queryForObject(&quot;select * from account where name=?&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class), &quot;tom&quot;); System.out.println(account); &#125; //查询所有 @Test public void testQueryAll()&#123; List&lt;Account&gt; accountList = jdbcTemplate.query(&quot;select * from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class)); System.out.println(accountList); &#125;&#125; 09-JdbcTemplate基本使用-知识要点(理解，记忆)①导入spring-jdbc和spring-tx坐标 ②创建数据库表和实体 ③创建JdbcTemplate对象 12JdbcTemplate jdbcTemplate = newJdbcTemplate(); jdbcTemplate.setDataSource(dataSource); ④执行数据库操作 123456789更新操作： jdbcTemplate.update (sql,params)查询操作： jdbcTemplate.query (sql,Mapper,params)jdbcTemplate.queryForObject(sql,Mapper,params) 声明式事务控制1. 编程式事务控制相关对象1.1 PlatformTransactionManager (平台事物管理器)PlatformTransactionManager 接口是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法。 方法 说明 TransactionStatusgetTransaction(TransactionDefination defination) 获取事物的状态信息 void commit(TransactionStatus status) 提交事物 void rollback(TransactionStatus status) 回滚事物 注意： PlatformTransactionManager 是接口类型，不同的 Dao 层技术则有不同的实现类，例如：Dao 层技术是jdbc 或 mybatis 时：org.springframework.jdbc.datasource.DataSourceTransactionManager Dao 层技术是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManager 1.2 TransactionDefinitionTransactionDefinition 是事务的定义信息对象，里面有如下方法： 方法 说明 int getIsolationLevel() 获得事务的隔离级别 int getPropogationBehavior() 获得事务的传播行为 int getTimeout() 获得超时时间 boolean isReadOnly() 是否只读 1. 事务隔离级别设置隔离级别，可以解决事务并发产生的问题，如脏读、不可重复读和虚读。 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE 2. 事务传播行为（业务处相互调用是事物的问题） REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值） SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务） MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前在事务中，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 NEVER：以非事务方式运行，如果当前存在事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作 超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 是否只读：建议查询时设置为只读 1.3 TransactionStatus（事物的状态对象）TransactionStatus 接口提供的是事务具体的运行状态，方法介绍如下。 方法 说明 boolean hasSavepoint() 是否存储回滚点 boolean isCompleted() 事务是否完成 boolean isNewTransaction() 是否是新事务 boolean isRollbackOnly() 事务是否回滚 1.4 知识要点编程式事务控制三大对象 PlatformTransactionManager（用什么平台事物管理器） TransactionDefinition（封装事物参数） TransactionStatus（别动封装事物状态信息） 2 基于 XML 的声明式事务控制2.1 什么是声明式事务控制Spring 的声明式事务顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指在配置文件中声明，用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。 声明式事务处理的作用 事务管理不侵入开发的组件。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话，也只需要在定义文件中重新配置即可 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便 注意：Spring 声明式事务控制底层就是AOP。 2.2 声明式事务控制的实现声明式事务控制明确事项： 谁是切点？ 谁是通知？ 配置切面？ ①引入tx命名空间 1234567891011121314&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ②配置事务增强 1234567891011&lt;!--平台事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; ③配置事务 AOP 织入 12345&lt;!--事务的aop增强--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; ④测试事务控制转账业务代码 123456@Overridepublic void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money);&#125; 2.3 切点方法的事务参数的配置123456&lt;!--事务增强配置--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，&lt;tx:method&gt; 代表切点方法的事务参数的配置，例如： 1&lt;tx:method name=&quot;transfer&quot; isolation=&quot;REPEATABLE_READ&quot; propagation=&quot;REQUIRED&quot; timeout=&quot;-1&quot; read-only=&quot;false&quot;/&gt; name：切点方法名称 isolation:事务的隔离级别 propogation：事务的传播行为 timeout：超时时间 read-only：是否只读 2.4 知识要点声明式事务控制的配置要点 平台事务管理器配置 事务通知的配置 引用上面配好的平台事物管理器 每个方法事物可以配置不同的参数 事务aop织入的配置 织入使用&lt;aop:advisor 3 基于注解的声明式事务控制3.1 使用注解配置声明式事务控制 编写 AccoutDao 1234567891011@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void out(String outMan, double money) &#123; jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan); &#125; public void in(String inMan, double money) &#123; jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan); &#125;&#125; 编写 AccoutService 123456789101112@Service(&quot;accountService&quot;)@Transactionalpublic class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Transactional(isolation = Isolation.READ_COMMITTED,propagation = Propagation.REQUIRED) public void transfer(String outMan, String inMan, double money) &#123; accountDao.out(outMan,money); int i = 1/0; accountDao.in(inMan,money); &#125;&#125; 编写 applicationContext.xml 配置文件 12345&lt;!—之前省略datsSource、jdbcTemplate、平台事务管理器的配置--&gt;&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;&lt;!--事务的注解驱动--&gt;&lt;tx:annotation-driven/&gt; 3.2 注解配置声明式事务控制解析①使用 @Transactional 在需要进行事务控制的类或是方法上修饰，注解可用的属性同 xml 配置方式，例如隔离级别、传播行为等。 ②注解使用在类上，那么该类下的所有方法都使用同一套注解参数配置。 ③使用在方法上，不同的方法可以采用不同的事务参数配置。 ④Xml配置文件中要开启事务的注解驱动&lt;tx:annotation-driven &#x2F;&gt; 3.3 知识要点注解声明式事务控制的配置要点 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 &lt;tx:annotation-driven&#x2F;&gt;","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"Spring-aop","slug":"Spring-aop","date":"2022-05-07T02:51:45.000Z","updated":"2022-05-07T15:52:15.872Z","comments":true,"path":"2022/05/07/Spring-aop/","link":"","permalink":"http://example.com/2022/05/07/Spring-aop/","excerpt":"","text":"1.Spring 的 AOP 简介1.1 什么是 AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。 AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 1.5 JDK 的动态代理①目标类接口 123public interface TargetInterface &#123; public void method();&#125; ②目标类 123456public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ③动态代理代码 1234567891011121314Target target = new Target(); //创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;前置增强代码...&quot;); Object invoke = method.invoke(target, args); System.out.println(&quot;后置增强代码...&quot;); return invoke; &#125; &#125;); ④ 调用代理对象的方法测试 12// 测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); 1.6 cglib 的动态代理导入cglib对应的jar包 导入spring-context坐标 里面有cglib ①目标类 12345public class Target &#123; public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ②动态代理代码 1234567891011121314Target target = new Target(); //创建目标对象Enhancer enhancer = new Enhancer(); //创建增强器enhancer.setSuperclass(Target.class); //设置父类enhancer.setCallback(new MethodInterceptor() &#123; //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;前置代码增强....&quot;); Object invoke = method.invoke(target, objects); System.out.println(&quot;后置代码增强....&quot;); return invoke; &#125;&#125;);Target proxy = (Target) enhancer.create(); //创建代理对象 ③调用代理对象的方法测试 12//测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); 1.7 AOP 相关概念Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点（可以被增强的方法） Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义（被增强的方法） Advice（通知&#x2F; 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知 Aspect（切面）：是切入点和通知（引介）的结合（目标方法加增强） Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入（切点和通知结合的过程） 1.8 AOP 开发明确的事项1)需要编写的内容 编写核心业务代码（目标类的目标方法） 编写切面类，切面类中有通知(增强功能方法) 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合 2）AOP 技术实现的内容Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 3）AOP 底层使用哪种代理方式在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 1.9 知识要点 aop：面向切面编程 aop底层实现：基于JDK的动态代理 和 基于Cglib的动态代理 aop的重点概念： 1234567Pointcut（切入点）：被增强的方法Advice（通知/ 增强）：封装增强业务逻辑的方法Aspect（切面）：切点+通知Weaving（织入）：将切点与通知结合的过程 开发明确事项： 12345谁是切点（切点表达式配置）谁是通知（切面类中的增强方法）将切点和通知进行织入配置 2. 基于 XML 的 AOP 开发2.1 快速入门①导入 AOP 相关坐标 ②创建目标接口和目标类（内部有切点） ③创建切面类（内部有增强方法） ④将目标类和切面类的对象创建权交给 spring ⑤在 applicationContext.xml 中配置织入关系 ⑥测试代码 ①导入 AOP 相关坐标 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; ②创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; public void method();&#125;public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ③创建切面类（内部有增强方法） 123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ④将目标类和切面类的对象创建权交给 spring 1234&lt;!--配置目标类--&gt;&lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.Target&quot;&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id=&quot;myAspect&quot; class=&quot;com.itheima.aop.MyAspect&quot;&gt;&lt;/bean&gt; ⑤在 applicationContext.xml 中配置织入关系 导入aop命名空间 1234567891011&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ⑤在 applicationContext.xml 中配置织入关系 配置切点表达式和前置增强的织入关系 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(public void com.itheima.aop.Target.method())&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; 2.2 XML 配置 AOP 详解1) 切点表达式的写法表达式语法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 例如 12345execution(public void com.itheima.aop.Target.method()) execution(void com.itheima.aop.Target.*(..))execution(* com.itheima.aop.*.*(..))execution(* com.itheima.aop..*.*(..))execution(* *..*.*(..)) 2) 通知的类型通知的配置语法： 1&lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式&quot;&gt;&lt;/aop:通知类型&gt; 名称 标签 说明 前置通知 &lt;aop:before&gt; 用于配置前置通知。指定增强的方法在切入点方法之前执行 后置通知 &lt;aop:after-returning&gt; 用于配置后置通知。指定增强的方法在切入点方法之后执行 环绕通知 &lt;aop:around&gt; 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行 异常抛出通知 &lt;aop:throwing&gt; 用于配置异常抛出通知。指定增强的方法在出现异常时执行 最终通知 &lt;aop:after&gt; 用于配置最终通知。无论增强方式执行是否有异常都会执行 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=&quot;myAspect&quot;&gt; &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;myPointcut&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 2.3 知识要点 aop织入的配置 12345&lt;aop:config&gt; &lt;aop:aspect ref=“切面类”&gt; &lt;aop:before method=“通知方法名称” pointcut=“切点表达式&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 通知的类型：前置通知、后置通知、环绕通知、异常抛出通知、最终通知 切点表达式的写法： 1execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 3.基于注解的 AOP 开发3.1 快速入门基于注解的aop开发步骤： ①创建目标接口和目标类（内部有切点） ②创建切面类（内部有增强方法） ③将目标类和切面类的对象创建权交给 spring ④在切面类中使用注解配置织入关系 ⑤在配置文件中开启组件扫描和 AOP 的自动代理 ⑥测试 ①创建目标接口和目标类（内部有切点） 12345678910public interface TargetInterface &#123; public void method();&#125;public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125; ②创建切面类（内部有增强方法) 123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ③将目标类和切面类的对象创建权交给 spring 12345678910111213@Component(&quot;target&quot;)public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(&quot;Target running....&quot;); &#125;&#125;@Component(&quot;myAspect&quot;)public class MyAspect &#123; public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ④在切面类中使用注解配置织入关系 12345678@Component(&quot;myAspect&quot;)@Aspectpublic class MyAspect &#123; @Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125;&#125; ⑤在配置文件中开启组件扫描和 AOP 的自动代理 12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima.aop&quot;/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ⑥测试代码 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; 3.2 注解配置 AOP 详解注解通知的类型 通知的配置语法：@通知注解(“切点表达式”) 切点表达式的抽取 同 xml配置aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 12345678910@@Component(&quot;myAspect&quot;)@Aspectpublic class MyAspect &#123; @Before(&quot;MyAspect.myPoint()&quot;) public void before()&#123; System.out.println(&quot;前置代码增强.....&quot;); &#125; @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;) public void myPoint()&#123;&#125;&#125; 3.3 知识要点 注解aop开发步骤 ①使用@Aspect标注切面类 ②使用@通知注解标注通知方法 ③在配置文件中配置aop自动代理aop:aspectj-autoproxy/ 通知注解类型","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"MQTT1-8ESP8266订阅MQTT主题","slug":"MQTT1-8ESP8266订阅MQTT主题","date":"2022-05-04T07:56:49.000Z","updated":"2022-05-04T07:57:36.268Z","comments":true,"path":"2022/05/04/MQTT1-8ESP8266订阅MQTT主题/","link":"","permalink":"http://example.com/2022/05/04/MQTT1-8ESP8266%E8%AE%A2%E9%98%85MQTT%E4%B8%BB%E9%A2%98/","excerpt":"","text":"订阅单个主题","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"Spring注解开发","slug":"Spring注解开发","date":"2022-05-04T00:59:40.000Z","updated":"2022-05-04T05:03:55.408Z","comments":true,"path":"2022/05/04/Spring注解开发/","link":"","permalink":"http://example.com/2022/05/04/Spring%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/","excerpt":"","text":"1.Spring配置数据源1.1 数据源（连接池）的作用数据源(连接池)是提高程序性能如出现的 事先实例化数据源，初始化部分连接资源 使用连接资源时从数据源中获取 使用完毕后将连接资源归还给数据源 常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等 开发步骤①导入数据源的坐标和数据库驱动坐标 ②创建数据源对象 ③设置数据源的基本连接数据 ④使用数据源获取连接资源和归还连接资源 1.2 数据源的手动创建①导入c3p0和druid的坐标 123456789101112&lt;!-- C3P0连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; ①导入mysql数据库驱动坐标 123456&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt;&lt;/dependency&gt; ②创建C3P0连接池 123456789101112@Testpublic void testC3P0() throws Exception &#123; //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ②创建Druid连接池 12345678910111213@Testpublic void testDruid() throws Exception &#123; //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; ③提取jdbc.properties配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root ④读取jdbc.properties配置文件创建连接池 123456789101112@Testpublic void testC3P0ByProperties() throws Exception &#123; //加载类路径下的jdbc.properties ResourceBundle rb = ResourceBundle.getBundle(&quot;jdbc&quot;); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(&quot;jdbc.driver&quot;)); dataSource.setJdbcUrl(rb.getString(&quot;jdbc.url&quot;)); dataSource.setUser(rb.getString(&quot;jdbc.username&quot;)); dataSource.setPassword(rb.getString(&quot;jdbc.password&quot;)); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 1.3 Spring配置数据源可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;&lt;/bean&gt; 测试从容器当中获取数据源 123456ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;);Connection connection = dataSource.getConnection();System.out.println(connection); 1.4 抽取jdbc配置文件applicationContext.xml加载jdbc.properties配置文件获得连接信息。 首先，需要引入context命名空间和约束路径： 命名空间：xmlns:context&#x3D;”http://www.springframework.org/schema/context&quot; 约束路径：http://www.springframework.org/schema/context​ ​ http://www.springframework.org/schema/context/spring-context.xsd 1234567&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 1.5 知识要点Spring容器加载properties文件 12&lt;context:property-placeholder location=&quot;xx.properties&quot;/&gt;&lt;property name=&quot;&quot; value=&quot;$&#123;key&#125;&quot;/&gt; 2. Spring注解开发2.1 Spring原始注解Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring原始注解主要是替代&lt;Bean&gt;的配置 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 注意： 使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。 12&lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt; 使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。 12345678//@Component(&quot;userDao&quot;)@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;save running... ...&quot;); &#125;&#125; 使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化 使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入 123456789101112//@Component(&quot;userService&quot;)@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; /*@Autowired @Qualifier(&quot;userDao&quot;)*/ @Resource(name=&quot;userDao&quot;) private UserDao userDao; @Override public void save() &#123; userDao.save(); &#125;&#125; 使用@Value进行字符串的注入 12345678910111213@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao &#123; @Value(&quot;注入普通数据&quot;) private String str; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Override public void save() &#123; System.out.println(str); System.out.println(driver); System.out.println(&quot;save running... ...&quot;); &#125;&#125; 使用@Scope标注Bean的范围 12345//@Scope(&quot;prototype&quot;)@Scope(&quot;singleton&quot;)public class UserDaoImpl implements UserDao &#123; //此处省略代码&#125; 使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法 12345678@PostConstructpublic void init()&#123; System.out.println(&quot;初始化方法....&quot;);&#125;@PreDestroypublic void destroy()&#123; System.out.println(&quot;销毁方法.....&quot;);&#125; 2.2 Spring新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置：&lt;bean&gt; 加载properties文件的配置：&lt;context:property-placeholder&gt; 组件扫描的配置：&lt;context:component-scan&gt; 引入其他文件：&lt;import&gt; 注解 说明 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package&#x3D;”com.itheima”&#x2F;&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 @Configuration @ComponentScan @Import 123456@Configuration@ComponentScan(&quot;com.itheima&quot;)@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123; //主配置文件&#125; @PropertySource @value 12345678910@PropertySource(&quot;classpath:jdbc.properties&quot;)public class DataSourceConfiguration &#123; @Value(&quot;$&#123;jdbc.driver&#125;&quot;) private String driver; @Value(&quot;$&#123;jdbc.url&#125;&quot;) private String url; @Value(&quot;$&#123;jdbc.username&#125;&quot;) private String username; @Value(&quot;$&#123;jdbc.password&#125;&quot;) private String password; @Bean 123456789@Bean(name=&quot;dataSource&quot;)public DataSource getDataSource() throws PropertyVetoException &#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(driver); dataSource.setJdbcUrl(url); dataSource.setUser(username); dataSource.setPassword(password); return dataSource;&#125; 测试加载核心配置类创建Spring容器 1234567891011@Testpublic void testAnnoConfiguration() throws Exception &#123;ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfiguration.class); UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;); userService.save(); DataSource dataSource = (DataSource) applicationContext.getBean(&quot;dataSource&quot;); Connection connection = dataSource.getConnection(); System.out.println(connection); &#125; 3. Spring整合Junit3.1 原始Junit测试Spring的问题在测试类中，每个测试方法都有以下两行代码： 12ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);IAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class); 这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 3.2 上述问题解决思路让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 将需要进行测试Bean直接在测试类中进行注入 3.3 Spring集成Junit步骤①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试 3.4 Spring集成Junit代码实现①导入spring集成Junit的坐标 123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②使用@Runwith注解替换原来的运行期 123@RunWith(SpringJUnit4ClassRunner.class)//提供Spring内核去跑public class SpringJunitTest &#123;&#125; ③使用@ContextConfiguration指定配置文件或配置类 1234567@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)//加载spring核心配置类@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;&#125; ④使用@Autowired注入需要测试的对象 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService;&#125; ⑤创建测试方法进行测试 123456789@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;) public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void testUserService()&#123; userService.save(); &#125;&#125; Spring集成Junit步骤 ①导入spring集成Junit的坐标 ②使用@Runwith注解替换原来的运行期 ③使用@ContextConfiguration指定配置文件或配置类 ④使用@Autowired注入需要测试的对象 ⑤创建测试方法进行测试","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"Spring简介和配置","slug":"Spring简介和配置","date":"2022-05-03T01:14:29.000Z","updated":"2022-05-04T08:19:54.914Z","comments":true,"path":"2022/05/03/Spring简介和配置/","link":"","permalink":"http://example.com/2022/05/03/Spring%E7%AE%80%E4%BB%8B%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1. spring概述1.1 Spring是什么（理解）Spring是分层的 Java SE&#x2F;EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。 提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架 1.2 Spring发展历程 （了解）1.3 Spring的优势（理解）方便解耦，简化开发 AOP 编程的支持 声明式事务的支持 方便程序的测试 1.4 Spring的体系结构（了解）2. spring快速入门2.1 Spring程序开发步骤 导入 Spring 开发的基本包坐标 编写 Dao 接口和实现类 创建 Spring 核心配置文件 在 Spring 配置文件中配置 UserDaoImpl 使用 Spring 的 API 获得 Bean 实例 2.2 导入Spring开发的基本包坐标1234567891011&lt;properties&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!--导入spring的context坐标，context依赖core、beans、expression--&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3 编写Dao接口和实现类12345678910public interface UserDao &#123; public void save();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 2.4 创建Spring核心配置文件在类路径下（resources）创建applicationContext.xml配置文件 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; 2.5 在Spring配置文件中配置UserDaoImpl123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 2.6 使用Spring的API获得Bean实例123456@Testpublic void test1()&#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125; 3. Spring配置文件3.1 Bean标签基本配置用于配置对象交由Spring 来创建。 默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 基本属性： id：Bean实例在Spring容器中的唯一标识 class：Bean的全限定名称 3.2 Bean标签范围配置scope:指对象的作用范围，取值如下： 取值范围 说明 Singleton 默认值，单例的 prototype 多例的 request WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中 session WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中 global session WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session 1）当scope的取值为singleton时 ​ Bean的实例化个数：1个 ​ Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 ​ Bean的生命周期： 对象创建：当应用加载，创建容器时，对象就被创建了 对象运行：只要容器在，对象一直活着 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 2）当scope的取值为prototype时 ​ Bean的实例化个数：多个 ​ Bean的实例化时机：当调用getBean()方法时实例化Bean 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 3.3 Bean生命周期配置init-method：指定类中的初始化方法名称 destroy-method：指定类中销毁方法名称 3.4 Bean实例化三种方式1） 使用无参构造方法实例化 ​ 它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败 1&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt; 2） 工厂静态方法实例化 ​ 工厂的静态方法返回Bean实例 12345public class StaticFactoryBean &#123; public static UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 12&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.StaticFactoryBean&quot; factory-method=&quot;createUserDao&quot; /&gt; 3） 工厂实例方法实例化 ​ 工厂的非静态方法返回Bean实例 12345public class DynamicFactoryBean &#123; public UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 12&lt;bean id=&quot;factoryBean&quot; class=&quot;com.itheima.factory.DynamicFactoryBean&quot;/&gt;&lt;bean id=&quot;userDao&quot; factory-bean=&quot;factoryBean&quot; factory-method=&quot;createUserDao&quot;/&gt; 3.5 Bean的依赖注入入门①创建 UserService，UserService 内部在调用 UserDao的save() 方法 12345678public class UserServiceImpl implements UserService &#123; @Override public void save() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125; &#125; ②将 UserServiceImpl 的创建权交给 Spring 1&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt; ③从 Spring 容器中获得 UserService 进行操作 123ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);userService.save(); 3.6 Bean的依赖注入概念依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。 在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。 IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。 那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 3.7 Bean的依赖注入方式①构造方法 ​ 创建有参构造 12345678public class UserServiceImpl implements UserService &#123;@Overridepublic void save() &#123;ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;); userDao.save(); &#125; &#125; ​ 配置Spring容器调用有参构造时进行注入 123&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; ②set方法 ​ 在UserServiceImpl中添加setUserDao方法 12345678910public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; ​ 配置Spring容器调用set方法进行注入 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;&lt;/bean&gt; set方法:P命名空间注入 ​ P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： ​ 首先，需要引入P命名空间： 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式 12&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot; p:userDao- ref=&quot;userDao&quot;/&gt; 3.8 Bean的依赖注入的数据类型上面的操作，都是注入的引用Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。 注入数据的三种数据类型 普通数据类型 引用数据类型 集合数据类型 其中引用数据类型，此处就不再赘述了，之前的操作都是对UserDao对象的引用进行注入的，下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。 Bean的依赖注入的数据类型 （1）普通数据类型的注入 1234567891011121314public class UserDaoImpl implements UserDao &#123;private String company; private int age; public void setCompany(String company) &#123; this.company = company; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void save() &#123; System.out.println(company+&quot;===&quot;+age); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 1234&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;company&quot; value=&quot;传智播客&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;15&quot;&gt;&lt;/property&gt;&lt;/bean&gt; （2）集合数据类型（List&lt;String&gt;）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) &#123; this.strList = strList; &#125; public void save() &#123; System.out.println(strList); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;strList&quot;&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; （3）集合数据类型（List&lt;User&gt;）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125;public void save() &#123; System.out.println(userList); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789101112&lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userList&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;bean class=&quot;com.itheima.domain.User&quot;/&gt; &lt;ref bean=&quot;u1&quot;/&gt; &lt;ref bean=&quot;u2&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; （4）集合数据类型（ Map&lt;String,User&gt; ）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Map&lt;String,User&gt; userMap; public void setUserMap(Map&lt;String, User&gt; userMap) &#123; this.userMap = userMap; &#125; public void save() &#123; System.out.println(userMap); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 12345678910&lt;bean id=&quot;u1&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;u2&quot; class=&quot;com.itheima.domain.User&quot;/&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;userMap&quot;&gt; &lt;map&gt; &lt;entry key=&quot;user1&quot; value-ref=&quot;u1&quot;/&gt; &lt;entry key=&quot;user2&quot; value-ref=&quot;u2&quot;/&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; （5）集合数据类型（Properties）的注入 12345678910public class UserDaoImpl implements UserDao &#123; private Properties properties; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public void save() &#123; System.out.println(properties); System.out.println(&quot;UserDao save method running....&quot;); &#125;&#125; 123456789&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;bbb&lt;/prop&gt; &lt;prop key=&quot;p3&quot;&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3.9 引入其他配置文件（分模块开发）实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载 1&lt;import resource=&quot;applicationContext-xxx.xml&quot;/&gt; 小总结12345678910111213&lt;bean&gt;标签id属性:在容器中Bean实例的唯一标识，不允许重复 class属性:要实例化的Bean的全限定名 scope属性:Bean的作用范围，常用是Singleton(默认)和prototype &lt;property&gt;标签：属性注入 name属性：属性名称 value属性：注入的普通属性值 ref属性：注入的对象引用值 &lt;list&gt;标签 &lt;map&gt;标签 &lt;properties&gt;标签 &lt;constructor-arg&gt;标签&lt;import&gt;标签:导入其他的Spring的分文件 4. spring相关API4.1 ApplicationContext的继承体系applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring 容器中的 Bean 对象 4.2 ApplicationContext的实现类1）ClassPathXmlApplicationContext ​ 它是从类的根路径下加载配置文件 推荐使用这种 2）FileSystemXmlApplicationContext ​ 它是从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置。 3）AnnotationConfigApplicationContext ​ 当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。 4.3 getBean()方法使用1234567public Object getBean(String name) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name);&#125;public &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(requiredType);&#125; 其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。 当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错 getBean()方法使用 1234ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserService userService1 = (UserService) applicationContext.getBean(&quot;userService&quot;); UserService userService2 = applicationContext.getBean(UserService.class);","categories":[],"tags":[{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"}]},{"title":"MQTT1-7主题进阶","slug":"MQTT1-7主题进阶","date":"2022-05-01T06:11:25.000Z","updated":"2022-05-01T06:41:15.890Z","comments":true,"path":"2022/05/01/MQTT1-7主题进阶/","link":"","permalink":"http://example.com/2022/05/01/MQTT1-7%E4%B8%BB%E9%A2%98%E8%BF%9B%E9%98%B6/","excerpt":"","text":"从以下几个方面来学习MQTT主题的高级知识： 主题基本形式 主题分级 主题通配符 主题应用注意事项 主题基本形式主题的最基本形式就是一个字符串。以下是几个主题示例： myTopic motorSpeed MotorSpeed current time 要注意以下几点 主题是区分大小写的。如上列表中的主题 motor_speed和Motor_speed是两个完全不同的主题。 主题可以使用空格 如以上列表中的current time，虽然有空格分隔current和time这两个词，但这实际是一个MQTT主题。不过，虽然我们可以使用空格，但是笔者强烈建议您不要在主题中使用空格。 大部分MQTT服务端是不支持中文主题的，所以我们应使用英文字符或ASCII字符来作为MQTT主题。 主题分级MQTT主题可以是一个简单的字符串，比如motor_speed，myTopic。这些都是单一级别的主题。 为了更好的对主题进行管理和分类，我们可以对主题进行分级处理。MQTT主题各个级别之间可以使用”&#x2F;”来分隔。如下例所示： Tyler-1&#x2F;motor&#x2F;1&#x2F;speed 在以上示例中一共有四级主题，分别是第1级 Tyler-1、第2级motor、第三级1、第4级speed。主题的每一级至少需要一个字符，比如以上示例中，数字1既是一级主题。 主题通配符当客户端订阅主题时，可以使用通配符同时订阅多个主题。通配符只能在订阅主题时使用，下面我们将介绍两种通配符：单级通配符和多级通配符。 单级通配符：+ 顾名思义，单级通配符可以代替一个主题级别。 以下为含有单极通配符的主题示例。 home&#x2F;sensor&#x2F;+&#x2F;temperature 当客户端订阅了以上主题后，它将会收到以下主题的信息内容： home&#x2F;sensor&#x2F;kitchen&#x2F;temperaturehome&#x2F;sensor&#x2F;bedroom&#x2F;temperature 多级通配符 # 单级通配符仅可代替一个主题级别，而多级通配符”#”可以涵盖任意数量的主题级别。如下示例所示， 多级通配符必须是主题中的最后一个字符。 home&#x2F;sensor&#x2F;# 当客户端订阅了以上含有”#”的主题后，可以收到以下主题的信息。 home&#x2F;sensor&#x2F;kitchen&#x2F;temperaturehome&#x2F;sensor&#x2F;bedroom&#x2F;brightnesshome&#x2F;sensor&#x2F;data 主题应用注意事项– 以$开始的主题 以$开始的主题是MQTT服务端系统保留的特殊主题，我们不能随意订阅或者向其发布信息。 – 不要用 “&#x2F;” 作为主题开头MQTT允许使用“&#x2F;”作为主题的开头，例如&#x2F;home&#x2F;sensor&#x2F;data。但是这将这么做毫无意义，而且会额外产生一个没有用处的主题级别。所以我们应避免使用&#x2F;作为主题的开头。 – 主题中不要使用空格 MQTT协议允许我们在主题中使用空格，但是阅读和调试含有空格的主题会显得异常困难。所以我们尽量不要在主题中使用空格或者特殊字符。 -在主题中嵌入客户端ID 在主题中嵌入发布消息的客户端ID，这一操作可以为开发和管理MQTT信息提供便利。通过主题中的客户端ID内容，我们可以很容易的了解该主题信息是由哪一台设备所发布的。","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"Liunx&Nginx","slug":"Liunx-Nginx","date":"2022-05-01T02:44:37.000Z","updated":"2022-05-01T05:55:30.869Z","comments":true,"path":"2022/05/01/Liunx-Nginx/","link":"","permalink":"http://example.com/2022/05/01/Liunx-Nginx/","excerpt":"","text":"Linux软件安装Linux上的软件安装有以下几种常见方式介绍 二进制发布包 软件已经针对具体平台编译打包发布，只要解压，修改配置即可 RPM包 软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装 Yum在线安装 软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题 源码编译安装 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。 上传与下载工具介绍 FileZilla lrzsz 在Linux上安装JDK 上传JDK到Linux的服务器. 上传JDK 卸载open-JDK 在Linux服务器上安装JDK. 通常将软件安装到&#x2F;usr&#x2F;local 直接解压就可以 配置JDK的环境变量. 配置环境变量： vi &#x2F;etc&#x2F;profile 在末尾行添加 12345#set java environment JAVA_HOME=/usr/local/jdk/jdk1.7.0_71 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 保存退出 source &#x2F;etc&#x2F;profile 使更改的配置立即生效 在Linux上安装mysql 将mysql的安装文件上传到Linux的服务器. 将mysql的tar解压 将系统自带的mysql卸载 安装MYSQL服务端 下面的提示是告诉我们root用户的密码第一次是随机生成的，它保存在&#x2F;root&#x2F;.mysql_secret中，第一次登录需要修改root密码 安装MYSQL客户端 查看生成的root密码 报错:原因是没有启动mysql服务 需要开启mysql服务 执行下面操作报错，原因是第一次操作mysql必须修改root用户的密码 设置root用户的密码 Mysq服务加入到系统服务并自动启动操作： chkconfig –add mysql 自动启动： chkconfig mysql on 查询列表： chkconfig 关于mysql远程访问设置 在linux中很多软件的端口都被”防火墙”限止，我们需要将防火墙关闭 防火墙打开3306端口 &#x2F;sbin&#x2F;iptables -I INPUT -p tcp –dport 3306 -j ACCEPT &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;iptables save &#x2F;etc&#x2F;init.d&#x2F;iptables status 学习阶段我们也可以直接将防火墙关闭 service iptables stop; 在Liunx上安装tomcat Tomcat上传到linux上 将上传的tomcat解压 在tomcat&#x2F;bin目录下执行 startup.sh（注意防火墙） 查看目标 tomcat&#x2F;logs&#x2F;catalina.out Linux部署案例将Maven打包 修改porm配置 在porm.xml中添加&lt;finalName&gt; 修改jdk版本保持一致 将本地数据库导出成为sql文件 切换Linux数据库将文件还原 修改项目 druid.properties 加字符编码 将绝对路径都就改成相对路径 用package命令打包 将war包传到tomcat的webapps文件中 Nginx主要内容 掌握Nginx的安装 掌握Nginx的静态网站部署 理解Nginx的反向代理与负载均衡，能够配置反向代理和负载均衡 Nginx是什么一款高性能的 http 服务器&#x2F;反向代理服务器 Nginx的应用场景 http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 安装步骤 安装gcc的环境 第三方的开发包 pcre PCRE(Perl Compatible Regular Expressions)是一个 Perl 库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库。 1yum install -y pcre pcre-devel 注：pcre-devel 是使用 pcre 开发的一个二次开发库。nginx 也需要此库 zlib zlib 库提供了很多种压缩和解压缩的方式，nginx 使用 zlib 对 http 包的内容进行 gzip，所以需要在 linux 上安装 zlib 库。 1yum install -y zlib zlib-devel OpenSSL OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在 ssl 协议上传输 http），所以需要在 linux安装 openssl 库。 1yum install -y openssl openssl-devel Nginx下载官方网站下载 nginx：http://nginx.org/ Nginx安装 把 nginx 的源码包nginx-1.8.0.tar.gz上传到 linux 系统 解压缩 1tar zxvf nginx-1.8.0.tar.gz 进入nginx-1.8.0目录 使用 configure 命令创建一 makeFile 文件。 123456789101112./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi 执行后可以看到Makefile文件 Makefile是一种配置文件， Makefile 一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。 configure参数 12345678910111213141516171819--prefix=/usr \\ 指向安装目录--sbin-path=/usr/sbin/nginx \\ 指向（执行）程序文件（nginx）--conf-path=/etc/nginx/nginx.conf \\ 指向配置文件--error-log-path=/var/log/nginx/error.log \\ 指向log--http-log-path=/var/log/nginx/access.log \\ 指向http-log--pid-path=/var/run/nginx/nginx.pid \\ 指向pid--lock-path=/var/lock/nginx.lock \\ （安装文件锁定，防止安装文件被别人利用，或自己误操作。）--user=nginx \\--group=nginx \\--with-http_ssl_module \\ 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）--with-http_flv_module \\ 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）--with-http_stub_status_module \\ 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）--with-http_gzip_static_module \\ 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）--http-client-body-temp-path=/var/tmp/nginx/client/ \\ 设定http客户端请求临时文件路径--http-proxy-temp-path=/var/tmp/nginx/proxy/ \\ 设定http代理临时文件路径--http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \\ 设定http fastcgi临时文件路径--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \\ 设定http uwsgi临时文件路径--http-scgi-temp-path=/var/tmp/nginx/scgi \\ 设定http scgi临时文件路径--with-pcre 启用pcre库 编译 ​ make 安装 make install Nginx安装","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MQTT1-6 ESP8266发布消息","slug":"MQTT1-6-ESP8266发布消息","date":"2022-04-30T14:25:06.000Z","updated":"2022-04-30T15:24:13.085Z","comments":true,"path":"2022/04/30/MQTT1-6-ESP8266发布消息/","link":"","permalink":"http://example.com/2022/04/30/MQTT1-6-ESP8266%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF/","excerpt":"","text":"使用最为流行的PubSubClient库来作为本教程的主要介绍对象 发布MQTT消息示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt;#include &lt;Ticker.h&gt;//可定时执行任务的库 // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichi-maker&quot;;const char* password = &quot;12345678&quot;;const char* mqttServer = &quot;test.ranye-iot.net&quot;;//mqtt服务端的地址 // 如以上MQTT服务器无法正常连接，请前往以下页面寻找解决方案// http://www.taichi-maker.com/public-mqtt-broker/ Ticker ticker;WiFiClient wifiClient;PubSubClient mqttClient(wifiClient);//建立PubSubCliebt对象 int count; // Ticker计数用变量 void setup() &#123; Serial.begin(9600); //设置ESP8266工作模式为无线终端模式 WiFi.mode(WIFI_STA); // 连接WiFi connectWifi(); // 设置MQTT服务器和端口号 mqttClient.setServer(mqttServer, 1883); // 连接MQTT服务器 connectMQTTServer(); // Ticker定时对象 ticker.attach(1, tickerCount); &#125; void loop() &#123; if (mqttClient.connected()) &#123; // 如果开发板成功连接服务器 // 每隔3秒钟发布一次信息 if (count &gt;= 3)&#123; pubMQTTmsg(); count = 0; &#125; // 保持心跳 mqttClient.loop(); &#125; else &#123; // 如果开发板未能成功连接服务器 connectMQTTServer(); // 则尝试连接服务器 &#125;&#125; void tickerCount()&#123; count++;&#125; void connectMQTTServer()&#123; // 根据ESP8266的MAC地址生成客户端ID（避免与其它ESP8266的客户端ID重名） String clientId = &quot;esp8266-&quot; + WiFi.macAddress(); // 连接MQTT服务器 if (mqttClient.connect(clientId.c_str())) &#123; Serial.println(&quot;MQTT Server Connected.&quot;); Serial.println(&quot;Server Address: &quot;); Serial.println(mqttServer); Serial.println(&quot;ClientId:&quot;); Serial.println(clientId); &#125; else &#123; Serial.print(&quot;MQTT Server Connect Failed. Client State:&quot;); Serial.println(mqttClient.state()); delay(3000); &#125; &#125; // 发布信息void pubMQTTmsg()&#123; static int value; // 客户端发布信息用数字 // 建立发布主题。主题名称以Taichi-Maker-为前缀，后面添加设备的MAC地址。 // 这么做是为确保不同用户进行MQTT信息发布时，ESP8266客户端名称各不相同， String topicString = &quot;Taichi-Maker-Pub-&quot; + WiFi.macAddress(); char publishTopic[topicString.length() + 1]; strcpy(publishTopic, topicString.c_str()); // 建立发布信息。信息内容以Hello World为起始，后面添加发布次数。 String messageString = &quot;Hello World &quot; + String(value++); char publishMsg[messageString.length() + 1]; strcpy(publishMsg, messageString.c_str()); // 实现ESP8266向主题发布信息 if(mqttClient.publish(publishTopic, publishMsg))&#123; Serial.println(&quot;Publish Topic:&quot;);Serial.println(publishTopic); Serial.println(&quot;Publish message:&quot;);Serial.println(publishMsg); &#125; else &#123; Serial.println(&quot;Message Publish Failed.&quot;); &#125;&#125; // ESP8266连接wifivoid connectWifi()&#123; WiFi.begin(ssid, password); //等待WiFi连接,成功连接后输出成功信息 while (WiFi.status() != WL_CONNECTED) &#123; delay(1000); Serial.print(&quot;.&quot;); &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi Connected!&quot;); Serial.println(&quot;&quot;); &#125;","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"Liunx","slug":"Liunx","date":"2022-04-30T01:23:45.000Z","updated":"2022-04-30T05:35:50.506Z","comments":true,"path":"2022/04/30/Liunx/","link":"","permalink":"http://example.com/2022/04/30/Liunx/","excerpt":"","text":"Linux的概述:学习Linux之前先了解Unixlinux的历史Linux系统的应用服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等， 高性能运算、计算密集型应用Linux有强大的运算能力。 桌面应用系统 移动手持系统 Linux的版本Linux的版本分为两种：内核版本和发行版本；内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ； Linux的主流版本Liunx安装虚拟机安装VMware Liunx的目录结构树状结构： 参考资料：https://www.runoob.com/linux/linux-system-contents.html ![截屏2022-04-30 10.06.14](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;Liunx&#x2F;截屏2022-04-30 10.06.14.png) &#x2F;bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 &#x2F;boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 &#x2F;dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 &#x2F;etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 &#x2F;home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 &#x2F;lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 &#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 &#x2F;media： Liunx常用命令列出文件列表 ls llls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式：ls[参数] [路径或文件名] 常用： 在linux中以 . 开头的文件都是隐藏的文件 ls ls -a 显示所有文件或目录（包含隐藏的文件） ls -l 缩写成ll 切换目录指令cd： 使用cd app 切换到app目录 cd .. 切换到上一层目录 cd &#x2F; 切换到系统根目录 cd ~ 切换到用户主目录 cd - 切换到上一个所在目录 使用tab键来补全文件路径 创建目录和移除目录：mkdir rmdir mkdir(make directory)命令可用来创建子目录。 mkdir app è 在当前目录下创建app目录 mkdir –p app2&#x2F;test è 级联创建aap2以及test目 rmdir(remove directory)命令可用来删除“空”的子目录： rmdir app è 删除app目录 当有些命令不知道怎么办，命令 –help 查询此命令文档 浏览文件 cat 用于显示文件的内容。格式：cat[参数]&lt;文件名&gt; cat yum.conf more 一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。回车显示下一行内容。 按 q 键退出查看。 more yum.conf 空格显示下一页数据 回车显示下一行的数据 less less用法和more类似，不同的是less可以通过PgUp、PgDn键来控制。 less yum.conf PgUp 和 PgDn 进行上下翻页. tail tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。 用法 tail -10 &#x2F;etc&#x2F;passwd è 查看后10行数据 tail -f catalina.log è 动态查看日志(*****) ctrl+c 结束查看 文件操作 rm 删除文件 用法：rm [选项]… 文件… rm a.txt 删除a.txt文件 删除需要用户确认，y&#x2F;nrm 删除不询问 rm -f a.txt 不询问，直接删除rm 删除目录 rm -r a 递归删除不询问递归删除（慎用） rm -rf a 不询问递归删除 rm -rf * 删除所有文件 rm -rf &#x2F;* 自杀 cp &amp; mv cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。 cp a.txt b.txt 将a.txt复制为b.txt文件 cp a.txt ..&#x2F; 将a.txt文件复制到上一层目录中 mv 移动或者重命名 mv a.txt ..&#x2F; 将a.txt文件移动到上一层目录中 mv a.txt b.txt 将a.txt文件重命名为b.txt tar打包或解压 tar命令位于&#x2F;bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数： -c：创建一个新tar文件 -v：显示运行过程的信息 -f：指定文件名 -z：调用gzip压缩命令进行压缩 查看压缩文件的内容 -x：解开tar文件 打包 tar –cvf xxx.tar .&#x2F;* 打包并且压缩： tar –zcvf xxx.tar.gz .&#x2F;* 解压 tar –xvf xxx.tar tar -zxvf xxx.tar.gz -C &#x2F;usr&#x2F;aaa find find指令用于查找符合条件的文件 示例 find &#x2F; -name “ins*” 查找文件名称是以ins开头的文件 find &#x2F; -name “ins*” –ls find &#x2F; –user itcast –ls 查找用户itcast的文件 find &#x2F; –user itcast –type d –ls 查找用户itcast的目录 find &#x2F;-perm -777 –type d-ls 查找权限是777的文件 grep 查找文件里符合条件的字符串。 用法: grep [选项]… PATTERN [FILE]… 示例 grep lang anaconda-ks.cfg 在文件中查找lang grep lang anaconda-ks.cfg –color 高亮显示 其他常见命令 pwd 显示当前所在目录 touch 创建一个空文件 touch a.txt clear&#x2F;crtl + L 清屏 vi和vim编辑器vim编辑器 在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。 切换到命令行模式：按Esc键； 切换到插入模式：按 i 、o、a键； i 在当前位置前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 切换到底行模式：按 :（冒号）；更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》 常见命令 打开文件：vim file 退出：esc -&gt; :q 修改文件：输入i进入插入模式 保存并退出：esc-&gt;:wq 不保存退出：esc-&gt;:q! 三种进入插入模式： i:在当前的光标所在处插入 o:在当前光标所在的行的下一行插入 a:在光标所在的下一个字符插入 快捷键： dd – 快速删除一行 yy - 复制当前行 nyy - 从当前行向后复制几行 p - 粘贴 R – 替换 重定向输出&gt;和&gt;&gt; &gt;重定向输出，覆盖原有内容 &gt;&gt;重定向输出，又追见功能 示例 cat &#x2F;etc&#x2F;passwd &gt; a.txt 将输出定向到a.txt中 cat &#x2F;etc&#x2F;passwd &gt;&gt; a.txt 输出并且追加 ifconfig &gt; ifconfig.txt 系统管理命令 ps 正在运行的某个进程的状态 ps –ef 查看所有进程 ps –ef | grep ssh 查找某一进程 kill 2868 杀掉2868编号的进程 kill -9 2868 强制杀死进程 管道 管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。 ls –help | more 分页查询帮助信息 ps –ef | grep java 查询名称中包含java的进程 ifconfig | more cat index.html | more ps –ef | grep aio Liunx的权限命令文件权限![截屏2022-04-30 12.49.31](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;Liunx&#x2F;截屏2022-04-30 12.49.31.png) 1- --- --- --- 文件类型 -表示文件 d表示文件夹 l表示链接 当前用户具有该文件的权限 r：read 读 4 w：write 写 2 x：excute 执行 1 当前组内其他用户具有该文件的权限 r：read 读 w：write 写 x：excute 执行 其他组的用户具有该文件的权限 r：read 读 w：write 写 x：excute 执行 Linux三种文件类型 普通文件：包括文本文件、数据文件、可执行的二进制程序文件等。 目录文件：Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 设备文件：Linux系统把每一个设备都看成是一个文件 文件权限管理 chmod 变更文件或目录的权限。 chmod 755 a.txt chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx a.txt Liunx上常用网络操作 主机名配置 hostname 查看主机名 hostname xxx 修改主机名 重启后无效 如果想要永久生效，可以修改&#x2F;etc&#x2F;sysconfig&#x2F;network文件 IP地址配置 ifconfig 查看(修改)ip地址(重启后无效) ifconfig eth0 192.168.12.22 修改ip地址 如果想要永久生效 修改 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0文件 DEVICE&#x3D;eth0 #网卡名称 BOOTPROTO&#x3D;static #获取ip的方式(static&#x2F;dhcp&#x2F;bootp&#x2F;none) HWADDR&#x3D;00:0C:29:B5:B2:69 #MAC地址 IPADDR&#x3D;12.168.177.129 #IP地址 NETMASK&#x3D;255.255.255.0 #子网掩码 NETWORK&#x3D;192.168.177.0 #网络地址 BROADCAST&#x3D;192.168.0.255 #广播地址 NBOOT&#x3D;yes # 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。 域名映射 &#x2F;etc&#x2F;hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:\\Windows\\System32\\drivers\\etc\\hosts文件的功能 网络服务管理1234567891011121314service network status 查看指定服务的状态service network stop 停止指定服务service network start 启动指定服务service network restart 重启指定服务service --status–all 查看系统中所有后台服务netstat –nltp 查看系统中网络进程的端口监听情况防火墙设置防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。service iptables status 查看防火墙状态service iptables stop 关闭防火墙service iptables start 启动防火墙chkconfig iptables off 禁止防火墙自启","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MQTT1-5发布,订阅和取消订阅","slug":"MQTT1-5发布-订阅和取消订阅","date":"2022-04-30T01:08:13.000Z","updated":"2022-04-30T01:18:04.215Z","comments":true,"path":"2022/04/30/MQTT1-5发布-订阅和取消订阅/","link":"","permalink":"http://example.com/2022/04/30/MQTT1-5%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E5%92%8C%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85/","excerpt":"","text":"MQTT报文 PUBLISH – 发布信息 SUBSCRIBE – 订阅主题 SUBACK – 订阅确认 UNSUBSCRIBE – 取消订阅 PUBLISH – 发布消息MQTT客户端一旦连接到服务端，便可以发布消息。 每条发布的MQTT消息必须包含一个主题。MQTT服务器可以通过主题确定将消息转发给哪些客户端。 MQTT客户端发布消息时，会向服务端发送PUBLISH报文。 topicName – 主题名 主题名用于识别此信息应发布到哪一个主题 QoS – 服务质量等级 QoS（Quality of Service）表示MQTT消息的服务质量等级。QoS有三个级别：0、1和2。QoS决定MQTT通讯有什么样的服务保证。 packetId – 报文标识符 报文标识符可用于对MQTT报文进行标识。不同的MQTT报文所拥有的标识符不同。MQTT设备可以通过该标识符对MQTT报文进行甄别和管理。请注意：报文标识符的内容与QoS级别有密不可分的关系。只有QoS级别大于0时，报文标识符才是非零数值。如果QoS等于0，报文标识符为0。 retainFlag – 保留标志 有些情况下，我们需要客户端在订阅了某一主题后马上接收到一条该主题的信息。这时候就需要用到保留标志这一信息。 Payload – 有效载荷 有效載荷是我们希望通过MQTT所发送的实际内容。我们可以使用MQTT协议发送文本，图像等格式的内容。这些内容都是通过有效載荷所发送的。 dupFlag – 重发标志 当MQTT报文的接收方没有及时确认收到报文时，发送方会重复发送MQTT报文。在重复发送MQTT报文时，发送方会将此“重发标志”设置为true。请注意，重发标志只在QoS级别大于0时使用。 SUBSCRIBE – 订阅主题一个SUBSCRIBE报文可以包含有单个或者多个订阅主题名。也就是说，一个SUBSCRIBE报文可以用于订阅一个或者多个主题。 SUBACK – 订阅确认服务端接收到客户端的订阅报文后，会向客户端发送SUBACK报文确认订阅。 SUBACK报文包含有“订阅返回码”和“报文标识符”这两个信息。 returnCode – 订阅返回码 返回码 Return Code Response 0 订阅成功 – QoS 0 1 订阅成功- QoS 1 2 订阅成功- QoS 2 128 订阅失败 请留意，如上表所示，针对不同的主题订阅QoS，服务端的返回码会有所不同。 UNSUBSCRIBE – 取消订阅顾名思义，当客户端要取消订阅某主题时，可通过向服务端发送UNSUBSCRIBE – 取消订阅报文来实现。 UNSUBSCRIBE报文包含两个重要信息，第一个是取消订阅的主题名称。同一个UNSUBSCRIBE报文可以同时包含多个取消订阅的主题名称。","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"小程序模板与配置","slug":"小程序模板与配置","date":"2022-04-29T06:31:15.000Z","updated":"2022-05-04T07:51:55.356Z","comments":true,"path":"2022/04/29/小程序模板与配置/","link":"","permalink":"http://example.com/2022/04/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"主要内容能够使用 WXML 模板语法渲染页面结构能够使用 WXSS 样式美化页面结构能够使用 app.json 对小程序进行全局性配置能够使用 page.json 对小程序页面进行个性化配置能够知道如何发起网络数据请求 WXML 模板语法数据绑定 数据绑定的基本原则 在 data 中定义数据 在 WXML 中使用数据 在 data 中定义页面的数据 在页面对应的 .js 文件中，把数据定义到 data 对象中即可： 123data: &#123; info: &#x27;hello world&#x27; &#125;, Mustache 语法的格式 把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来即可。语法格式为： 1&lt;view&gt;&#123;&#123;数据名称&#125;&#125;&lt;/view&gt; Mustache 语法的应用场景 Mustache 语法的主要应用场景如下： 绑定内容 绑定属性 运算（三元运算、算术运算等） 动态绑定内容 页面的数据如下： 12345Page(&#123; data: &#123; info: &#x27;init data&#x27; &#125;&#125;) 页面的结构如下： 1&lt;view&gt;&#123;&#123; info &#125;&#125;&lt;/view&gt; 动态绑定属性 页面的数据如下： 12345Page(&#123; data: &#123; imgSrc: &#x27;http://www.itheima.com/images/1.png&#x27; &#125;&#125;) 页面的结构如下： 1&lt;image src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt;&lt;/image&gt; 三元运算 页面的数据如下： 12345Page(&#123; data: &#123; randomNum1: Math.random() * 10 //生成10以内的随机数 &#125;&#125;) 页面的结构如下： 1&lt;view&gt;&#123;&#123;randomNum1 &gt;=5 ? &#x27;数字大于5&#x27; : &#x27;数字小于5&#x27;&#125;&#125;&lt;/view&gt; 算数运算 页面的数据如下： 12345Page(&#123; data: &#123; randomNum1: Math.random().toFixed(2)//生成带两位小数的随机数 如：0.45 &#125;&#125;) 页面的结构如下： 1&lt;view&gt;&#123;&#123;randomNum2 * 100&#125;&#125;&lt;/view&gt; 事件绑定 什么是事件事件是渲染层到逻辑层的通讯方式。通过事件可以将用户在渲染层产生的行为，反馈到逻辑层进行业务的处理。 小程序中常用的事件 类型 绑定方式 事件描述 tap bindtap 或 bind:tap 手指触摸后马上离开，类似于 HTML 中的 click 事件 input bindinput 或 bind:input 文本框的输入事件 change bindchange 或 bind:change 状态改变时触发 事件对象的属性列表 当事件回调触发的时候，会收到一个事件对象 event，它的详细属性如下表所示： 属性 类型 说明 type String 事件类型 timeStamp Integer 页面打开到触发事件所经过的毫秒数 target Object 触发事件的组件的一些属性值集合 currentTarget Object 当前组件的一些属性值集合 detail Object 额外的信息 touches Array 触摸事件，当前停留在屏幕中的触摸点信息的数组 changedTouches Array 触摸事件，当前变化的触摸点信息的数组 target 和 currentTarget 的区别 target 是触发该事件的源头组件，而 currentTarget 则是当前事件所绑定的组件。 123&lt;view class=&quot;outer-view&quot; bindtap=&quot;outerHandler&quot;&gt; &lt;button type=&quot;primary&quot;&gt;按钮&lt;/button&gt;&lt;/view&gt; bindtap 的语法格式 在小程序中，不存在 HTML 中的 onclick 鼠标点击事件，而是通过 tap 事件来响应用户的触摸行为。 通过 bindtap，可以为组件绑定 tap 触摸事件，语法如下： 1&lt;button type=&quot;primary&quot; bindtap=&quot;btnTapHandler&quot;&gt;按钮&lt;/button&gt; 在页面的 .js 文件中定义对应的事件处理函数，事件参数通过形参 event（一般简写成 e） 来接收： 123btnTapHandler(e)&#123; console.log(e) &#125;, 在事件处理函数中为 data 中的数据赋值 通过调用 this.setData(dataObject) 方法，可以给页面 data 中的数据重新赋值 1234567891011page(&#123; data: &#123; count: 0 &#125;&#125;)CountChange()&#123; this.setData(&#123; count: this.data.count +1 &#125;) &#125;, 事件传参 小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。 1&lt;button type=&quot;primary&quot; bindtap=&quot;btnTapHandler(123)&quot;&gt;事件传参&lt;/button&gt; 因为小程序会把 bindtap 的属性值，统一当作事件名称来处理，相当于要调用一个名称为 btnHandler(123) 的事件处理函数。 可以为组件提供 data-* 自定义属性传参，其中 * 代表的是参数的名字 12&lt;button type=&quot;primary&quot; bindtap=&quot;btnTapHand&quot; data-info=&quot;&#123;&#123;2&#125;&#125;&quot;&gt;事件传参&lt;/button&gt;&lt;!-没有&#123;&#123;&#125;&#125;将传递的是字符串不是值-&gt; 最终 info 会被解析为参数的名字 数值 2 会被解析为参数的值 在事件处理函数中，通过 event.target.dataset.参数名 即可获取到具体参数的值 1234btnTapHand(event)&#123;console.log(event.target.dataset) console.log(event.target.dataset.info) &#125;, bindinput 的语法格式 在小程序中，通过 input 事件来响应文本框的输入事件 通过 bindinput，可以为文本框绑定输入事件： 1&lt;input bindinput=&quot;inputHandler&quot;/&gt; 在页面的 .js 文件中定义事件处理函数： 123inputHandler(e)&#123; console.log(e.detail.value) &#125;, 实现文本框和 data 之间的数据同步 实现步骤 定义数据 12345pages(&#123; data: &#123; msg: &quot;你好&quot; &#125;&#125;) 渲染结构 1&lt;input value=&quot;&#123;&#123;msg&#125;&#125;&quot; bindinput=&quot;iptHandler&quot;/&gt; 美化样式 123456input&#123; border: 1px solid #eee; padding: 5px; margin: 5px; border-radius: 3px;&#125; 绑定 input 事件处理函数 12345iptHandler(e)&#123; this.setData(&#123; msg: e.detail.value &#125;) &#125;, 条件渲染 wx:if 在小程序中，使用 wx:if&#x3D;”“ 来判断是否需要渲染该代码块： 也可以用 wx:elif 和 wx:else 来添加 else 判断： 123&lt;view wx:if=&quot;&#123;&#123;type == 1&#125;&#125;&quot;&gt;男&lt;/view&gt;&lt;view wx:elif=&quot;&#123;&#123;type == 2&#125;&#125;&quot;&gt;女&lt;/view&gt;&lt;view wx:else=&quot;&#123;&#123;type == 3&#125;&#125;&quot;&gt;不清楚&lt;/view&gt; &#x3D;&#x3D;&#x3D; 为数据类型和数值都相等 结合 &lt;block&gt; 使用 wx:if 如果要一次性控制多个组件的展示与隐藏，可以使用一个 &lt;block&gt;&lt;&#x2F;block&gt; 标签将多个组件包装起来，并在&lt;block&gt; 标签上使用 wx:if 控制属性 1234&lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt; &lt;view&gt;view1&lt;/view&gt; &lt;view&gt;view2&lt;/view&gt;&lt;/block&gt; 注意：&lt;block&gt; 并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。 hidden 在小程序中，直接使用 hidden&#x3D;”“ 也能控制元素的显示与隐藏： 1&lt;view hidden=&quot;&#123;&#123;flag&#125;&#125;&quot;&gt;条件为true隐藏，条件为flase显示&lt;/view&gt; wx:if 与 hidden 的对比 运行方式不同 wx:if 以动态创建和移除元素的方式，控制元素的展示与隐藏 hidden 以切换样式的方式（display: none&#x2F;block;），控制元素的显示与隐藏 使用建议 频繁切换时，建议使用 hidden 控制条件复杂时，建议使用 wx:if 搭配 wx:elif、wx:else 进行展示与隐藏的切换 列表渲染 wx：for 通过wx:for可以根据指定数组，循环渲染重复的组件结构 1ar1:[&#x27;苹果&#x27;,&#x27;华为&#x27;,&#x27;小米&#x27;] 123&lt;view wx:for=&quot;&#123;&#123;ar1&#125;&#125;&quot;&gt; 索引是：&#123;&#123;index&#125;&#125; ,item项:&#123;&#123;item&#125;&#125;&lt;/view&gt; 默认情况下，当前循环项的索引用 index 表示；当前循环项用 item 表示。 手动指定索引和当前项的变量名* 使用 wx:for-index 可以指定当前循环项的索引的变量名 使用 wx:for-item 可以指定当前项的变量名 wx:key 的使用 类似于 Vue 列表渲染中的 :key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的 key 值，从而提高渲染的效率 12345userList: [ &#123;id: 1,name: &#x27;小马&#x27;&#125;, &#123;id: 2,name: &#x27;小隋&#x27;&#125;, &#123;id: 3,name: &#x27;小田&#x27;&#125; ] 1&lt;view wx:for=&quot;&#123;&#123;userList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt; WXSS模板样式 什么是WXSS WXSS (WeiXin Style Sheets)是一套样式语言，用于美化 WXML 的组件样式，类似于网页开发中的 CSS。 WXSS 和 CSS 的关系 WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发。与 CSS 相比，WXSS 扩展的特性有： rpx 尺寸单位 @import 样式导入 rpx 什么是 rpx 尺寸单位 rpx（responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位。 rpx 的实现原理rpx 的实现原理非常简单：鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕，在宽度上等分为 750 份（即：当前屏幕的总宽度为 750rpx）。 在较小的设备上，1rpx 所代表的宽度较小 在较大的设备上，1rpx 所代表的宽度较大 小程序在不同设备上运行的时候，会自动把 rpx 的样式单位换算成对应的像素单位来渲染，从而实现屏幕适配。 rpx 与 px 之间的单位换算* 在 iPhone6 上，屏幕宽度为375px，共有 750 个物理像素，等分为 750rpx。则： 750rpx &#x3D; 375px &#x3D; 750 物理像素 1rpx &#x3D; 0.5px &#x3D; 1物理像素 官方建议：开发微信小程序时，设计师可以用 iPhone6 作为视觉稿的标准。 开发举例：在 iPhone6 上如果要绘制宽100px，高20px的盒子，换算成rpx单位，宽高分别为 200rpx 和 40rpx。 样式导入 什么是样式导入 使用 WXSS 提供的 @import 语法，可以导入外联的样式表。 @import的语法样式@import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束 12345.username &#123; color: red;&#125;@import &quot;/common/common.wxss&quot;; 全局样式和局部样式 全局样式 定义在 app.wxss 中的样式为全局样式，作用于每一个页面。 局部样式 在页面的 .wxss 文件中定义的样式为局部样式，只作用于当前页面。 注意 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式 简单理解选择越详细，权重越高 全局配置 全局配置文件及常用的配置项 小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下： pages 记录当前小程序所有页面的存放路径 window 全局设置小程序窗口的外观 tabBar 设置小程序底部的 tabBar 效果 style 是否启用新版的组件样式 window 小程序窗口的组成部分 从上到下为导航栏区，背景区域，页面的主体区域 window只能配置导航栏区和背景区 了解 window 节点常用的配置项 属性名 类型 默认值 说明 navigationBarTitleText String 字符串 导航栏标题文字内容 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 #000000 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black &#x2F; white backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark &#x2F; light enablePullDownRefresh Boolean false 是否全局开启下拉刷新 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为px 主页面中app.json中改以上属性 设置上拉触底的距离 概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。 设置步骤： app.json -&gt; window -&gt; 为 onReachBottomDistance 设置新的数值 注意：默认距离为50px，如果没有特殊需求，建议使用默认值即可。 tabBar 什么是 tabBar tabBar 是移动端应用常见的页面效果，用于实现多页面 的快速切换。小程序中通常将其分为： 底部 tabBar 顶部 tabBar 注意 tabBar中只能配置最少 2 个、最多 5 个 tab 页签 当渲染顶部 tabBar 时，不显示 icon，只显示文本 icon是图标 tabBar 的 6 个组成部分 backgroundColor：tabBar 的背景色 selectedIconPath：选中时的图片路径 borderStyle：tabBar 上边框的颜色 iconPath：未选中时的图片路径 selectedColor：tab 上的文字选中时的颜色 color：tab 上文字的默认（未选中）颜色 tabBar 节点的配置项 属性 类型 必填 默认值 描述 position String 否 bottom tabBar 的位置，仅支持 bottom&#x2F;top borderStyle String 否 black tabBar 上边框的颜色，仅支持 black&#x2F;white color HexColor 否 tab 上文字的默认（未选中）颜色 selectedColor HexColor 否 tab 上的文字选中时的颜色 backgroundColor HexColor 否 tabBar 的背景色 list Array 是 tab 页签的列表，最少 2 个、最多 5 个 tab 每个 tab 项的配置选项 属性 类型 必填 描述 pagePath String 是 页面路径，页面必须在 pages 中预先定义 text String 是 tab 上显示的文字 iconPath String 否 未选中时的图标路径；当 postion 为 top 时，不显示 icon selectedIconPath String 否 选中时的图标路径；当 postion 为 top 时，不显示 icon 案例：配置 tabBar 需求描述 根据资料中提供的小图标、在小程序中配置如图所示的tabBar 效果： 实现步骤 123456789101112131415161718192021&quot;tabBar&quot;: &#123; &quot;list&quot;: [&#123; &quot;pagePath&quot;: &quot;pages/home/home&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;/images/tabs/home.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabs/home-active.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/message/message&quot;, &quot;text&quot;: &quot;消息&quot;, &quot;iconPath&quot;: &quot;/images/tabs/message.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabs/message-active.png&quot; &#125;, &#123; &quot;pagePath&quot;: &quot;pages/contact/contact&quot;, &quot;text&quot;: &quot;联系我们&quot;, &quot;iconPath&quot;: &quot;/images/tabs/contact.png&quot;, &quot;selectedIconPath&quot;: &quot;/images/tabs/contact-active.png&quot; &#125; ] &#125; 页面配置页面配置文件的作用小程序中，每个页面都有自己的 .json 配置文件，用来对当前页面的窗口外观、页面效果等进行配置。 页面配置和全局配置的关系小程序中，app.json 中的 window 节点，可以全局配置小程序中每个页面的窗口表现。 如果某些小程序页面想要拥有特殊的窗口表现，此时，“页面级别的 .json 配置文件”就可以实现这种需求。 注意：当页面配置与全局配置冲突时，根据就近原则，最终的效果以页面配置为准。 页面配置中常用的配置项 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000000 当前页面导航栏背景颜色，如 #000000 navigationBarTextStyle String white 当前页面导航栏标题颜色，仅支持 black &#x2F; white navigationBarTitleText String 当前页面导航栏标题文字内容 backgroundColor HexColor #ffffff 当前页面窗口的背景色 backgroundTextStyle String dark 当前页面下拉 loading 的样式，仅支持 dark &#x2F; light enablePullDownRefresh Boolean false 是否为当前页面开启下拉刷新的效果 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位为 px 网络数据请求小程序中网络数据请求的限制出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下 两个限制： 只能请求 HTTPS 类型的接口 必须将接口的域名添加到信任列表中 配置 request 合法域名需求描述：假设在自己的微信小程序中，希望请求 https://www.escook.cn/ 域名下的接口 配置步骤：登录微信小程序管理后台 -&gt; 开发 -&gt; 开发设置 -&gt; 服务器域名 -&gt; 修改 request 合法域名后台：https://mp.weixin.qq.com 注意事项： 域名只支持 https 协议 域名不能使用 IP 地址或 localhost 域名必须经过 ICP 备案 服务器域名一个月内最多可申请 5 次修改 发起 GET 请求调用微信小程序提供的 wx.request() 方法，可以发起 GET 数据请求 12345678910111213getInfo() &#123; wx.request(&#123; url: &#x27;https://www.escook.cn/api/get&#x27;, method: &#x27;GET&#x27;, data: &#123; name: &#x27;mhy&#x27;, age: &#x27;20&#x27; &#125;, success: (res) =&gt; &#123; console.log(res.data) &#125; &#125;) &#125;, 发起 POST 请求调用微信小程序提供的 wx.request() 方法，可以发起 POST 数据请求 12345678910111213getInfo() &#123; wx.request(&#123; url: &#x27;https://www.escook.cn/api/post&#x27;, method: &#x27;POST&#x27;, data: &#123; name: &#x27;mhy&#x27;, age: &#x27;20&#x27; &#125;, success: (res) =&gt; &#123; console.log(res.data) &#125; &#125;) &#125;, 在页面刚加载时请求数据在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 onLoad 事件中调用获取数据的函数 123onLoad(options) &#123; this.getInfo() &#125;, 跳过 request 合法域名校验如果后端程序员仅仅提供了 http 协议的接口、暂时没有提供 https 协议的接口。 此时为了不耽误开发的进度，我们可以在微信开发者工具中，临时 开启「开发环境不校验请求域名、TLS 版本及 HTTPS 证书」选项， 跳过 request 合法域名的校验。 注意： 跳过 request 合法域名校验的选项，仅限在开发与调试阶段使用！ 关于跨域和 Ajax说明跨域问题只存在于基于浏览器的 Web 开发中。由于小程序的宿主环境不是浏览器，而是微信客户端，所以小 程序中不存在跨域的问题。 Ajax 技术的核心是依赖于浏览器中的 XMLHttpRequest 这个对象，由于小程序的宿主环境是微信客户端，所 以小程序中不能叫做“发起 Ajax 请求”，而是叫做“发起网络数据请求”。 案例 本地生活1234567891011121314151617181920212223242526272829303132333435363738394041424344home.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; swiperList: [], gridList: [] &#125;, /** * 生命周期函数--监听页面加载 */ onLoad(options) &#123; this.getSwiperList(), this.getGridList() &#125;, //获取轮播图数据 getSwiperList() &#123; wx.request(&#123; url: &#x27;https://www.escook.cn/slides&#x27;, method: &#x27;GET&#x27;, success:(res) =&gt; &#123; console.log(res), this.setData(&#123; swiperList: res.data &#125;) &#125; &#125;) &#125;,//获取九宫格数据 getGridList() &#123; wx.request(&#123; url: &#x27;https://www.escook.cn/categories&#x27;, method: &#x27;GET&#x27;, success:(res) =&gt; &#123; console.log(res), this.setData(&#123; gridList: res.data &#125;) &#125; &#125;) &#125;, 123456789101112131415161718home.wxml&lt;swiper indicator-dots circular autoplay&gt; &lt;swiper-item wx:for=&quot;&#123;&#123;swiperList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt; &lt;image src=&quot;&#123;&#123;item.image&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;/swiper-item&gt;&lt;/swiper&gt;&lt;view class=&quot;grid-list&quot;&gt; &lt;view class=&quot;grid-item&quot; wx:for=&quot;&#123;&#123;gridList&#125;&#125;&quot; wx:key=&quot;id&quot; &gt; &lt;image src=&quot;&#123;&#123;item.icon&#125;&#125;&quot;&gt;&lt;/image&gt; &lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt;&lt;view class=&quot;img-box&quot;&gt; &lt;image src=&quot;/images/link-01.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt; &lt;image src=&quot;/images/link-02.png&quot; mode=&quot;widthFix&quot;&gt;&lt;/image&gt;&lt;/view&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748home.wxssswiper &#123; height: 350rpx;&#125;swiper image &#123; width: 100%; height: 100%;&#125;.grid-list &#123; display: flex; flex-wrap: wrap; border-left: 1px solid #efefef; border-top: 1px solid #efefef ;&#125;.grid-item &#123; width: 33.33%; height: 200rpx; display: flex; flex-direction: column; align-items: center; justify-content: center; border-right: 1px solid #efefef; border-bottom: 1px solid #efefef ; box-sizing: border-box;&#125;.grid-item image &#123; width: 60rpx; height: 60rpx;&#125;.grid-item text &#123; font-size: 24rpx; margin-top: 10rpx;&#125;.img-box &#123; display: flex; padding: 20rpx 10rpx; justify-content: space-around;&#125;.img-box image &#123; width: 45%;&#125;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"四级词汇26-33串词","slug":"四级词汇26-33串词","date":"2022-04-28T07:48:54.000Z","updated":"2022-05-08T15:18:58.001Z","comments":true,"path":"2022/04/28/四级词汇26-33串词/","link":"","permalink":"http://example.com/2022/04/28/%E5%9B%9B%E7%BA%A7%E8%AF%8D%E6%B1%8726-33%E4%B8%B2%E8%AF%8D/","excerpt":"","text":"第26串词：sign（书写，记号）design v.设计；构思 n.设计；图案 de-：向下 designer n.设计师；谋划者sign n.符号；迹象 v.签署；签名 a sign of stress 紧张的迹象 signature n.签名；署名signal n.信号 v.发信号；示意significant adj.有重大意义的assign v.分配；指派 as-：去 assignment n.任务；分派resign v.辞职第27串词：lat（to carry 带来，携带）relate v.联系 relate A to B &#x3D; A is related to B 把A和B联系起来 relatively adj.相比较而言 n.亲戚relatively adv.相当程度上；相较而言地relation n.关系；联系；关联（形式的连接）relationship n.联系；关系；爱情关系（密切的联系）relevant adj.密切相关的；切题的第28串词：ject（throw投掷）subject n.主题；试验对象 adj.服从的；易患的 v.使屈服于subjective adj.主观的project n.项目；方案 v.发射；预测；展示；放大projector n.放映机；投影仪object n.物体；目标 v.反对 ob&#x3D;op：相反 goal 目标 objective n.目标；目的 adj.客观的reject v.拒绝；抵制；丢弃第29串词：spect(to see, to look 看)expect v.预料；预期 ex- &#x3D; out expectation n.预期；期待unexpect adj.出乎意料的respect v.尊敬；尊重respectful adj.尊重的，有礼貌的 -ful ：主动的 主动尊敬 respectable adj.得体的；值得尊重的 -able：被动的 被尊敬的 respectively adv.分别；各自prospect n.前途；预期；景色 pro- &#x3D; 向前 suspect n.嫌疑犯 v.怀疑；猜想 su- &#x3D; under aspect n.方面；外貌 as- &#x3D; 朝着 perspective n.观点，远景 per- &#x3D; 彻底 第30串词：mun（munl）&#x3D; 公共的community n.社区；团体immune adj.免疫的；免除的 im &#x3D; in &#x3D; 否定 immunity n.免疫力；免除communicate v.沟通communication n.交流第31串词：ploy（折叠，引申为“繁忙”）employ v.雇主；运用 em-：使得 employee n.雇员employer n.雇主employment n.受雇；就业unemployed adj.就业的unemployment n.失业第32串词：maxmajor adj.主要的；主修的 n.主修科目 v.主修majority n.多数mass n.块；群众；大量；质量 adj.大规模的massive adj.巨大的maximum n.最大限度；最大量minmini n.迷你型 adj.微型的；袖珍minute n.分钟；片刻 adj.微小的；细微的（extremely small 非常非常非常小）minor adj.次要的；轻微的 n.未成年人；辅修科目minority n.少数；少数民族；未成年minimum n.最低限度第33串词：volv（to roll 转到，to turn 翻转）involve v.包含；卷入；参与 involution 内卷 involvement n.参与；恋爱evolve v.发展；进化（&#x3D;develop） e- ；out evolutionary adj.进化的；演变的revolution n.革命revolutionary adj.革命的volume n.容量；体积；音量；卷，册","categories":[],"tags":[{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"}]},{"title":"微信小程序入门","slug":"微信小程序入门","date":"2022-04-28T02:51:04.000Z","updated":"2022-04-29T06:03:09.119Z","comments":true,"path":"2022/04/28/微信小程序入门/","link":"","permalink":"http://example.com/2022/04/28/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8/","excerpt":"","text":"小程序简介1.小程序与普通网页开发的区别 运行环境不同 网页运行在浏览器环境中 小程序运行在微信环境中 API不同 由于运行环境的不同，所以小程序中，无法调用 DOM 和 BOM 的 API。 但是，小程序中可以调用微信环境提供 的各种 API，例如： 地理定位 扫码 支付 开发模式不同 网页的开发模式：浏览器 + 代码编辑器 小程序有自己的一套标准开发模式： 申请小程序开发账号 安装小程序开发者工具 创建和配置小程序项目 第一个小程序 - 注册小程序开发帐号 点击注册按钮 使用浏览器打开 https://mp.weixin.qq.com/ 网址，点击右上角的“立即注册”即可进入到小程序开发账号的注册流程 选择注册账号的类型 填写账号信息 提示邮箱激活 点击链接激活账号 选择主体类型 主体信息登记 获取小程序的 AppID 点击开发设置 安装开发者工具 了解微信开发者工具 主要功能 快速创建小程序项目 代码的查看和编辑 对小程序功能进行调试 小程序的预览和发布 下载推荐下载和安装最新的稳定版（Stable Build）的微信开发者工具，下载页面的链接如下： https://developers.weixin.qq.com/miniprogram/dev/devtools/stable.html 设置外观和代理 创建小程序项目 点击“加号”按钮 填写项目信息 项目创建完成 在模拟器上查看项目效果 在真机上预览项目效果 主界面的 5 个组成部分 项目结构 了解项目的基本组成结构 pages 用来存放所有小程序的页面 utils 用来存放工具性质的模块（例如：格式化时间的自定义模块） app.js 小程序项目的入口文件 app.wxss 小程序项目的全局样式文件 project.config.json 项目的配置文件 sitemap.json 用来配置小程序及其页面是否允许被微信索引 小程序页面的组成部分 小程序官方建议把所有小程序的页面，都存放在 pages 目录中，以单独的文件夹存在 其中，每个页面由 4 个基本文件组成，它们分别是： .js 文件（页面的脚本文件，存放页面的数据、事件处理函数等） .json 文件（当前页面的配置文件，配置窗口的外观、表现等） .wxml 文件（页面的模板结构文件） .wxss 文件（当前页面的样式表文件） JSON 配置文件 JSON 配置文件的作用 JSON 是一种数据格式，在实际开发中，JSON 总是以配置文件的形式出现。小程序项目中也不例外：通过不同的 .json 配置文件，可以对小程序项目进行不同级别的配置。 小程序项目中有 4 种 json 配置文件，分别是： 项目根目录中的 app.json 配置文件 项目根目录中的 project.config.json 配置文件 项目根目录中的 sitemap.json 配置文件 每个页面文件夹中的 .json 配置文件 app.json 文件 app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部 tab 等。Demo 项目里边的 app.json 配置内容如下： 简单了解下这 4 个配置项的作用： pages：用来记录当前小程序所有页面的路径 window：全局定义小程序所有页面的背景色、文字颜色等 style：全局定义小程序组件所使用的样式版本 sitemapLocation：用来指明 sitemap.json 的位置 project.config.json 文件 project.config.json 是项目配置文件，用来记录我们对小程序开发工具所做的个性化配置，例如： setting 中保存了编译相关的配置 projectname 中保存的是项目名称 appid 中保存的是小程序的账号 ID sitemap.json 文件 微信现已开放小程序内搜索，效果类似于 PC 网页的 SEO。sitemap.json 文件用来配置小程序页面是否允许微信索引。 当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索关键字和页面的索引匹配成功的时候，小程序的页面将可能展示在搜索结果中。 注意：sitemap 的索引提示是默认开启的，如需要关闭 sitemap 的索引提示，可在小程序项目配置文件project.config.json 的 setting 中配置字段 checkSiteMap 为 false 页面的 .json 配置文件 小程序中的每一个页面，可以使用 .json 文件来对本页面的窗口外观进行配置，页面中的配置项会覆盖app.json 的 window 中相同的配置项。 新建小程序页面 只需要在 app.json -&gt; pages 中新增页面的存放路径，小程序开发者工具即可帮我们自动创建对应的页面文件。 修改项目首页 只需要调整 app.json -&gt; pages 数组中页面路径的前后顺序，即可修改项目的首页。小程序会把排在第一位的页面，当作项目首页进行渲染。 WXML 模板 什么是 WXML WXML（WeiXin Markup Language）是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作用类似于网页开发中的 HTML。 WXML 和 HTML 的区别 标签名称不同 HTML （div, span, img, a） WXML（view, text, image, navigator） 属性节点不同 &#96;&#96;&#96;超链接123- ``` &lt;navigator url=&quot;/pages/home/home&quot;&gt;&lt;/navigator&gt; 提供了类似于 Vue 中的模板语法 数据绑定 列表渲染 条件渲染 WXSS 样式 什么是 WXSS WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS。 WXSS 和 CSS 的区别 新增了 rpx 尺寸单位 CSS 中需要手动进行像素单位换算，例如 rem WXSS 在底层支持新的尺寸单位 rpx，在不同大小的屏幕上小程序会自动进行换算 提供了全局的样式和局部样式 项目根目录中的 app.wxss 会作用于所有小程序页面 局部页面的 .wxss 样式仅对当前页面生效 WXSS 仅支持部分 CSS 选择器 .class 和 #id element 并集选择器、后代选择器 ::after 和 ::before 等伪类选择器 JS 逻辑交互 小程序中的 .js 文件 一个项目仅仅提供界面展示是不够的，在小程序中，我们通过 .js 文件来处理用户的操作。例如：响应用户的点击、获取用户的位置等等。 小程序中 .js 文件的分类 小程序中的 JS 文件分为三大类，分别是： app.js 是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序 页面的 .js 文件 是页面的入口文件，通过调用 Page() 函数来创建并运行页面 普通的 .js 文件 是普通的功能模块文件，用来封装公共的函数或属性供页面使用 宿主环境简介 什么是宿主环境 宿主环境（host environment）指的是程序运行所必须的依赖环境。 例如： Android 系统和 iOS 系统是两个不同的宿主环境。安卓版的微信 App 是不能在 iOS 环境下运行的，所以，Android 是安卓软件的宿主环境，脱离了宿主环境的软件是没有任何意义的！ 小程序的宿主环境 手机微信是小程序的宿主环境 小程序宿主环境包含的内容 通信模型 运行机制 组件 API 通信模型 通信的主体 小程序中通信的主体是渲染层和逻辑层 WXML 模板和 WXSS 样式工作在渲染层 JS 脚本工作在逻辑层 小程序的通信模型 小程序中的通信模型分为两部分： 渲染层和逻辑层之间的通信 由微信客户端进行转发 逻辑层和第三方服务器之间的通信 由微信客户端进行转发 运行机制 小程序启动的过程 把小程序的代码包下载到本地 解析 app.json 全局配置文件 执行 app.js 小程序入口文件，调用 App() 创建小程序实例 渲染小程序首页 小程序启动完成 页面渲染的过程 加载解析页面的 .json 配置文件 加载页面的 .wxml 模板和 .wxss 样式 执行页面的 .js 文件，调用 Page() 创建页面实例 页面渲染完成 组件 小程序中组件的分类 小程序中的组件也是由宿主环境提供的，开发者可以基于组件快速搭建出漂亮的页面结构。官方把小程序的组件分为了 9 大类，分别是： 视图容器 基础内容 表单组件 导航组件 媒体组件 map 地图组件 canvas 画布组件 开放能力 无障碍访问 常用的视图容器类组件 view 普通视图区域 类似于 HTML 中的 div，是一个块级元素 常用来实现页面的布局效果 scroll-view 可滚动的视图区域 常用来实现滚动列表效果 swiper 和 swiper-item 轮播图容器组件 和 轮播图 item 组件 view 组件的基本使用 实现如图的 flex 横向布局效果： 123456list.wxml&lt;view class=&quot;container1&quot;&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122list.wxss.container1 view &#123; width: 100px; height: 100px; text-align: center; line-height: 100px;&#125;.container1 view:nth-child(1)&#123; background-color: lightblue;&#125;.container1 view:nth-child(2)&#123; background-color: lightcoral;&#125;.container1 view:nth-child(3)&#123; background-color: lightgoldenrodyellow;&#125;.container1 &#123; display: flex; justify-content: space-around;&#125; scroll-view 组件的基本使用 实现如图的纵向滚动效果： 1234567list.wxml scroll-x 表示横行滑动&lt;scroll-view class=&quot;container1&quot; scroll-y&gt; &lt;view&gt;A&lt;/view&gt; &lt;view&gt;B&lt;/view&gt; &lt;view&gt;C&lt;/view&gt;&lt;/scroll-view&gt; html是骨架 css是化妆 js是动作 swiper 和 swiper-item 组件的基本使用 实现如图的轮播图效果： 12345678910111213wxml&lt;swiper class=&quot;swiper-container&quot;&gt; &lt;!--第一个轮播图--&gt; &lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;A&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;B&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view class=&quot;item&quot;&gt;C&lt;/view&gt; &lt;/swiper-item&gt;&lt;/swiper&gt; 12345678910111213141516171819202122wxss.swiper-container &#123; height: 150px;&#125;.item &#123; height: 100%; line-height: 150px; text-align: center;&#125;swiper-item:nth-child(1) .item&#123; background-color: lightgreen;&#125;swiper-item:nth-child(2) .item&#123; background-color: lightblue;&#125;swiper-item:nth-child(3) .item&#123; background-color: lightgoldenrodyellow;&#125; swiper 组件的常用属性（轮播图属性） 属性 类型 默认值 说明 indicator-dots boolean false 是否显示面板指示点,轮播图 indicator-color color rgba(0, 0, 0, .3) 指示点颜色 indicator-active-color color #000000 当前选中的指示点颜色 autoplay boolean false 是否自动切换 interval number 5000 自动切换时间间隔 circular boolean false 是否采用衔接滑动 常用的基础内容组件 text 文本组件 类似于 HTML 中的 span 标签，是一个行内元素 rich-text 富文本组件 支持把 HTML 字符串渲染为 WXML 结构 text 组件的基本使用 通过 text 组件的 selectable 属性，实现长按选中文本内容的效果 1234&lt;view&gt; 手机号支持长按操作 &lt;text selectable&gt;15247334313&lt;/text&gt;&lt;/view&gt; rich-text 组件的基本使用 通过 rich-text 组件的 nodes 属性节点，把 HTML 字符串渲染为对应的 UI 结构： 1&lt;rich-text nodes=&quot;&lt;h1 style=&#x27;color: red;&#x27;&gt;标题&lt;/h1&gt;&quot;&gt;&lt;/rich-text&gt; 其它常用组件 button 按钮组件 功能比 HTML 中的 button 按钮丰富 通过 open-type 属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等） image 图片组件 image 组件默认宽度约 300px、高度约 240px navigator（后面课程会专门讲解） 页面导航组件 类似于 HTML 中的 a 链接 button 按钮的基本使用1234567891011&lt;button&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;primary&quot;&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warn&quot;&gt;警告按钮&lt;/button&gt;&lt;view&gt;--------------mini小按钮----------------&lt;/view&gt;&lt;button size=&quot;mini&quot;&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; size=&quot;mini&quot;&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warn&quot; size=&quot;mini&quot;&gt;警告按钮&lt;/button&gt;&lt;view&gt;-----------------plain镂空--------------&lt;/view&gt;&lt;button size=&quot;mini&quot; plain&gt;默认按钮&lt;/button&gt;&lt;button type=&quot;primary&quot; size=&quot;mini&quot; plain&gt;主色调按钮&lt;/button&gt;&lt;button type=&quot;warn&quot; size=&quot;mini&quot; plain&gt;警告按钮&lt;/button&gt; image 组件的基本使用1&lt;image src=&quot;/imags/1.png&quot;&gt;&lt;/image&gt; 1&lt;image src=&quot;/imags/1.png&quot; mode=&quot;aspectFit&quot;&gt;&lt;/image&gt; image 组件的 mode 属性 image 组件的 mode 属性用来指定图片的裁剪和缩放模式，常用的 mode 属性值如下： mode值 说明 scaleToFill （默认值）缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 aspectFit 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 aspectFill 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 widthFix 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变 heightFix 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变 API 小程序 API 概述 小程序中的 API 是由宿主环境提供的，通过这些丰富的小程序 API，开发者可以方便的调用微信提供的能力,例如：获取用户信息、本地存储、支付功能等。 小程序 API 的 3 大分类 小程序官方把 API 分为了如下 3 大类： 事件监听 API 特点：以 on 开头，用来监听某些事件的触发 举例：wx.onWindowResize(function callback) 监听窗口尺寸变化的事件 同步 API 特点1：以 Sync 结尾的 API 都是同步 API 特点2：同步 API 的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常 举例：wx.setStorageSync(‘key’, ‘value’) 向本地存储中写入内容 异步 API 特点：类似于 jQuery 中的 $.ajax(options) 函数，需要通过 success、fail、complete 接收调用的结果 举例：wx.request() 发起网络数据请求，通过 success 回调函数接收数据 协同工作 了解权限管理需求 在中大型的公司里，人员的分工非常仔细：同一个小程序项目，一般会有不同岗位、不同角色的员工同时参与设计与开发。 此时出于管理需要，我们迫切需要对不同岗位、不同角色的员工的权限进行边界的划分，使他们能够高效的进行协同工作。 了解项目成员的组织结构 项目管理者：统筹整个项目的进展和风险，把控小程序对外发布的节奏 产品组：提需求 设计组：出设计方案 开发组：代码开发 测试组：项目测试 小程序的开发流程产品组提出需求-&gt;设计者设计-&gt;开发组开发-&gt;产品组和设计组体验-&gt;测试组测试-&gt;管理者进行发布 小程序成员管理 成员管理的两个方面 小程序成员管理体现在管理员对小程序项目成员及体验成员的管理： 项目成员： 表示参与小程序开发、运营的成员 可登录小程序管理后台 管理员可以添加、删除项目成员，并设置项目成员的角色 体验成员： 表示参与小程序内测体验的成员 可使用体验版小程序，但不属于项目成员 管理员及项目成员均可添加、删除体验成员 不同项目成员对应的权限 权限 运营者 开发者 数据分析者 开发者权限 * 体验者权限 * * * 登录 * * * 数据分析 * 微信支付 * 推广 * 开发管理 * 开发设置 * 暂停服务 * 解除关联公众号 * 腾讯云管理 * 小程序插件 * 游戏运营管理 * 开发者的权限说明 开发者权限：可使用小程序开发者工具及对小程序的功能进行代码开发 体验者权限：可使用体验版小程序 登录权限：可登录小程序管理后台，无需管理员确认 开发设置：设置小程序服务器域名、消息推送及扫描普通链接二维码打开小程序 腾讯云管理：云开发相关设置 添加项目成员和体验成员 https://mp.weixin.qq.com/中管理里成员管理可操作项目成员与体验人员 小程序的版本 软件开发过程中的不同版本 在软件开发过程中，根据时间节点的不同，会产出不同的软件版本，例如： 开发者编写代码的同时，对项目代码进行自测（开发版本） 直到程序达到一个稳定可体验的状态时，开发者把体验版本给到产品经理和测试人员进行体验测试 最后修复完程序的 Bug 后，发布正式版供外部用户使用 小程序的版本 版本阶段 说明 开发版本 使用开发者工具，可将代码上传到开发版本中。 开发版本只保留每人最新的一份上传的代码。点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。 体验版本 可以选择某个开发版本作为体验版，并且选取一份体验版。 审核中的版本 只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。 线上版本 线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。 发布上线 小程序发布上线的整体步骤 一个小程序的发布上线，一般要经过上传代码 -&gt; 提交审核 -&gt; 发布这三个步骤。 上传代码 点击开发者工具顶部工具栏中的“上传” 按钮 填写版本号以及项目备注 在后台查看上传之后的版本 登录小程序管理后台 -&gt; 管理 -&gt; 版本管理 -&gt; 开发版本，即可查看刚才提交上传的版本了： 提交审核 为什么需要提交审核：为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过腾讯官方审核的。 提交审核的方式：在开发版本的列表中，点击“提交审核”按钮之后，按照页面提示填写相关的信息，就能把小程序提交到腾讯官方进行审核。 发布 审核通过之后，管理员的微信中会收到小程序通过审核的通知，此时在审核版本的列表中，点击“发布”按钮之后，即可把“审核通过”的版本发布为“线上版本”，供所有小程序用户访问和使用。 基于小程序码进行推广 相对于普通二维码来说，小程序码的优势如下： 在样式上更具辨识度和视觉冲击力 能够更加清晰地树立小程序的品牌形象 可以帮助开发者更好地推广小程序 获取小程序码的 5 个步骤： 登录小程序管理后台 -&gt; 设置 -&gt; 基本设置 -&gt; 基本信息 -&gt; 小程序码及线下物料下载 运营数据 查看小程序运营数据的两种方式 在“小程序后台”查看 登录小程序管理后台 点击侧边栏的“统计” 点击相应的 tab 可以看到相关的数据 使用“小程序数据助手”查看 打开微信 搜索“小程序数据助手” 查看已发布的小程序相关的数据","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"MQTT1-4服务端连接操作","slug":"MQTT1-4服务端连接操作","date":"2022-04-27T15:03:16.000Z","updated":"2022-04-27T15:38:02.217Z","comments":true,"path":"2022/04/27/MQTT1-4服务端连接操作/","link":"","permalink":"http://example.com/2022/04/27/MQTT1-4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C/","excerpt":"","text":"首先，您可以通过MQTT官网下载到MQTTfx软件。MQTTfx的官网地址是：http://mqttfx.org https://blog.csdn.net/nicholaszao/article/details/79211965 ESP8266连接MQTT服务端SP8266的Arduino开发环境里有多个MQTT库，我们将使用最为流行的PubSubClient库来作为本教程的主要介绍对象，我们将通过一系列课程教您如何使用ESP8266通过PubSubClient库来实现MQTT物联网应用。 B站视频：https://www.bilibili.com/video/BV1T54y1k7MQ?spm_id_from=333.999.0.0 ESP8266链接代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;ESP8266WiFi.h&gt;#include &lt;PubSubClient.h&gt; // 设置wifi接入信息(请根据您的WiFi信息进行修改)const char* ssid = &quot;taichi-maker&quot;;const char* password = &quot;12345678&quot;;const char* mqttServer = &quot;test.ranye-iot.net&quot;; // 如以上MQTT服务器无法正常连接，请前往以下页面寻找解决方案// http://www.taichi-maker.com/public-mqtt-broker/ WiFiClient wifiClient;PubSubClient mqttClient(wifiClient); void setup() &#123; Serial.begin(9600); //设置ESP8266工作模式为无线终端模式 WiFi.mode(WIFI_STA); // 连接WiFi connectWifi(); // 设置MQTT服务器和端口号 mqttClient.setServer(mqttServer, 1883); // 连接MQTT服务器 connectMQTTServer();&#125; void loop() &#123; if (mqttClient.connected()) &#123; // 如果开发板成功连接服务器 mqttClient.loop(); // 保持客户端心跳 &#125; else &#123; // 如果开发板未能成功连接服务器 connectMQTTServer(); // 则尝试连接服务器 &#125;&#125; void connectMQTTServer()&#123; // 根据ESP8266的MAC地址生成客户端ID（避免与其它ESP8266的客户端ID重名） String clientId = &quot;esp8266-&quot; + WiFi.macAddress(); // 连接MQTT服务器 if (mqttClient.connect(clientId.c_str())) &#123; Serial.println(&quot;MQTT Server Connected.&quot;); Serial.println(&quot;Server Address: &quot;); Serial.println(mqttServer); Serial.println(&quot;ClientId:&quot;); Serial.println(clientId); &#125; else &#123; Serial.print(&quot;MQTT Server Connect Failed. Client State:&quot;); Serial.println(mqttClient.state()); //返回连接返回码 delay(3000); &#125; &#125; // ESP8266连接wifivoid connectWifi()&#123; WiFi.begin(ssid, password); //等待WiFi连接,成功连接后输出成功信息 while (WiFi.status() != WL_CONNECTED) &#123; delay(1000); Serial.print(&quot;.&quot;); &#125; Serial.println(&quot;&quot;); Serial.println(&quot;WiFi Connected!&quot;); Serial.println(&quot;&quot;); &#125; 参考文献B站视频：https://www.bilibili.com/video/BV1T54y1k7MQ?spm_id_from=333.999.0.0文档：http://www.taichi-maker.com/homepage/esp8266-nodemcu-iot/iot-tuttorial/mqtt-tutorial/client-connect-mqtt-server/","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"英语好句积累","slug":"英语好句积累","date":"2022-04-26T08:59:28.000Z","updated":"2022-04-26T09:16:29.284Z","comments":true,"path":"2022/04/26/英语好句积累/","link":"","permalink":"http://example.com/2022/04/26/%E8%8B%B1%E8%AF%AD%E5%A5%BD%E5%8F%A5%E7%A7%AF%E7%B4%AF/","excerpt":"","text":"A true master is an eternal student真正的大师，永远都怀着一颗学徒的心。 master：n.大师，主人 grand master 宗师 eternal：adj.永恒的，永远的 I long for a worthy opponent我渴望有价值的对手 Long for somebody&#x2F;something：渴望 worthy：adj.有价值的 opponent：n.对手 Its not how much time that you have;Its how you use it.时间不在于你拥有多少，而在于你怎样使用 强调句： it is + 强调部分 +that + 其他 I have been to the top of the mountain ，and the bottom of the gutter.There is much to learn from both.我曾踏足山巅，也曾跌入低谷，二者都使我受益良多。","categories":[],"tags":[{"name":"英语","slug":"英语","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD/"}]},{"title":"四级词汇21-25串词","slug":"四级词汇21-25串词","date":"2022-04-24T15:23:04.000Z","updated":"2022-04-28T07:44:32.884Z","comments":true,"path":"2022/04/24/四级词汇21-25串词/","link":"","permalink":"http://example.com/2022/04/24/%E5%9B%9B%E7%BA%A7%E8%AF%8D%E6%B1%8721-25%E4%B8%B2%E8%AF%8D/","excerpt":"","text":"第21串词：form（形状，形成）information n.信息；消息 -tion：名词结尾 inform v.通知；告发（officially tell：告诉） inform sb of&#x2F;about sth 通知某人某事 form n.类型；形式，样式；表格 v.形成formal adj.正式的 -al ：形容词词尾 informal adj.非正式的perform v.执行；表演（可替换do ：完成） per- ：彻底的，从头到尾的 performance n.性能；绩效；表演platform n.平台 plat：平台 reform n.改革 v.改革transform v.改变（彻底改变）format n.格式 -at&#x3D;“无意义” former adj.从前的；前者的（反义词:latter 后者的 ）formost 最重要的第22串词：cess&#x2F;ceed&#x2F;cede（行走）process n.过程；进程 v.加工；处理 proceed v.前进.移动；继续进行 pro-：向前 in the process of 处于…过程当中 procedure n.程序，步骤success n.成功succeed v.成功；继承 suc-：下面 successful adj.成功的 successive adj.连续的，相继的 access n.方法；途径；渠道(&#x3D; way) ac-：朝向 recession n.衰退；不景气excess n.超过；过度 adj.额外的 ex-：out exceed v.超过excessive adj.过多的ancestor n.祖先；始祖 an-：before 第23串词：tend&#x2F;tent&#x2F;tens（to stretch 伸）tend v.照料；趋向 tend to 倾向 tendency n.倾向；趋势attend v.出席；照料 attend to sth&#x2F;sb 处理事&#x2F;照料人 attendance n.出席attention n.注意力extend v.延伸；扩展extent n.程度；范围 to some extent 在某种程度上 extension n.延长；扩展；延长部分extensive adj.广泛的；大量的intend v.打算；想要intention n.意图 real&#x2F;evil&#x2F;good intention 真实意图&#x2F;恶意&#x2F;好心 tent n.帐篷content n.内容；目录 adj.满意的 v.使满足tense adj.紧张的；紧绷的 n.时态tension n.张力;紧张 v.使紧张；拉紧intense adj.强烈的第24串词：ceive&#x2F;cept&#x2F;cap&#x2F;cup（to take，to seize 拿，抓）receive v.收到；招待；接待（被动收到）accept v.承认；接受（主动接受）acceptable adj.可接受的concept n.观念except conj.除了 prep.除…之外 besides prep.除…还…. exception n.例外 without exception 一律；无一例外 exceptional adj.异常的；例外的；卓越的perceive v.察觉；理解 per-：彻底，从头到尾 capacity n.能力；容量；资格capture v.俘获；捕捉 n.捕获anticipate v.预期；预料participate v.参与 take part in participant n.参与者occupation n.职业第25串词：nov（new 新）novel n.小说 adj.新奇的（&#x3D;new）innovative adj.创新的innovator n.创新者innovate v.创新innovation n.创新","categories":[],"tags":[{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"}]},{"title":"maven基础","slug":"maven基础","date":"2022-04-24T02:05:15.000Z","updated":"2022-04-25T08:57:23.441Z","comments":true,"path":"2022/04/24/maven基础/","link":"","permalink":"http://example.com/2022/04/24/maven%E5%9F%BA%E7%A1%80/","excerpt":"","text":"maven概述 什么是maven Maven的正确发音是[ˈmevən]，而不是“马瘟”以及其他什么瘟。Maven在美国是一个口语化的词语，代表专家、内行的意思。 一个对Maven比较正式的定义是这么说的：Maven是一个项目管理工具，它包含了一个**项目对象模型(POM：Project Object Model)**，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 能干什么 现在有一种工具，可以把你从上面的繁琐工作中解放出来，能帮你构建工程，管理jar包，编译代码，还能帮你自动运行单元测试，打包，生成报表，甚至能帮你部署项目，生成Web站点，meven就能解决以上问题 maven经典作用1.2.1 Maven的依赖管理概念：maven工程对jar包的管理过程 通过pom.xml文件配置要引入的jar包的坐标，再读取坐标并到仓库中加载jar包，这样我们就可以直接使用jar包了 1.2.2 项目的一键构建构建是指项目从编译、测试、运行、打包、安装，部署整个过程都交给maven进行管理，这个过程称为构建。 一键构建指的是整个构建过程，使用maven一个命令可以轻松完成整个工作。 maven的安装mac安装：https://blog.csdn.net/wang_jing_jing/article/details/120403123https://blog.csdn.net/u011374856/article/details/116648311关闭终端有报错：解决文字 https://www.cnblogs.com/momo-nancy/p/nancy_0688.html maven仓库2.2.1 仓库分类 本地仓库 用来存储从远程仓库或中央仓库下载的插件和jar包，项目使用一些插件或jar包，优先从本地仓库查找默认本地仓库位置在${user.dir}&#x2F;.m2&#x2F;repository，${user.dir}表示windows用户目录。 远程仓库 如果本地需要插件或者jar包，本地仓库没有，默认去远程仓库下载。远程仓库可以在互联网内也可以在局域网内。 中央仓库 在maven软件中内置一个远程仓库地址http://repo1.maven.org/maven2，它是中央仓库，服务于整个互联网，它是由Maven团队自己维护，里面存储了非常全的jar包，它包含了世界上大部分流行的开源项目构件。 2.2.2 Maven本地仓库的配置打开settings.xml文件， 1&lt;loaclRepository&gt;本地仓路径&lt;/loaclRepository&gt; 2.2.3 全局setting与用户settingmaven仓库地址、私服等配置信息需要在setting.xml文件中配置，分为全局配置和用户配置。 Maven 工程的认识2.3.1 Maven工程的目录结构作为一个maven工程，它的src目录和pom.xml是必备的。 src目录src&#x2F;main&#x2F;java——存放项目的.java文件 src&#x2F;main&#x2F;resources——存放项目资源文件，如spring, hibernate配置文件 src&#x2F;test&#x2F;java——存放所有单元测试.java文件，如JUnit测试类 src&#x2F;test&#x2F;resources——测试资源文件 target——项目输出位置，编译后的class文件会输出到此目录 pom.xml——maven项目核心配置文件 注意：如果是普通的java项目，那么就没有webapp目录。 Maven 常用命令 compile compile是maven工程的编译命令，作用是将src&#x2F;main&#x2F;java下的文件编译为class文件输出到target目录下。 test test是maven工程的测试命令mvn test，会执行src&#x2F;test&#x2F;java下的单元测试类。 clean clean是maven工程的清理命令，执行clean会删除target目录及内容。 package package是maven工程的打包命令，对于java工程执行package打成jar包，对于web工程打成war包。 install install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。 Maven 生命周期maven对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： Clean Lifecycle在进行真正的构建之前进行一些清理工作。 Default Lifecycle构建的核心部分，编译，测试，打包，部署等等。（默认生命周期） Site Lifecycle生成项目报告，站点，发布站点。 Maven 概念模型Maven包含了一个项目对象模型(Project Object Model)，一组标准集合，一个项目生命周期(ProjectLifecycle)，一个依赖管理系统(DependencyManagementSystem)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 项目概念模型 一个maven工程都有一个pom.xml文件，通过pom.xml文件定义项目的坐标、项目依赖、项目信息、插件目标等。 依赖管理系统 通过maven的依赖管理对项目所依赖的jar包进行统一管理。 必须包含 项目名称 版本名称 一个项目生命周期 使用maven完成项目的构建，项目构建包括：清理、编译、测试、部署等过程，maven将这些过程规范为一个生命周期， maven通过执行一些简单命令即可实现上边生命周期的各各过程，比如执行mvn compile执行编译、执行mvn clean执行清理。 一组标准集合 maven将整个项目管理过程定义一组标准，比如：通过maven构建工程有标准的目录结构，有标准的生命周期阶段、依赖管理有标准的坐标定义等。 插件目标 maven管理项目生命周期过程都是基于插件完成的。 idea开发maven项目 idea的maven配置 打开-&gt; File-&gt; Settings配置maven 坐标是唯一标识 Groupid：公司或组织的名称 Artifactid：项目名 Version：版本号 打包方式 &#96;&#96;&#96;123456789 - Jar:java项目，默认值 - war：web项目 - pom## 项目中添加的坐标 junit junit 4.12 test 123## 添加插件 //添加插件 //编译插件 org.apache.maven.plugins maven-compiler-plugin 3.1 1 //Tomcat插件，启动当前web应用 org.apache.tomcat.maven tomcat7-maven-plugin 2.1 8848//修改tomcat端口 ///修改tomcat虚拟路径 1 //导入serlet javax.servlet javax.servlet-api 3.1.0 ``` 依赖范围详解A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包括： compile：编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。 provided：provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。 runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。 test：test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用，比如：junit。由于运行时不需要所以 test范围依赖不会被打包。 system：system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"Redis","slug":"Redis","date":"2022-04-23T03:00:23.000Z","updated":"2022-04-23T13:59:33.796Z","comments":true,"path":"2022/04/23/Redis/","link":"","permalink":"http://example.com/2022/04/23/Redis/","excerpt":"","text":"主要内容 redis 概念 下载安装 命令操作 数据结构 持久化操作 使用Java客户端操作redis Redis 概念： redis是一款高性能的NOSQL系列的非关系型数据库 什么是NOSQL NoSQL(NoSQL &#x3D; Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 NOSQL和关系型数据库比较 优点 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 非关系型数据库的优势： 性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 总结 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库， 让NoSQL数据库对关系型数据库的不足进行弥补。 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 主流的NOSQL产品 键值(Key-Value)存储数据库 相关产品： Tokyo Cabinet&#x2F;Tyrant、Redis、Voldemort、Berkeley DB 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 列存储数据库 相关产品：Cassandra, HBase, Riak 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档型数据库 相关产品：CouchDB、MongoDB 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 相关数据库：Neo4J、InfoGrid、Infinite Graph 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 什么是Redis Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下： 字符串类型 string 哈希类型 hash 列表类型 list 集合类型 set 有序集合类型 sortedset redis的应用场景 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 下载安装 官网：https://redis.io 中文网：http://www.redis.net.cn/ mac安装：https://blog.csdn.net/weixin_45509705/article/details/119242390 https://www.jianshu.com/p/2972c8e6d2f6 解压直接可以使用： redis.windows.conf：配置文件 redis-cli.exe：redis的客户端 redis-server.exe：redis服务器端 命令操作 redis的数据结构： redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构 value的数据结构： 字符串类型 string 哈希类型 hash ： map格式 列表类型 list ： linkedlist格式。支持重复元素 集合类型 set ： 不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 字符串类型 string 存储： set key value 127.0.0.1:6379&gt; set username zhangsanOK 获取： get key 127.0.0.1:6379&gt; get username“zhangsan” 删除： del key 127.0.0.1:6379&gt; del age(integer) 1 哈希类型 hash 存储： hset key field value 127.0.0.1:6379&gt; hset myhash username lisi(integer) 1127.0.0.1:6379&gt; hset myhash password 123(integer) 1 获取： hget key field: 获取指定的field对应的值127.0.0.1:6379&gt; hget myhash username“lisi” hgetall key：获取所有的field和value127.0.0.1:6379&gt; hgetall myhash \\1) “username” \\2) “lisi” \\3) “psaaward” \\4) “123” 删除： hdel key field 127.0.0.1:6379&gt; hdel myhash username(integer) 1 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边 ​ 127.0.0.1:6379&gt; lpush myList a​ (integer) 1​ 127.0.0.1:6379&gt; lpush myList b​ (integer) 2​ 127.0.0.1:6379&gt; rpush myList c​ (integer) 3 获取： lrange key start end ：范围获取 127.0.0.1:6379&gt; lrange myList 0 -1 “b” “a” “c” 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set ： 不允许重复元素 存储：sadd key value 127.0.0.1:6379&gt; sadd myset a(integer) 1127.0.0.1:6379&gt; sadd myset a(integer) 0 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379&gt; smembers myset 1) &quot;a&quot; 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379&gt; srem myset a(integer) 1 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value ​ 127.0.0.1:6379&gt; zadd mysort 60 zhangsan​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 50 lisi​ (integer) 1​ 127.0.0.1:6379&gt; zadd mysort 80 wangwu​ (integer) 1 获取：zrange key start end [withscores] 1234127.0.0.1:6379&gt; zrange mysort 0 -1 1) &quot;lisi&quot; 2) &quot;zhangsan&quot; 3) &quot;wangwu&quot; 1234567127.0.0.1:6379&gt; zrange mysort 0 -1 withscores 1) &quot;zhangsan&quot; 2) &quot;60&quot; 3) &quot;wangwu&quot; 4) &quot;80&quot; 5) &quot;lisi&quot; 6) &quot;500&quot; 删除：zrem key value 12127.0.0.1:6379&gt; zrem mysort lisi (integer) 1 通用命令 keys * : 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value 持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB：默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 123456# after 900 sec (15 min) if at least 1 key changed save 900 1# after 300 sec (5 min) if at least 10 keys changed save 300 10# after 60 sec if at least 10000 keys changed save 60 10000 重新启动redis服务器，并指定配置文件名称 1D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9&gt;redis-server.exe redis.windows.conf AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windwos.conf文件 12345appendonly no（关闭aof） --&gt; appendonly yes （开启aof） # appendfsync always ： 每一次操作都进行持久化appendfsync everysec ： 每隔一秒进行一次持久化# appendfsync no ： 不进行持久化 Java客户端 Jedis Jedis: 一款java操作redis数据库的工具. 使用步骤： 下载jedis的jar包 使用 123456 //1. 获取连接Jedis jedis = new Jedis(&quot;localhost&quot;,6379); //2. 操作 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); //3. 关闭连接jedis.close(); Jedis操作各种redis中的数据结构 字符串类型 string set get 123456789101112131415 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口//2. 操作//存储 jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);//获取String username = jedis.get(&quot;username&quot;);System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接jedis.close(); 哈希类型 hash ： map格式 hset hget hgetAll 123456789101112131415161718192021222324//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // 存储hash jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;); jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;); jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;); // 获取hash String name = jedis.hget(&quot;user&quot;, &quot;name&quot;); System.out.println(name); // 获取hash的所有map中的数据 Map&lt;String, String&gt; user = jedis.hgetAll(&quot;user&quot;); // keyset Set&lt;String&gt; keySet = user.keySet(); for (String key : keySet) &#123; //获取value String value = user.get(key); System.out.println(key + &quot;:&quot; + value); &#125; //3. 关闭连接 jedis.close(); 列表类型 list ： linkedlist格式。支持重复元素 lpush &#x2F; rpushlpop &#x2F; rpoplrange start end : 范围获取 123456789101112131415161718192021222324//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // list 存储 jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从左边存 jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);//从右边存 // list 范围获取 List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(&quot;mylist&quot;);//c System.out.println(element1); String element2 = jedis.rpop(&quot;mylist&quot;);//c System.out.println(element2); // list 范围获取 List&lt;String&gt; mylist2 = jedis.lrange(&quot;mylist&quot;, 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 123456789101112//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // set 存储 jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;); // set 获取 Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;); System.out.println(myset); //3. 关闭连接 jedis.close(); 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange 1234567891011121314//1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 &quot;localhost&quot;,6379端口 //2. 操作 // sortedset 存储 jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;); jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;); jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;); // sortedset 获取 Set&lt;String&gt; mysortedset = jedis.zrange(&quot;mysortedset&quot;, 0, -1); System.out.println(mysortedset); //3. 关闭连接 jedis.close(); jedis连接池： JedisPool 使用： 创建JedisPool连接池对象 调用方法 getResource()方法获取Jedis连接 1234567891011121314//0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,&quot;localhost&quot;,6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(&quot;hehe&quot;,&quot;heihei&quot;); //4. 关闭 归还到连接池中 jedis.close(); 连接池工具类 123456789101112131415161718192021222324252627282930public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;))); config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;))); &#125; /** * 获取连接方法 */ public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125; &#125; 案例：案例需求： 提供index.html页面，页面中有一个省份 下拉列表 当 页面加载完成后 发送ajax请求，加载所有省份 注意：使用redis缓存一些不经常发生变化的数据。 数据库的数据一旦发生改变，则需要更新缓存。 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 在service对应的增删改方法中，将redis数据删除。 12345678910111213141516171819202122#最大活动对象数 redis.pool.maxTotal=1000 #最大能够保持idel状态的对象数 redis.pool.maxIdle=100 #最小能够保持idel状态的对象数 redis.pool.minIdle=50 #当池内没有返回对象时，最大等待时间 redis.pool.maxWaitMillis=10000 #当调用borrow Object方法时，是否进行有效性检查 redis.pool.testOnBorrow=true #当调用return Object方法时，是否进行有效性检查 redis.pool.testOnReturn=true #“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1. redis.pool.timeBetweenEvictionRunsMillis=30000 #向调用者输出“链接”对象时，是否检测它的空闲超时； redis.pool.testWhileIdle=true # 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3. redis.pool.numTestsPerEvictionRun=50 #redis服务器的IP redis.ip=xxxxxx #redis服务器的Port redis1.port=6379","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MQTT1-3连接MQTT服务端","slug":"MQTT1-3连接MQTT服务端","date":"2022-04-22T14:21:03.000Z","updated":"2022-04-22T15:17:05.975Z","comments":true,"path":"2022/04/22/MQTT1-3连接MQTT服务端/","link":"","permalink":"http://example.com/2022/04/22/MQTT1-3%E8%BF%9E%E6%8E%A5MQTT%E6%9C%8D%E5%8A%A1%E7%AB%AF/","excerpt":"","text":"MQTT客户端连接服务端一共有两步 首先MQTT客户端将会向服务端发送连接请求。该请求实际上是一个包含有连接请求信息的数据包。这个数据包的官方名称为CONNECT。 MQTT服务端收到客户端连接请求后，会向客户端发送连接确认。同样的，该确认也是一个数据包。这个数据包官方名称为CONNACK。 CONNECT – 连接服务端（客户端） clientId – 客户端ID ClientId是MQTT客户端的标识。MQTT服务端用该标识来识别客户端。因此ClientId必须是独立的。如果两个MQTT客户端使用相同ClientId标识，服务端会把它们当成同一个客户端来处理。 cleanSession – 清除会话 如果cleanSession 被设置为“true”。那么服务端不需要客户端确认收到报文，也不会保存任何报文。在这种情况下，即使客户端错过了服务端发来的报文，也没办法让服务端再次发送报文。 如果我们将cleanSession 设置为”false”。那么服务端就知道，后续通讯中，客户端可能会要求我保存没有收到的报文。 如果想让服务器记住重要报文，那么客户端在连接服务端时，需要把cleanSession中设置为false。 keepAlive – 心跳时间间隔 KeepAlive用于服务端实时了解客户端是否与其保持连接的情况。 CONNACK – 确认连接请求（服务端） returnCode – 连接返回码 当服务端收到了客户端的连接请求后，会向客户端发送returnCode(连接返回码)，用以说明连接情况。 返回码 返回码描述 0 成功连接 1 连接被服务端拒绝，原因是不支持客户端的MQTT协议版本 2 连接被服务端拒绝，原因是不支持客户端标识符的编码。可能造成此原因的是客户端标识符编码是UTF-8，但是服务端不允许使用此编码。 3 连接被服务端拒绝，原因是服务端不可用。即，网络连接已经建立，但MQTT服务不可用。 4 连接被服务端拒绝，原因是用户名或密码无效。 5 连接被服务端拒绝，原因是客户端未被授权连接到此服务端。 sessionPresent – 当前会话 其作用是客户端发送连接请求时，服务端告知客户端有没有保存报文信息。这个被服务端保存的报文信息是来自于上一次客户端连接时，服务端曾经发送此报文给客户端，但是发送后没有收到客户端接收确认。","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"AJAX&Json","slug":"AJAX-Json","date":"2022-04-22T03:11:42.000Z","updated":"2022-04-22T10:14:03.686Z","comments":true,"path":"2022/04/22/AJAX-Json/","link":"","permalink":"http://example.com/2022/04/22/AJAX-Json/","excerpt":"","text":"主要内容 AJAX JSON AJAX： 概念： ASynchronous JavaScript And XML 异步的JavaScript 和 XML 异步和同步：客户端和服务器端相互通信的基础上 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。 提升用户的体验 实现方式： 原生的JS实现方式（了解） 1234567891011121314151617181920212223242526272829303132333435363738394041//1.创建核心对象 var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; //2. 建立连接 /* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(&quot;GET&quot;,&quot;ajaxServlet?username=tom&quot;,true); //3.发送请求 xmlhttp.send(); //4.接受并处理来自服务器的响应结果 //获取方式 ：xmlhttp.responseText //什么时候获取？当服务器响应成功后再获取 //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 xmlhttp.onreadystatechange=function() &#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125; &#125; JQeury实现方式 $.ajax() 123456789101112131415//使用$.ajax()发送异步请求 $.ajax(&#123; url:&quot;ajaxServlet1111&quot; , // 请求路径 type:&quot;POST&quot; , //请求方式 //data: &quot;username=jack&amp;age=23&quot;,//请求参数 data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(&quot;出错啦...&quot;) &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:&quot;text&quot;//设置接受到的响应数据的格式 &#125;); $.get()：发送get请求 123456* 语法：$.get(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 $.post()：发送post请求 123456* 语法：$.post(url, [data], [callback], [type]) * 参数： * url：请求路径 * data：请求参数 * callback：回调函数 * type：响应结果的类型 JSON： 概念： JavaScript Object Notation JavaScript对象表示法 1234Person p = new Person(); p.setName(&quot;张三&quot;); p.setAge(23); p.setGender(&quot;男&quot;); 1var p = &#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;&#125;; json现在多用于存储和交换文本信息的语法 进行数据的传输 JSON 比 XML 更小、更快，更易解析 语法： 基本规则 数据在名称&#x2F;值对中：json数据是由键值对构成的 键用引号(单双都行)引起来，也可以不使用引号 值得取值类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） {“address”:{“province”：”陕西”….}} null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{}定义json 格式 方括号保存数组：[] 获取数据: json对象.键名 json对象[“键名”] 数组对象[索引] 遍历 123456789101112131415161718192021//1.定义基本格式 var person = &#123;&quot;name&quot;: &quot;张三&quot;, age: 23, &#x27;gender&#x27;: true&#125;; var ps = [&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 23, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 24, &quot;gender&quot;: true&#125;, &#123;&quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;gender&quot;: false&#125;]; //获取person对象中所有的键和值 //for in 循环 /* for(var key in person)&#123; //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); &#125;*/ //获取ps中的所有值 for (var i = 0; i &lt; ps.length; i++) &#123; var p = ps[i]; for(var key in p)&#123; alert(key+&quot;:&quot;+p[key]); &#125; &#125; JSON数据和Java对象的相互转换 (json可以转换为任何语言) JSON解析器： 常见的解析器：Jsonlib，Gson，fastjson，jackson JSON转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class) Java对象转换JSON 使用步骤： 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 1ObjectMapper mapper = new ObjectMapper(); 调用ObjectMapper的相关方法进行转换 转换方法： writeValue(参数1，obj): 参数1： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 writeValueAsString(obj):将对象转为json字符串 注解： @JsonIgnore：排除属性。 @JsonFormat：属性值得格式化 @JsonFormat(pattern &#x3D; “yyyy-MM-dd”) 复杂java对象转换 List：数组 Map：对象格式一致 案例： 校验用户名是否存在 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案： $.get(type):将最后一个参数type指定为”json” 在服务器端设置MIME类型 response.setContentType(“application&#x2F;json;charset&#x3D;utf-8”); 代码 客户端 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;script src=&quot;js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $(&quot;#username&quot;).blur(function () &#123; var username = $(this).val(); $.get(&quot;findUserSerlet&quot;,&#123;username:username&#125;,function (data) &#123; var span= $(&quot;#s_username&quot;); if (data.userExsit)&#123; span.css(&quot;color&quot;,&quot;red&quot;); span.html(data.msg); &#125;else &#123; span.css(&quot;color&quot;,&quot;green&quot;); span.html(data.msg); &#125; &#125;,&quot;json &quot;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt; &lt;span id=&quot;s_username&quot;&gt;&lt;/span&gt; &lt;br&gt; &lt;input type=&quot;password&quot; name=&quot;username&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 服务器 12345678910111213141516171819202122232425@WebServlet(&quot;/findUserSerlet&quot;)public class FindUserSerlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String username = request.getParameter(&quot;username&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); if(&quot;Tom&quot;.equals(username))&#123; map.put(&quot;userExsit&quot;,true); map.put(&quot;msg&quot;,&quot;该用户名不可以&quot;); &#125;else &#123; map.put(&quot;userExsit&quot;,false); map.put(&quot;msg&quot;,&quot;该用户名可以用&quot;); &#125; ObjectMapper mapper = new ObjectMapper(); mapper.writeValue(response.getWriter(),map); &#125; @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"JQuery高级","slug":"JQuery高级","date":"2022-04-21T05:26:47.000Z","updated":"2022-04-21T09:53:00.950Z","comments":true,"path":"2022/04/21/JQuery高级/","link":"","permalink":"http://example.com/2022/04/21/JQuery%E9%AB%98%E7%BA%A7/","excerpt":"","text":"主要内容 JQuery 高级 动画 遍历 事件绑定 案例 插件 JQuery 高级 动画 三种方式显示和隐藏元素 默认显示和隐藏方式 show([speed,[easing],[fn]]) 显示 参数： speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，默认是”swing”，可用参数”linear” swing：动画执行时效果是 先慢，中间快，最后又慢 linear：动画执行时速度是匀速的 fn：在动画完成时执行的函数，每个元素执行一次。 hide([speed,[easing],[fn]]) 隐藏 toggle([speed],[easing],[fn]) 切换 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历 js的遍历方式 for(初始化值;循环结束条件;步长) jq的遍历方式 jq对象.each(callback) 语法： jquery对象.each(function(index,element){}); index:就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象 回调函数返回值： true:如果当前function返回为false，则结束循环(break)。 false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 事件绑定 jquery标准的绑定方式 jq对象.事件方法(回调函数)； 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();&#x2F;&#x2F;让表单提交 on绑定事件&#x2F;off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：toggle jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 1&lt;script src=&quot;../js/jquery-migrate-1.0.0.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; 案例 案例1 1234567需求：1. 当页面加载完，3秒后。自动显示广告2. 广告显示5秒后，自动消失。分析：1. 使用定时器来完成。setTimeout (执行一次定时器)2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display3. 使用 show/hide方法来完成广告的显示 123456789101112131415161718代码//入口函数，在页面加载完成之后，定义定时器，调用这两个方法$(function () &#123; //定义定时器，调用adShow方法 3秒后执行一次 setTimeout(adShow,3000); //定义定时器，调用adHide方法，8秒后执行一次 setTimeout(adHide,8000); &#125;); //显示广告 function adShow() &#123; //获取广告div，调用显示方法 $(&quot;#ad&quot;).show(&quot;slow&quot;); &#125; //隐藏广告 function adHide() &#123; //获取广告div，调用隐藏方法 $(&quot;#ad&quot;).hide(&quot;slow&quot;); &#125; 案例2 123456789分析： 1. 给开始按钮绑定单击事件 1.1 定义循环定时器 1.2 切换小相框的src属性 * 定义数组，存放图片资源路径 * 生成随机数。数组索引 2. 给结束按钮绑定单击事件 1.1 停止定时器 1.2 给大相框设置src属性 代码 1234567891011121314151617181920212223242526272829303132333435363738394041var imgs = [&quot;../img/man00.jpg&quot;, &quot;../img/man01.jpg&quot;, &quot;../img/man02.jpg&quot;, &quot;../img/man03.jpg&quot;, &quot;../img/man04.jpg&quot;, &quot;../img/man05.jpg&quot;, &quot;../img/man06.jpg&quot;, ]; var startId;//开始定时器的id var index;//随机角标 $(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); //1. 给开始按钮绑定单击事件 $(&quot;#startID&quot;).click(function () &#123; // 1.1 定义循环定时器 20毫秒执行一次 startId = setInterval(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,true); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,false); //1.2生成随机角标 0-6 index = Math.floor(Math.random() * 7);//0.000--0.999 --&gt; * 7 --&gt; 0.0-----6.9999 //1.3设置小相框的src属性 $(&quot;#img1ID&quot;).prop(&quot;src&quot;,imgs[index]); &#125;,20); &#125;); //2. 给结束按钮绑定单击事件 $(&quot;#stopID&quot;).click(function () &#123; //处理按钮是否可以使用的效果 $(&quot;#startID&quot;).prop(&quot;disabled&quot;,false); $(&quot;#stopID&quot;).prop(&quot;disabled&quot;,true); // 1.1 停止定时器 clearInterval(startId); // 1.2 给大相框设置src属性 $(&quot;#img2ID&quot;).prop(&quot;src&quot;,imgs[index]).hide(); //显示1秒之后 $(&quot;#img2ID&quot;).show(1000); &#125;); &#125;); 插件：增强JQuery的功能 实现方式： $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $&#x2F;jQuery 123456//定义了check方法$.fn.extend(&#123; check:function () &#123; alert(123); &#125; &#125;); 1234567$.extend(&#123; MAX:function () &#123; &#125; &#125;); //调用 $.MAX();","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MQTT1-2MQTT基本原理","slug":"MQTT1-2MQTT基本原理","date":"2022-04-20T14:42:45.000Z","updated":"2022-04-21T05:24:02.356Z","comments":true,"path":"2022/04/20/MQTT1-2MQTT基本原理/","link":"","permalink":"http://example.com/2022/04/20/MQTT1-2MQTT%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/","excerpt":"","text":"MQTT服务端MQTT服务端通常是一台服务器。它是MQTT信息传输的枢纽，负责将MQTT客户端发送来的信息传递给MQTT客户端。MQTT服务端还负责管理MQTT客户端。确保客户端之间的通讯顺畅，保证MQTT消息得以正确接收和准确投递。 MQTT客户端MQTT客户端可以向服务端发布信息，也可以从服务端收取信息。我们把客户端发送信息的行为成为“发布”信息。而客户端要想从服务端收取信息，则首先要向服务端“订阅”信息。“订阅”信息这一操作很像我们在视频网站订阅某一部电视剧。当这部电视剧上新后，视频网站会向订阅了该剧的用户发送信息，告诉他们有新剧上线了。 MQTT主题刚刚我们在讲解MQTT客户端订阅信息时，使用了用户在视频网站订阅电视剧这个例子。在MQTT通讯中，客户端所订阅的肯定不是一部部电视剧，而是一个个“主题”。MQTT服务端在管理MQTT信息通讯时，就是使用“主题”来控制的。 MQTT 发布&#x2F;订阅 特性 相互可独立：MQTT客户端是一个个独立的个体。 空间可分离：空间分离相对容易理解，MQTT客户端在通讯必要条件是连接到了同一个MQTT通讯网络。 时间可异步：MQTT客户端在发送和接收信息时无需同步。","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"JQuery基础","slug":"JQuery基础","date":"2022-04-20T01:06:44.000Z","updated":"2022-04-24T02:03:12.162Z","comments":true,"path":"2022/04/20/JQuery基础/","link":"","permalink":"http://example.com/2022/04/20/JQuery%E5%9F%BA%E7%A1%80/","excerpt":"","text":"主要内容 JQuery 基础： 概念 快速入门 JQuery对象和JS对象区别与转换 选择器 DOM操作 案例 JQuery 基础： 概念： 一个JavaScript框架。简化JS开发 jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨 是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优 化HTML文档操作、事件处理、动画设计和Ajax交互。 JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已 快速入门 步骤： 下载JQuery 目前jQuery有三个大版本： 1.x：兼容ie678,使用最为广泛的，官方只做BUG维护， 功能不再新增。因此一般项目来说，使用1.x版本就可以了， 最终版本：1.12.4 (2016年5月20日)2.x：不兼容ie678，很少有人使用，官方只做BUG维护， 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x， 最终版本：2.2.4 (2016年5月20日) ​ 3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，​ 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。​ 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日） jquery-xxx.js 与 jquery-xxx.min.js区别： jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些 jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快 导入JQuery的js文件：导入min.js文件 使用 12var div1 = $(&quot;#div1&quot;);alert(div1.html()); JQuery对象和JS对象区别与转换 JQuery对象在操作时，更加方便。 JQuery对象和js对象方法不通用的. 两者相互转换 jq – &gt; js : jq对象[索引] 或者 jq对象.get(索引) js – &gt; jq : $(js对象) 选择器：筛选具有相似特征的元素(标签) 基本操作学习： 事件绑定 1234//1.获取b1按钮 $(&quot;#b1&quot;).click(function()&#123; alert(&quot;abc&quot;); &#125;); 入口函数 123$(function () &#123; &#125;); window.onload 和 $(function) 区别 window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉 $(function)可以定义多次的。 样式控制：css方法 12// $(&quot;#div1&quot;).css(&quot;background-color&quot;,&quot;red&quot;); $(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 分类 基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 - 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器： 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名&#x3D;’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名&#x3D;’值’][]…”) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选&#x2F;复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 DOM操作 内容操作 1234561:html(): 获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt;2:text(): 获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容3:val()： 获取/设置元素的value属性值 属性操作 通用属性操作 attr(): 获取&#x2F;设置元素的属性 removeAttr():删除属性 prop():获取&#x2F;设置元素的属性 removeProp():删除属性 attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 对class属性操作 addClass():添加class属性值 removeClass():删除class属性值 toggleClass():切换class属性 toggleClass(“one”): 判断如果元素对象上存在class&#x3D;”one”，则将属性值one删除掉。 如果元素对象上不存在class&#x3D;”one”，则添加 css(): CRUD操作: append():父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 prepend():父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo(): 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 prependTo()： 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 after():添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before():添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 remove():移除元素 对象.remove():将对象删除掉 empty():清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 案例 123456案例1//需求：将数据行的奇数行背景色设置为 pink，偶数行背景色设置为 yellow$(function ()&#123; $(&quot;tr:gt(1):odd&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); $(&quot;tr:gt(1):even&quot;).css(&quot;backgroundColor&quot;,&quot;yellow&quot;); &#125;); 123456案例2//全选全不选//分析：需要保证下边的选中状态和第一个复选框的选中状态一致即可function selectAll(obj) &#123; $(&quot;.itemSelect&quot;).prop(&quot;checked&quot;,obj.checked); &#125; 1234567案例3 //需求：点击qq表情，将其追加到发言框中 $(function () &#123; $(&quot;ul img&quot;).click(function () &#123; $(&quot;.word&quot;).append($(this).clone()); &#125;); &#125;) 123456789101112案例4//需求：实现下拉列表选择条目左右选择功能 $(function () &#123; $(&quot;#toRight&quot;).click(function () &#123; $(&quot;#rightName&quot;).append($(&quot;#leftName &gt; option:selected&quot;)); &#125;); $(&quot;#toLeft&quot;).click(function () &#123; $(&quot;#rightName &gt; option:selected&quot;).appendTo($(&quot;#leftName&quot;)); &#125;); &#125;)","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"Filter&Listener","slug":"Filter-Listener","date":"2022-04-19T05:56:06.000Z","updated":"2022-05-07T03:10:14.065Z","comments":true,"path":"2022/04/19/Filter-Listener/","link":"","permalink":"http://example.com/2022/04/19/Filter-Listener/","excerpt":"","text":"主要内容： Filter：过滤器 Listener：监听器 Filter：过滤器 概念： 生活中的过滤器：净水器,空气净化器，土匪、 web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。 过滤器的作用： 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤… 快速入门： 步骤： 定义一个类，实现接口Filter 复写方法 配置拦截路径 web.xml 注解 代码： 1234567891011121314151617181920@WebFilter(&quot;/*&quot;)//访问所有资源之前，都会执行该过滤器 public class FilterDemo1 implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filterDemo1被执行了....&quot;); //放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125; &#125; 过滤器细节： web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 过滤器执行流程 执行过滤器 执行放行后的资源 回来执行过滤器放行代码下边的代码 过滤器生命周期方法 init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter:每一次请求被拦截资源时，会执行。执行多次 destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解 拦截路径配置： 具体资源路径： &#x2F;index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： &#x2F;user&#x2F;* 访问&#x2F;user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：&#x2F;* 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置： 设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 设置&lt;dispatcher&gt;&lt;&#x2F;dispatcher&gt;标签即可 过滤器链(配置多个过滤器) 执行顺序：如果有两个过滤器：过滤器1和过滤器2 过滤器1 过滤器2 资源执行 过滤器2 过滤器1 过滤器先后顺序问题： 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置：&lt;filter-mapping&gt;谁定义在上边，谁先执行 案例： 案例1_登录验证 需求： 访问day17_case案例的资源。验证其是否登录 如果登录了，则直接放行。 如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”。 案例2_敏感词汇过滤 需求： 对day17_case案例录入的数据进行敏感词汇过滤 敏感词汇参考《敏感词汇.txt》 如果是敏感词汇，替换为 *** 分析： 对request对象进行增强。增强获取参数相关方法 放行。传递代理对象 增强对象的功能： 设计模式：一些通用的解决固定问题的方式 装饰模式 代理模式 概念： 真实对象：被代理的对象 代理对象： 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的 实现方式： 静态代理：有一个类文件描述代理模式 动态代理：在内存中形成代理类 实现步骤： 代理对象和真实对象实现相同的接口 代理对象 &#x3D; Proxy.newProxyInstance(); 1. 类加载器：真实对象.getclass().getClassLoder 2. 接口对象:真实对象.getClass().getTnterfaces() 3. 处理器:new InfocationHandler() 使用代理对象调用方法。 4. 增强方法 - 增强方式： 1. 增强参数列表 增强返回值类型 3. 增强方法体执行逻辑 不管调用什么方法，invoke方法都会被执行 ​ 12345678910代理逻辑编写的方法：代理对象调用的所有方法都会触发该方法执行参数： 1. proxy:代理对象 2. method：代理对象调用的方法，被封装为的对象 3. args:代理对象调用的方法时，传递的实际参数 @Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; &#125; 代码 1234567891011121314if(method.getName().equals(&quot;sale&quot;))&#123; //1.增强参数 double money = (double) args[0]; money = money * 0.85; System.out.println(&quot;专车接你....&quot;); //使用真实对象调用该方法 String obj = (String) method.invoke(lenovo, money); System.out.println(&quot;免费送货...&quot;); //2.增强返回值 return obj+&quot;_鼠标垫&quot;; &#125;else&#123; Object obj = method.invoke(lenovo, args); return obj; &#125; Listener：监听器 概念：web的三大组件之一。 事件监听机制 事件 ：一件事情 事件源 ：事件发生的地方 监听器 ：一个对象 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码 ServletContextListener:监听ServletContext对象的创建和销毁 方法： void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法 void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法 步骤： 定义一个类，实现ServletContextListener接口 复写方法 配置 代码 12341. web.xml &lt;listener&gt; &lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 指定初始化参数&lt;context-param&gt; 注解 @WebListener ​ 用途 加载配置文件","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"JSP&&MVC&&EL&&JSTL","slug":"JSP-MVC-EL-JSTL","date":"2022-04-15T08:46:01.000Z","updated":"2022-04-16T15:35:30.283Z","comments":true,"path":"2022/04/15/JSP-MVC-EL-JSTL/","link":"","permalink":"http://example.com/2022/04/15/JSP-MVC-EL-JSTL/","excerpt":"","text":"主要内容 JSP： 指令 注释 内置对象 MVC开发模式 EL表达式 JSTL标签 三层架构 JSP： 指令 作用：用于配置JSP页面，导入资源文件 格式： 1&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; 分类： page ： 配置JSP页面的 contentType：等同于response.setContentType() 设置响应体的mime类型以及字符集 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集） import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前也是是否是错误页面。 true：是，可以使用内置对象exception false：否。默认值。不可以使用内置对象exception include ： 页面包含的。导入页面的资源文件 &lt;%@include file&#x3D;”top.jsp”%&gt; taglib ： 导入资源 &#96;&#96;&#96;&lt;%@ taglib prefix&#x3D;”c” uri&#x3D;”http://java.sun.com/jsp/jstl/core&quot; %&gt;1234567 - prefix：前缀，自定义的 2. 注释: 1. html注释： :只能注释html代码片段 1232. jsp注释：推荐使用 &lt;%– –%&gt;：可以注释所有 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758593. 内置对象 - 在jsp页面中不需要创建，直接使用的对象 - 一共有9个： 变量名 真实类型 作用 - pageContext PageContext 当前页面共享数据，还可以获取其他八个内置对象 - request HttpServletRequest 一次请求访问的多个资源(转发) - session HttpSession 一次会话的多个请求间 - application ServletContext 所有用户间共享数据 - response HttpServletResponse 响应对象 - page Object 当前页面(Servlet)的对象 this - out JspWriter 输出对象，数据输出到页面上 - config ServletConfig Servlet的配置对象 - exception Throwable 异常对象## MVC：开发模式 1. jsp演变历史 1. 早期只有servlet，只能使用response输出标签数据，非常麻烦 2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性2. MVC： 1. M：Model，模型。JavaBean - 完成具体的业务操作，如：查询数据库，封装对象 2. V：View，视图。JSP - 展示数据 3. C：Controller，控制器。Servlet - 获取用户的输入 - 调用模型 - 将数据交给视图进行展示- 优缺点： 1. 优点： 1. 耦合性低，方便维护，可以利于分工协作 2. 重用性高 2. 缺点： 1. 使得项目架构变得复杂，对开发人员要求高## EL表达式1. 概念：Expression Language 表达式语言2. 作用：替换和简化jsp页面中java代码的编写3. 语法：$&#123;表达式&#125;4. 注意： - jsp默认支持el表达式的。如果要忽略el表达式 1. 设置jsp中page指令中：isELIgnored=&quot;true&quot; 忽略当前jsp页面中所有的el表达式 2. ``` \\$&#123;表达式&#125; ：忽略当前这个el表达式 使用： 运算： 运算符： 算数运算符： + - * /(div) %(mod) 1232. ``` 比较运算符： &gt; &lt; &gt;= &lt;= == != &#96;&#96;&#96;逻辑运算符： &amp;&amp;(and) ||(or) !(not) 1234. ``` 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 &#96;&#96;&#96; ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 123- ``` $&#123;not empty str&#125;:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 获取值 el表达式只能从域对象中获取值 语法： $&#123;域名称.键名&#125;：从指定域中获取指定键的值 123456789101112- 域名称： 1. pageScope --&gt; pageContext 2. requestScope --&gt; request 3. sessionScope --&gt; session 4. applicationScope --&gt; application（ServletContext）- 举例：在request域中存储了name=张三- ``` 获取：$&#123;requestScope.name&#125; &#96;&#96;&#96;${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 123453. 获取对象、List集合、Map集合的值 1. ``` 对象：$&#123;域名称.键名.属性名&#125; 本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合： &#96;&#96;&#96;${域名称.键名.key名称}123- ``` $&#123;域名称.键名[&quot;key名称&quot;]&#125; 隐式对象： el表达式中有11个隐式对象 pageContext： 获取jsp其他八个内置对象 &#96;&#96;&#96;${pageContext.request.contextPath}：动态获取虚拟目录123456789101112131415161718192021222324252627## JSTL1. 概念：JavaServer Pages Tag Library JSP标准标签库 - 是由Apache组织提供的开源的免费的jsp标签 &lt;标签&gt;2. 作用：用于简化和替换jsp页面上的java代码 3. 使用步骤： 1. 导入jstl相关jar包 2. 引入标签库：taglib指令： &lt;%@ taglib %&gt; 3. 使用标签4. 常用的JSTL标签 1. if:相当于java代码的if语句 1. 属性： - test 必须属性，接受boolean表达式 - 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 - 一般情况下，test属性值会结合el表达式一起使用 &lt;c:if test&#x3D;”${not empty list}”&gt; 遍历集合123456789101112131415161718192021222324252627282930313233 2. 注意： - c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签2. choose:相当于java代码的switch语句 1. 使用choose标签声明 相当于switch声明 2. 使用when标签做判断 相当于case 3. 使用otherwise标签做其他情况的声明 相当于default3. foreach:相当于java代码的for语句 1. 完成重复操作： - 属性 1. begin: 开始值 2. end：结束值 3. var：临时变量 4. step：步长 5. varstatus:循环状态对家 1. index:容器中元素的素引，从e开始 2. count:循环次数，从1开始 2. 遍历容器 1. ``` List&lt;User&gt; list; for (User user : list)&#123; &#125; 属性 items：容器对象 var：容器中临时变量 varstatus:循环状态对家 index:容器中元素的素引，从e开始 count:循环次数，从1开始 123&lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;1&quot;&gt; $&#123;i&#125;&lt;br&gt;&lt;/c:forEach&gt; 123&lt;c:forEach items=&quot;$&#123;list&#125;&quot; var=&quot;str&quot; varStatus=&quot;s&quot;&gt; $&#123;s.index&#125; $&#123;s.count&#125; $&#123;str&#125; &lt;/c:forEach&gt; 练习： 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中 三层架构：软件设计架构 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互 业务逻辑层：处理业务逻辑的。 数据访问层：操作数据存储文件。 ![截屏2022-04-16 17.49.03](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;JSP-MVC-EL-STL&#x2F;截屏2022-04-16 17.49.03.png) 案例：用户信息列表展示 需求：用户信息的增删改查操作 设计： 技术选型： Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat 数据库设计： 1234567891011create database day17; -- 创建数据库 use day17; -- 使用数据库 create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50) ); 开发： 环境搭建 创建数据库环境 创建项目，导入需要的jar包 编码 测试 部署运维 ![截屏2022-04-16 22.44.42](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;JSP-MVC-EL-STL&#x2F;截屏2022-04-16 22.44.42.png)","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"Cookie&Session","slug":"Cookie-Session","date":"2022-04-13T00:36:58.000Z","updated":"2022-04-14T05:04:11.969Z","comments":true,"path":"2022/04/13/Cookie-Session/","link":"","permalink":"http://example.com/2022/04/13/Cookie-Session/","excerpt":"","text":"主要内容 会话技术 Cookie Session JSP：入门学习 会话技术 会话：一次会话中包含多次请求和响应。 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止 功能：在一次会话的范围内的多次请求间，共享数据 方式： 客户端会话技术：Cookie 服务器端会话技术：Session Cookie： 概念：客户端会话技术，将数据保存到客户端 快速入门： 使用步骤： 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理 基于响应头set-cookie和请求头cookie实现 cookie的细节 一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”&#x2F;“ 不同的tomcat服务器间cookie共享问题？ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 案例：记住上一次访问时间 需求： 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 分析： 可以采用Cookie来完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20 写回Cookie：lastTime&#x3D;2018年6月10日11:50:01 没有：是第一次访问 响应数据：您好，欢迎您首次访问 写回Cookie：lastTime&#x3D;2018年6月10日11:50:01 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@WebServlet(&quot;/cookieTest&quot;) public class CookieTest extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应的消息体的数据格式以及编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //1.获取所有Cookie Cookie[] cookies = request.getCookies(); boolean flag = false;//没有cookie为lastTime //2.遍历cookie数组 if(cookies != null &amp;&amp; cookies.length &gt; 0)&#123; for (Cookie cookie : cookies) &#123; //3.获取cookie的名称 String name = cookie.getName(); //4.判断名称是否是：lastTime if(&quot;lastTime&quot;.equals(name))&#123; //有该Cookie，不是第一次访问 flag = true;//有lastTime的cookie //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); cookie.setValue(str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); //响应数据 //获取Cookie的value，时间 String value = cookie.getValue(); System.out.println(&quot;解码前：&quot;+value); //URL解码： value = URLDecoder.decode(value,&quot;utf-8&quot;); System.out.println(&quot;解码后：&quot;+value); response.getWriter().write(&quot;&lt;h1&gt;欢迎回来，您上次访问时间为:&quot;+value+&quot;&lt;/h1&gt;&quot;); break; &#125; &#125; &#125; if(cookies == null || cookies.length == 0 || flag == false)&#123; //没有，第一次访问 //设置Cookie的value //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); String str_date = sdf.format(date); System.out.println(&quot;编码前：&quot;+str_date); //URL编码 str_date = URLEncoder.encode(str_date,&quot;utf-8&quot;); System.out.println(&quot;编码后：&quot;+str_date); Cookie cookie = new Cookie(&quot;lastTime&quot;,str_date); //设置cookie的存活时间 cookie.setMaxAge(60 * 60 * 24 * 30);//一个月 response.addCookie(cookie); response.getWriter().write(&quot;&lt;h1&gt;您好，欢迎您首次访问&lt;/h1&gt;&quot;); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125; &#125; JSP：入门学习 概念： Java Server Pages： java服务器端页面 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 用于简化书写！！！ 原理 JSP本质上就是一个Servlet JSP的脚本：JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 &lt;%&#x3D; 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 JSP的内置对象： 在jsp页面中不需要获取和创建，可以直接使用的对象 jsp一共有9个内置对象。 今天学习3个： request response out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似 response.getWriter()和out.write()的区别： 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。 response.getWriter()数据输出永远在out.write()之前 案例:改造Cookie案例 Session：主菜 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门： 获取HttpSession对象： HttpSession session &#x3D; request.getSession(); 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 原理 Session的实现是依赖于Cookie的。 细节： 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？ 默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 123Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId());c.setMaxAge(60*60);response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 session的钝化： 在服务器正常关闭之前，将session对象系列化到硬盘上 session的活化： 在服务器启动后，将session文件转化为内存中的session对象即可。 session什么时候被销毁？ 服务器关闭 session对象调用invalidate() 。 session默认失效时间 30分钟 1234选择性配置修改 &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全 案例：验证码 案例需求： 访问带有验证码的登录页面login.jsp 用户输入用户名，密码以及验证码。 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 分析：","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"四级词汇13-20串词","slug":"四级词汇13-20串词","date":"2022-04-12T15:13:05.000Z","updated":"2022-04-22T16:15:35.571Z","comments":true,"path":"2022/04/12/四级词汇13-20串词/","link":"","permalink":"http://example.com/2022/04/12/%E5%9B%9B%E7%BA%A7%E8%AF%8D%E6%B1%8713-20%E4%B8%B2%E8%AF%8D/","excerpt":"","text":"第13串词：cur&#x2F;cor&#x2F;car(关心，照料)curious adj.好奇的 a curious boy 充满好奇心&#x2F;古怪的小男孩 Stay hunger，Stay curious 保持求知，保持好奇 curiosity n.好奇的 out of curiosity 出于好奇 cure v.治好；解决 n.疗法；对策 cure him 治好他 cure this illness 治愈这种疾病 a cure for cancer 癌症治愈方法 a cure for poverty 解决贫穷的措施 accurate adj.正确的 accurate information 无误的信息 core n.果核；核心 adj.核心的；主要的 the earth&#96;s core 地核 the core of the debate 辩论的核心 hardcore n.核心部分，中坚分子 adj.绝对的，无条件的，没有限制的 core values 核心价值观 care n.照料v.关心；关注 care for &#x3D; love care about 关心 careless adj.粗心的 -less：否定 第14串词：sume（to take 拿，to use 用）consumer n.消费者 consume a lot of food 消耗了很多食物 consume energy 消耗能量 consume v.消费；消耗consumption n.消费 food consumption 食物消耗（量） assume v.承担；假设；认为 assume that 假设一下 Let&#96;s assume that….. 我将承担起这个责任（&#x3D;take） assumption n.假设；设想presume v.假定；推测（有一定假设） pre-：before resume n.简历；概述 personal resume 个人简历 resume v.继续；重新开始 resume her career 继续她的职业生涯 The noise resumed 噪声又响了起来 第15串词：valu（价值）value n.价值 v.重视valuable adj.宝贵的valueless adj.不值钱的（&#x3D;worthless） -less&#x3D;否定 evaluate v.评价 e-&#x3D;ex out estimate n.估价（估计） assess v.评定；评估（测评） （formal）评估能力，损失，价值等，以便确定下一步行动。 rate v.评价；评估 n.比率；速度；费用（评级） 仅评定等级的高低 equivalent adj.相等的 equal 相等的 -ent&#x3D;形容词词尾 的 A is equivalent to B A与B相等 A equals B 第16串词：cre（to grow 生长）create v.创造；创造；造成（从无到有） create wealth&#x2F;more jobs 创作财富&#x2F;更多就业 creativity adj.创造性的；有创造力的creativity n.创造力creator n.创造者creation n.创造；产物 value creation 价值创造 creature n.生物；动物（虚拟的或现实的） strange creature from outer space 外星怪物 第17串词：text&#x2F;test（编织&#x2F;证据，验证）text n.课本；文本 v.发短信context n.背景；上下文 social context 社会背景 textbook n.课本texture 质地，纹理textile 纺织品，织物test n.试验；测试 v.试验；测试contest v.争辩；质疑 v.竞赛；争论protest v.抗议 n.抗议 a peaceful protest 一场和平抗议 第18串词：quality&#x2F;quantity（质量&#x2F;数量）quality n.质量；品质 adj.优质的 quanlity life 优质生活 qualify v.使有资格；（使）合格qualified adj.有资格的 be qualified for sth&#x2F;to do sth 有资格做某事 qualification n.资格quantity n.数量 quantity makes quality 量变引起质变 quantum 量子第19串词：sens&#x2F;sent（感觉）sense n.感觉 v.感觉到；检测 sense of smell 嗅觉 sense of duty 责任感 make sense 有道理；有意义 sensitive adj.敏感的；体贴的（容易感知）sensible adj.明智的；理智的（正确感知）sensor n.传感器nonsense n.胡说；废话；愚蠢的行为；无聊的事物第20串词：fect&#x2F;fact（do，make 做）factory 场所 -ory 场所 dffect n.效果 v.产生 ef- &#x3D; ex- ：out 向外 effective adj.有效果的efficient adj.有效率的efficiency n.效率；效能sufficient adj.足够的（enough） suf- &#x3D; under 下面 fic &#x3D; fect feasible adj.可行的；可实行的 fea- &#x3D; fact ：做 a feasible plan&#x2F;solution 可行的计划&#x2F;解决方案 affect v.影响；感染 af-：强调 perfect adj.完美的 v.使完美 per- &#x3D; through，completely 贯穿。彻底 factor n.因素manufacture n.大量制造 v.大量生产 manu- &#x3D; 手 manufacturer n.制造商facility n.设施facilitate v.促进；使便利（&#x3D;help with 有助于）faculty n.科，系；能力；全体教员figure n.数字；身材；图，表 v.计算；弄懂sacrifice n.牺牲；祭品 v.牺牲;献祭 sacr- &#x3D;sacred 圣神的","categories":[],"tags":[{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"}]},{"title":"Response","slug":"Response","date":"2022-04-11T06:28:08.000Z","updated":"2022-04-12T15:11:14.317Z","comments":true,"path":"2022/04/11/Response/","link":"","permalink":"http://example.com/2022/04/11/Response/","excerpt":"","text":"主要内容 HTTP协议：响应消息 Response对象 ServletContext对象 HTTP协议： 请求消息：客户端发送给服务器端的数据 数据格式： 请求行 请求头 请求空行 请求体 响应消息：服务器端发送给客户端的数据 数据格式： 响应行 组成：协议&#x2F;版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 状态码都是3位数字 分类： 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。 代表： 404（请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头： 格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 值： in-line:默认值,在当前页面内打开 attachment;filename&#x3D;xxx：以附件形式打开响应体。文件下载 响应空行 响应体:传输的数据 1234567891011121314* 响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; Response对象 功能：设置响应消息 设置响应行 格式：HTTP&#x2F;1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name, String value) 设置响应体： 使用步骤： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 案例1:重定向_代码 完成重定向 重定向：资源跳转的方式 代码实现： 1234567//1. 设置状态码为302response.setStatus(302);//2.设置响应头locationresponse.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;); //简单的重定向方法response.sendRedirect(&quot;/day15/responseDemo2&quot;); 重定向的特点:redirect 地址栏发生变化 重定向可以访问其他站点(服务器)的资源 重定向是两次请求。不能使用request对象来共享数据 转发的特点：forward 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 forward 和 redirect 区别 路径写法： 路径分类 相对路径：通过相对路径不可以确定唯一资源 如：.&#x2F;index.html 不以&#x2F;开头，以.开头路径 规则：找到当前资源和目标资源之间的相对位置关系 .&#x2F;：当前目录 ..&#x2F;:后退一级目录 绝对路径：通过绝对路径可以确定唯一资源 如：http://localhost/day15/responseDemo2 ​ &#x2F;day15&#x2F;responseDemo2 以&#x2F;开头的路径 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出 给客户端浏览器使用：需要加虚拟目录(项目的访问路径) 建议虚拟目录动态获取： request.getContextPath() &#96;&#96;&#96; , 重定向… 1234567891011 - 给服务器使用：不需要加虚拟目录 - 转发路径2. 服务器输出字符数据到浏览器 - 步骤： 1. 获取字符输出流 PrintWriter pw &#x3D; respone.getWriter(); 1232. 输出数据 pw.write(“hello response“) 1234567891011 - 注意： - 乱码问题： 1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1 2. 设置该流的默认编码 3. 告诉浏览器响应体使用的编码 &#x2F;&#x2F;简单的形式，设置编码，是在获取流之前设置 response.setContentType(“text&#x2F;html;charset&#x3D;utf-8”); 12345673. 服务器输出字节数据到浏览器 - 步骤： 1. 获取字节输出流 ServletOutputStream sos &#x3D; response.getOutputStream(); 1232. 输出数据 sos.write(“hello”.getBytes()); 123456789101112131415164. 验证码 1. 本质：图片 2. 目的：防止恶意表单注册## ServletContext对象：1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信2. 获取： 1. 通过request对象获取 request.getServletContext(); 1232. 通过HttpServlet获取 this.getServletContext(); 1234567891011121314151617181920213. 功能： 1. 获取MIME类型： - MIME类型:在互联网通信过程中定义的一种文件数据类型 - 格式： 大类型/小类型 text/html image/jpeg - 获取：String getMimeType(String file) 2. 域对象：共享数据 1. setAttribute(String name,Object value) 2. getAttribute(String name) 3. removeAttribute(String name) ServletContext对象范围：所有用户所有请求的数据 3. 获取文件的真实(服务器)路径 1. 方法：String getRealPath(String path) String b &#x3D; context.getRealPath(“&#x2F;b.txt”); &#x2F;&#x2F;web目录下资源访问 System.out.println(b); String c &#x3D; context.getRealPath(“&#x2F;WEBINF&#x2F;c.txt”); &#x2F;&#x2F;WEB-INF目录下的资源访问 System.out.println(c); String a &#x3D; context.getRealPath(“&#x2F;WEBINF&#x2F;classes&#x2F;a.txt”);&#x2F;&#x2F;src目录下的资源访问System.out.println(a); 123456789101112131415161718192021222324252627## 案例- 文件下载需求： 1. 页面显示超链接 2. 点击超链接后弹出下载提示框 3. 完成图片文件下载- 分析： 1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求 2. 任何资源都必须弹出下载提示框 3. 使用响应头设置资源的打开方式： - content-disposition:attachment;filename=xxx- 步骤： 1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename 2. 定义Servlet 1. 获取文件名称 2. 使用字节输入流加载文件进内存 3. 指定response的响应头： content-disposition:attachment;filename=xxx 4. 将数据写出到response输出流- 问题： - 中文文件问题 - 解决思路： 1. 获取客户端使用的浏览器版本信息 2. 根据不同的版本信息，设置filename的编码方式不同案例代码 @WebServlet(“&#x2F;downloadServlet”)public class DownloadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { &#x2F;&#x2F;1.获取请求参数，文件名称 String filename &#x3D; request.getParameter(“filename”); &#x2F;&#x2F;2.使用字节输入流加载文件进内存 &#x2F;&#x2F;2.1找到文件服务器路径 ServletContext servletContext &#x3D; this.getServletContext(); String realPath &#x3D; servletContext.getRealPath(“&#x2F;img&#x2F;“ + filename); &#x2F;&#x2F;2.2用字节流关联 FileInputStream fis &#x3D; new FileInputStream(realPath); //3.设置response的响应头 //3.1设置响应头类型：content-type String mimeType = servletContext.getMimeType(filename);//获取文件的mime类型 response.setHeader(&quot;content-type&quot;,mimeType); //3.2设置响应头打开方式:content-disposition //解决中文文件名问题 //1.获取user-agent请求头、 String agent = request.getHeader(&quot;user-agent&quot;); //2.使用工具类方法编码文件名即可 filename = DownLoadUtils.getFileName(agent, filename); response.setHeader(&quot;content-disposition&quot;,&quot;attachment;filename=&quot;+filename); //4.将输入流的数据写出到输出流中 ServletOutputStream sos = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while((len = fis.read(buff)) != -1)&#123; sos.write(buff,0,len); &#125; fis.close(); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125; }","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"LeetCode题","slug":"LeetCode题","date":"2022-04-10T15:21:43.000Z","updated":"2022-04-10T15:33:21.809Z","comments":true,"path":"2022/04/10/LeetCode题/","link":"","permalink":"http://example.com/2022/04/10/LeetCode%E9%A2%98/","excerpt":"","text":"9.回文数题目：给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 示例1:12输入：x = 121输出：true 示例2:123输入：x = -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3:123输入：x = 10输出：false解释：从右向左读, 为 01 。因此它不是一个回文数。 提示： -2^31 &lt;= x &lt;= 2^31 - 1","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"Servleat&HTTP&Request","slug":"Servleat-HTTP-Request","date":"2022-04-09T05:32:51.000Z","updated":"2022-04-12T15:10:46.575Z","comments":true,"path":"2022/04/09/Servleat-HTTP-Request/","link":"","permalink":"http://example.com/2022/04/09/Servleat-HTTP-Request/","excerpt":"","text":"Servlet： 概念 步骤 执行原理 生命周期 Servlet3.0 注解配置 Servlet的体系结构 12345Servlet -- 接口 |GenericServlet -- 抽象类 |HttpServlet -- 抽象类 GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 HttpServlet：对http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet&#x2F;doPost方法 Servlet相关配置 urlpartten:Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“&#x2F;d4”,”&#x2F;dd4”,”&#x2F;ddd4”}) 路径定义规则： &#x2F;xxx：路径匹配 &#x2F;xxx&#x2F;xxx:多层路径，目录结构 *.do：扩展名匹配 HTTP： 概念：Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 特点： 基于TCP&#x2F;IP的高级协议 默认端口号:80 基于请求&#x2F;响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0：每一次请求响应都会建立新的连接 1.1：复用连接 请求消息数据格式 请求行 12请求方式 请求url 请求协议/版本GET /login.html HTTP/1.1 请求方式： HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 ​ 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？ 作用： 防盗链： 统计工作： 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)： 封装POST请求消息的请求参数的 字符串格式： 1234567891011POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 响应消息数据格式 Request： request对象和response对象的原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 request对象继承体系结构： 12345ServletRequest -- 接口 | 继承HttpServletRequest -- 接口 | 实现org.apache.catalina.connector.RequestFacade 类(tomcat) request功能： 获取请求消息数据 获取请求行数据 GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1 方法： 获取请求方式 ：GET String getMethod() (*)获取虚拟目录：&#x2F;day14 String getContextPath() 获取Servlet路径: &#x2F;demo1 String getServletPath() 获取get方式请求参数：name&#x3D;zhangsan String getQueryString() (*)获取请求URI：&#x2F;day14&#x2F;demo1 String getRequestURI(): &#x2F;day14&#x2F;demo1 StringBuffer getRequestURL() :http://localhost/day14/demo1 URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 URI：统一资源标识符 : &#x2F;day14&#x2F;demo1 共和国 获取协议及版本：HTTP&#x2F;1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr() 获取请求头数据 方法： (*)String getHeader(String name):通过请求头的名称获取请求头的值 &#96;&#96;&#96;Enumeration getHeaderNames():获取所有的请求头名称 123456789101112131415161718192021 3. 获取请求体数据: - 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 - 步骤： 1. 获取流对象 - BufferedReader getReader()：获取字符输入流，只能操作字符数据 - ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 - 在文件上传知识点后讲解 2. 再从流对象中拿数据2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方 取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. ``` Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数 名称 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题： get方式：tomcat 8 已经将get方式乱码问题解决了 post方式：会乱码 解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”); 请求转发：一种在服务器内部的资源跳转方式 步骤： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中。 转发是一次请求 共享数据： 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj):存储数据 Object getAttitude(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContext： ServletContext getServletContext() 案例：用户登录 用户登录案例需求： 编写login.html登录页面 username &amp; password 两个输入框 使用Druid数据库连接池技术,操作mysql，day14数据库中user表 使用JdbcTemplate技术封装JDBC 登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 分析 开发步骤 创建项目，导入html页面，配置文件，jar包 创建数据库环境 12345678CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 创建包cn.itcast.domain,创建类User 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast.domain; /** * 用户的实体类 */ public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; 创建包cn.itcast.util,编写工具类JDBCUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils &#123; private static DataSource ds ; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; &#125; 创建包cn.itcast.dao,创建类UserDao,提供login方法 123456789101112131415161718192021222324252627282930313233343536package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao &#123; //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser)&#123; try &#123; //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; &#125; catch (DataAccessException e) &#123; e.printStackTrace();//记录日志 return null; &#125; &#125; &#125; 编写cn.itcast.web.servlet.LoginServlet类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null)&#123; //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); &#125;else&#123; //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125; &#125; 编写FailServlet和SuccessServlet类 12345678910111213141516171819202122232425262728293031@WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null)&#123; //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); &#125; &#125; @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125; &#125; login.html中form表单的action路径的写法 虚拟目录+Servlet的资源路径 BeanUtils工具类，简化数据封装 用于封装JavaBean的 JavaBean：标准的Java类 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username 方法： setProperty() getProperty() populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"Tomcat&Servlet","slug":"Tomcat-Servlet","date":"2022-04-08T01:11:56.000Z","updated":"2022-04-08T15:30:57.605Z","comments":true,"path":"2022/04/08/Tomcat-Servlet/","link":"","permalink":"http://example.com/2022/04/08/Tomcat-Servlet/","excerpt":"","text":"web相关概念回顾 软件架构 C&#x2F;S：客户端&#x2F;服务器端 B&#x2F;S：浏览器&#x2F;服务器端 资源分类 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 如： html,css,JavaScript 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 如：servlet&#x2F;jsp,php,asp…. 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65536 传输协议：规定了数据传输的规则 基础协议： tcp:安全协议，三次握手。 速度稍慢 udp：不安全协议。 速度快 web服务器软件： 服务器：安装了服务器软件的计算机 服务器软件：接收用户的请求，处理请求，做出响应 web服务器软件：接收用户的请求，处理请求，做出响应。 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 web容器 常见的java相关的web服务器软件： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet&#x2F;jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat：web服务器软件 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格 卸载：删除目录就行了 启动： bin&#x2F;startup.bat ,双击运行该文件即可 访问：浏览器输入：http://localhost:8080 回车访问自己 http:&#x2F;&#x2F;别人的ip:8080 访问别人 可能遇到的问题： 黑窗口一闪而过： 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错： 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 netstat -ano 温柔：修改自身的端口号 conf&#x2F;server.xml 123&lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 关闭： 正常关闭： bin&#x2F;shutdown.bat ctrl+c 强制关闭： 点击启动窗口的× 配置: 部署项目的方式： 直接将项目放到webapps目录下即可。 &#x2F;hello：项目的访问路径–&gt;虚拟目录 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩 配置conf&#x2F;server.xml文件 12在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\\hello&quot; path=&quot;/hehe&quot; /&gt; docBase:项目存放的路径 path：虚拟目录 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 1&lt;Context docBase=&quot;D:\\hello&quot; /&gt; 虚拟目录：xml文件的名称 静态项目和动态项目： 目录结构 java动态项目的目录结构： 12345-- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 将来我们自定义一个类，实现Servlet接口，复写方法。 快速入门： 创建JavaEE项目 定义一个类，实现Servlet接口 public class ServletDemo1 implements Servlet 实现接口中的抽象方法 配置Servlet 1234567891011在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理： 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 1233. ``` 如果有，则在找到对应的&lt;servlet-class&gt;全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet中的生命周期方法： 被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 &#96;&#96;&#96;在标签下配置123451. 第一次被访问时，创建 - ``` &lt;load-on-startup&gt;的值为负数 在服务器启动时，创建 &#96;&#96;&#96;的值为0或正整数1234567891011121314151617181920212223242526272829303132 - Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 - 多个用户同时访问时，可能存在线程安全问题。 - 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 - 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 - Servlet被销毁时执行。服务器关闭时，Servlet被销毁 - 只有服务器正常关闭时，才会执行destroy方法。 - destroy方法在Servlet被销毁之前执行，一般用于释放资源- Servlet3.0： - 好处： - 支持注解配置。可以不需要web.xml了。 - 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用@WebServlet注解，进行配置 @WebServlet(“资源路径”) @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default “”;&#x2F;&#x2F;相当于 String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String description() default &quot;&quot;; String displayName() default &quot;&quot;; &#125; &#96;&#96;&#96; IDEA与tomcat的相关配置 IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台的log：Using CATALINA_BASE: “C:\\Users\\fqy.IntelliJIdea2018.1\\system\\tomcat_itcast” 工作空间项目 和 tomcat部署的web项目 tomcat真正访问的是“tomcat部署的web项目”，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问。 断点调试：使用”小虫子”启动 dubug 启动","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"xml","slug":"xml","date":"2022-04-07T00:52:36.000Z","updated":"2022-04-07T15:36:56.924Z","comments":true,"path":"2022/04/07/xml/","link":"","permalink":"http://example.com/2022/04/07/xml/","excerpt":"","text":"XML: 概念：Extensible Markup Language 可扩展标记语言 可扩展：标签都是自定义的。 1&lt;user&gt; &lt;student&gt; 功能 存储数据 配置文件 在网络中传输 xml与html的区别 xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 w3c:万维网联盟 语法： 基本语法： xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 123456789101112131415&lt;?xml version=&#x27;1.0&#x27; ?&gt; &lt;users&gt; &lt;user id=&#x27;1&#x27;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id=&#x27;2&#x27;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分： 文档声明 格式： 1&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 指令(了解)：结合css的 &#96;&#96;&#96; 12345678910111213141516171819- 标签：标签名称自定义的 - 规则： - 名称可以包含字母、数字以及其他的字符 - 名称不能以数字或者标点符号开始 - 名称不能以字母 xml（或者 XML、Xml 等等）开始 - 名称不能包含空格 - 属性： - id属性值唯一- 文本： - CDATA区：在该区域中的数据会被原样展示 - ``` 格式： &lt;![CDATA[ 数据 ]]&gt; 约束：规定xml文档的书写规则 作为框架的使用者(程序员)： 能够在xml中引入约束文档 能够简单的读懂约束文档 分类： DTD:一种简单的约束技术 Schema:一种复杂的约束技术 DTD: 引入dtd文档到xml文档中 内部dtd：将约束规则定义在xml文档中 外部dtd：将约束的规则定义在外部的dtd文件中 &#96;&#96;&#96;本地：123- ``` 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; Schema: 引入： 填写xml文档的根元素 引入xsi前缀. 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间. 1xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 为每一个xsd约束声明一个前缀,作为标识 1xmlns=&quot;http://www.itcast.cn/xml&quot; 123&lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; 解析：操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式： DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见的解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 快速入门： 步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 代码 12345678910111213//2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.获取元素对象 Element Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); 对象的使用： Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse(File in, String charsetName)：解析xml或html文件的。 parse(String html)：解析xml或html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树 获取Element对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。 1可以当做 ArrayList&lt;Element&gt;来使用 Element：元素对象 获取子元素对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式： selector:选择器 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 代码 12345678910111213141516171819202122232425262728293031323334353637//1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.获取Document对象 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); &#125;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"BootStrap","slug":"BootStrap","date":"2022-04-06T07:38:24.000Z","updated":"2022-04-06T14:44:10.231Z","comments":true,"path":"2022/04/06/BootStrap/","link":"","permalink":"http://example.com/2022/04/06/BootStrap/","excerpt":"","text":"Bootstrap： 概念：一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 好处： 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 响应式布局。 同一套页面可以兼容不同分辨率的设备。 快速入门 下载Bootstrap 在项目中将这三个文件夹复制 创建html页面，引入必要的资源文件 1dayd 响应式布局 同一套页面可以兼容不同分辨率的设备。 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子 步骤： 定义容器。相当于之前的table、 容器分类： container：两边留白 container-fluid：每一种设备都是100%宽度 定义行。相当于之前的tr 样式：row 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目 设备代号： xs：超小屏幕 手机 (&lt;768px)：col-xs-12 sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 注意： 一行中如果格子数目超过12，则超出部分自动换行。 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 CSS样式和JS插件文档：https://v3.bootcss.com/css/#forms 全局CSS样式： 按钮：class&#x3D;”btn btn-default” 图片： class&#x3D;”img-responsive”：图片在任意尺寸都占100% 图片形状 1&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形 1&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形 1&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框 表格 table table-bordered table-hover 表单 给表单项添加：class&#x3D;”form-control” 组件： 导航条 分页条 插件： 轮播图 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .paddtop&#123; padding-top: 10px; &#125; .search-btn&#123; float: left; border:1px solid #ffc900; width: 90px; height: 35px; background-color:#ffc900 ; text-align: center; line-height: 35px; margin-top: 15px; &#125; .search-input&#123; float: left; border:2px solid #ffc900; width: 400px; height: 35px; padding-left: 5px; margin-top: 15px; &#125; .jx&#123; border-bottom: 2px solid #ffc900; padding: 5px; &#125; .company&#123; height: 40px; background-color: #ffc900; text-align: center; line-height:40px ; font-size: 8px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1.页眉部分--&gt; &lt;header class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img src=&quot;img/top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;img src=&quot;img/logo.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-md-5&quot;&gt; &lt;input class=&quot;search-input&quot; placeholder=&quot;请输入线路名称&quot;&gt; &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;img src=&quot;img/hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--导航栏--&gt; &lt;div class=&quot;row&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;!-- 定义汉堡按钮 --&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;!--轮播图--&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;!-- 2.主体部分--&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row jx&quot;&gt; &lt;img src=&quot;img/icon_5.jpg&quot;&gt; &lt;span&gt;黑马精选&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row jx&quot;&gt; &lt;img src=&quot;img/icon_6.jpg&quot;&gt; &lt;span&gt;国内游&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;img src=&quot;img/guonei_1.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3.页脚部分--&gt; &lt;footer class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img src=&quot;img/footer_service.png&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row company&quot;&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882 &lt;/div&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"四级词汇7-12串词","slug":"四级词汇7-12串词","date":"2022-04-05T03:30:39.000Z","updated":"2022-04-10T09:44:21.284Z","comments":true,"path":"2022/04/05/四级词汇7-12串词/","link":"","permalink":"http://example.com/2022/04/05/%E5%9B%9B%E7%BA%A7%E8%AF%8D%E6%B1%877-12%E4%B8%B2%E8%AF%8D/","excerpt":"","text":"第7串词：-ageage n.年龄；时代 v.变老 Stan Age 石器时代 People age 人是会衰老的 aging n.老化；老龄化 aging process 衰老过程 average adj.平均的；普通的 n.平均；平均数manage v.管理；勉强完成 man- &#x3D; hand(手) management n.管理advantage n.优势；利益 advance- &#x3D; 前进的 take advantage of sth&#x2F;sb 占便宜&#x2F;充分利用 disadvantage n.缺点；不利条件damage n.损害 v.损毁message n.消息 v.发消息 mess-&#x2F;miss- &#x3D; to send (送), to throw (投) text me 编短信 marriage n.婚姻wage n.工资（周薪） wage：（按周发钱） salary：（按月发钱） income：（收入，所得） image n.影像；想像 v.想象；反映；象征 public image 公众形象 package n.包裹 v.打包luggage n.行李（英）baggage n.行李（美）shortage n.缺乏；不足stage n.舞台；阶段第8串词：techn （art&#x2F;skill 技艺&#x2F;技术）technology n.科技；技术 -ology 名词结尾 technological adj.科技的；工艺的；技术的 -cal 形容词词尾 technique n.技巧；技术technical adj.技能的；专门技术的technician n.技术员第9串词：fer(to carry 拿来，to bring 带来)offer v.提供 n.工作邀请 of-：朝向 refer v.查阅；参考；提及 refer to A as B：把A称作B reference n.参考differ v.不同于（&#x3D; be different） di-：away 分开 indifferent adj.漠不关心 an indifferent society 一个冷漠的社会 in-：not 不 prefer v.较喜欢 pre- ：before 先 preschool adj.学龄前的 prehistory n.史前时代 preference n.偏爱；偏好suffer v.受苦；遭受… sub-（suc-,suf-,sug-,sum-,sup-,sur-,sus-）&#x3D; under 在下面 conference n.会议 con-：共同，一起 -ence：名词结尾 meeting 碰头会 infer v.推断 in-：向内，里面 interfere v.干涉 inter-：between&#x2F;among 在…之间 interfere in 某人进入情况内部“插手” interfere with 人或物“影响” interference n.干涉transfer v.转学，调用；转移 trans-：across 转移，贯穿 从A到B 读音不同词性不同 名前动后 n.转移；换乘 transfer station 换乘站 第10串词：lead（引导，领导） leader n.领导者 lead v.领导；导致；n.领先地位 lead to 引发 took&#x2F;lost the lead 领先&#x2F;落后 leading adj.最重要的；领先的（&#x3D;top） leadership adj.最重要的；领先的 mislead v.误导 mis-：错误的，不好的 misleading adj.误导的 第11串词： economy n.经济；节约 a market economy 市场经济 economic adj.经济上的；经济学的 economical adj.省钱的 economics n.经济学 economist n.经济学者 economically adv.经济上地 support sb economically 经济上支持某人 第12串词： 所以词都可以加economic crisis n.危机 an economic crisis 一次经济危机 decline n.下降；衰退 v.下降；衰退；婉拒 a rapid decline 迅速下降 refuse&#x2F;decline his help 断然拒绝&#x2F;谢绝他的帮助 recession n.经济衰退 re- ：回，向后 -cess ：行走 depression n.抑郁；萧条期 de-：向下 press-：压，压制 fall v.落下；减少 n.衰退；瀑布；秋天 downturn n.(商业经济)的衰退","categories":[],"tags":[{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"}]},{"title":"Javascript高级","slug":"Javascript高级","date":"2022-04-04T10:22:35.000Z","updated":"2022-04-06T02:44:07.863Z","comments":true,"path":"2022/04/04/Javascript高级/","link":"","permalink":"http://example.com/2022/04/04/Javascript%E9%AB%98%E7%BA%A7/","excerpt":"","text":"DOM简单学习：为了满足案例要求 功能：控制html文档的内容 获取页面标签(元素)对象：Element document.getElementById(“id值”):通过元素的id获取元素对象 操作Element对象： 修改属性值： 明确获取的对象是哪一个？ 查看API文档，找其中有哪些属性可以设置 修改标签体内容： 属性：innerHTML 获取元素对象 使用innerHTML属性修改标签体内容 事件简单学习 功能：某些组件被执行了某些操作后，触发某些代码的执行。 造句：xxx被xxx,我就xxx 我方水晶被摧毁后，我就责备对友。 敌方水晶被摧毁后，我就夸奖自己。 如何绑定事件 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 事件：onclick— 单击事件 通过js获取元素对象，指定事件属性，设置一个函数 代码1234567891011121314151617181920&lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot; onclick=&quot;fun();&quot;&gt; &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt; &lt;script&gt; function fun()&#123; alert(&#x27;我被点了&#x27;); alert(&#x27;我又被点了&#x27;); &#125; function fun2()&#123; alert(&#x27;咋老点我？&#x27;); &#125; //1.获取light2对象 var light2 = document.getElementById(&quot;light2&quot;); //2.绑定事件 light2.onclick = fun2; &lt;/script&gt; &lt;/body&gt; 案例1:电灯开关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(&quot;light&quot;); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function()&#123; if(flag)&#123;//判断如果灯是开的，则灭掉 light.src = &quot;img/off.gif&quot;; flag = false; &#125;else&#123; //如果灯是灭的，则打开 light.src = &quot;img/on.gif&quot;; flag = true; &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; BOM: 概念：Browser Object Model 浏览器对象模型 将浏览器的各个组成部分封装成对象。 组成： Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Window：窗口对象 创建 不需要创建 方法 与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法： close() 关闭浏览器窗口。 谁调用我 ，我关谁 open() 打开一个新的浏览器窗口 返回新的Window对象 与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 属性： 获取其他BOM对象： history location Navigator Screen: 获取DOM对象 document 特点 Window对象不需要创建可以直接使用 window使用。 window.方法名(); window引用可以省略。 方法名(); Location：地址栏对象 创建(获取)： window.location location 方法： reload() 重新加载当前文档。刷新 属性 href 设置或返回完整的 URL。 History：历史记录对象 创建(获取)： window.history history 方法： back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go(参数) 加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性： length 返回当前窗口历史列表中的 URL 数量。 DOM： 概念： Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment:注释对象 Node：节点对象，其他5个的父对象 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 核心DOM模型： Document：文档对象 创建(获取)：在html dom模型中可以使用window对象来获取 window.document document 方法： 获取Element对象： getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 属性 Element：元素对象 获取&#x2F;创建：通过document来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象，其他5个的父对象 特点：所有dom对象都可以被认为是一个节点 方法： CRUD dom树： appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild() ：删除（并返回）当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 属性： parentNode 返回节点的父节点。 HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 123456如： //修改样式方式1 div1.style.border = &quot;1px solid red&quot;; div1.style.width = &quot;200px&quot;; //font-size--&gt; fontSize div1.style.fontSize = &quot;20px&quot;; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 事件监听机制： 概念：某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件： 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件 onblur：失去焦点 一般用于表单校验 onfocus:元素获得焦点。 加载事件： onload：一张页面或一幅图像完成加载。 鼠标事件： onmousedown 鼠标按钮被按下。 定义方法时，定义一个形参，接受event对象 event对象的button属性可以获取鼠标那个键被点击了 onmouseup 鼠标按键被松开。 onmousemove 鼠标被移动。 onmouseover 鼠标移到某元素之上。 onmouseout 鼠标从某元素移开。 键盘事件： onkeydown 某个键盘按键被按下。 onkeyup 某个键盘按键被松开。 onkeypress 某个键盘按键被按下并松开。 选择和改变 onchange 域的内容被改变。 onselect 文本被选中。 表单事件： onsubmit 确认按钮被点击。 可以阻止表单的提交 方法返回false onreset 重置按钮被点击。","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"2012年c B组省赛真题","slug":"2012年c-B组省赛真题","date":"2022-04-04T03:12:11.000Z","updated":"2022-04-04T10:20:09.831Z","comments":true,"path":"2022/04/04/2012年c-B组省赛真题/","link":"","permalink":"http://example.com/2022/04/04/2012%E5%B9%B4c-B%E7%BB%84%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98/","excerpt":"","text":"第一题：微生物增殖题目描述假设有两种微生物X和Y，X出生后每隔3分钟分裂一次（数目加倍），Y出生后每隔2分钟分裂一次（数目加倍）。一个新出生的X，半分钟之后吃掉1个Y，且从此开始每隔1分钟吃掉1个Y。已知新出生的X&#x3D;10，Y&#x3D;89，求60分钟后Y的数目。若X&#x3D;10，Y&#x3D;90呢？本题的要求就是写出这两种初始条件下，60分钟后Y的数目。题目的结果令你震惊吗？这不是简单的数字游戏！真实的生物圈有着同样脆弱的性质！也许因为你消灭的那只Y就是最终导致Y种群灭绝的最后一根稻草！ 题目分析通过画表格得知 时间 0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 X 10 10(吃Y) 10 10(吃Y) 10 10(吃Y) 20(分裂) 20(新生的和以前的X都吃Y) 20 20（吃Y） 从上面表格可以分析出不论是新出生的还是以前的X,都是每半分钟进行吃Y的操作，每3分钟进行一次分裂，故这题的操作如下在60分钟内进行判断： 1.如果为每个0.5分钟 Y&#x3D;Y-X2.如果为每个3分钟 X*&#x3D;23.如果为每个2分钟 Y*&#x3D;2 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; long long x = 10; long long y = 89; for(int i = 1;i &lt;= 120 ;i++)&#123; if( i % 2 == 1)&#123; y = y - x; &#125; if( i % 4 == 0)&#123; y = y * 2; &#125; if( i % 6 == 0)&#123; x = x * 2; &#125; &#125; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt; endl; return 0;&#125; 结果 12x = 10485760y = -979369984//表示微生物Y为0,灭绝 第二题：古堡算式题目描述福尔摩斯到某古堡探险，看到门上写着一个奇怪的算式：ABCDE*?&#x3D;EDCBA。他对华生说：“ABCDE应该代表不同的数字，问号也代表某个数字！” 华生：“我猜也是！”，于是，两人沉默了好久，还是没有算出合适的结果来。 请你利用计算机的优势，找到破解的答案，把ABCDE所代表的数字写出来。 题目分析使用numArray数组的前6个数分别表示ABCDE和？,最后判断条件即可。暴力杯的由来，暴力枚举所有可能，这里用的可能跟其他不一样，使用next_permutation()函数 函数参考文献：函数用法 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; int arraynumber[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; while(next_permutation(arraynumber,arraynumber+10))&#123; if(arraynumber[0] != 0&amp;&amp; arraynumber[4] != 0)&#123; int leftnum = arraynumber[0]*10000 + arraynumber[1]*1000 + arraynumber[2]*100 + arraynumber[3]*10 + arraynumber[4]; int rightnum = arraynumber[4]*10000 + arraynumber[3]*1000 + arraynumber[2]*100 + arraynumber[1]*10 + arraynumber[0]; int temp = arraynumber[5]; if(leftnum * temp == rightnum)&#123; cout &lt;&lt; arraynumber[0] &lt;&lt; arraynumber[1] &lt;&lt; arraynumber[2] &lt;&lt; arraynumber[3] &lt;&lt; arraynumber[4] &lt;&lt; endl &lt;&lt; &quot;?=&quot; &lt;&lt; arraynumber[5]; break; &#125; &#125; &#125; return 0;&#125; 结果 1221978?=4% 第三题：比酒量题目描述有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复—-直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“…昨天，我正好喝了一瓶…奉劝大家，开船不喝酒，喝酒别开船…”请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。如果有多个可能的答案，请列出所有答案，每个答案占一行。格式是：人数，人数，…例如，有一种可能是：20,5,4,2,0 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int i,j,k,l,m; //i为总人数 for(i=20;i&gt;0;i--)&#123; //j为第一次剩余的人，第一次至少倒下一人 for(j=i-1;j&gt;0;j--)&#123; //k为第二次剩余的人，第二次至少又倒下一人，...... for(k=j-1;k&gt;0;k--)&#123; for(m=k-1;m&gt;0;m--)&#123; if((1.0/i + 1.0/j + 1.0/k + 1.0/m) == 1) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot;&lt;&lt;&quot;0&quot; &lt;&lt; endl; &#125; &#125; &#125; &#125; return 0;&#125; 结果 123420 5 4 2 018 9 3 2 015 10 3 2 012 6 4 2 0","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2022-04-02T09:42:26.000Z","updated":"2022-04-04T03:06:45.946Z","comments":true,"path":"2022/04/02/JavaScript/","link":"","permalink":"http://example.com/2022/04/02/JavaScript/","excerpt":"","text":"JavaScript： 概念：一门客户端脚本语言 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 JavaScript发展史： 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C– ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 JavaScript &#x3D; ECMAScript + JavaScript自己特有的东西(BOM+DOM) ECMAScript：客户端脚本语言的标准 基本语法： 与html结合方式 内部JS： 1定义&lt;script&gt;，标签体内容就是js代码 外部JS： 1定义&lt;script&gt;，通过src属性引入外部的js文件 注意 121. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。2. &lt;script&gt;可以定义多个。 注释 121. 单行注释：//注释内容2. 多行注释：/*注释内容*/ 数据类型： 原始数据类型(基本数据类型)： number：数字。 整数&#x2F;小数&#x2F;NaN(not a number 一个不是数字的数字类型) string：字符串。 字符串 “abc” “a” ‘abc’ boolean: true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 引用数据类型：对象 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法： var 变量名 &#x3D; 初始化值; typeof运算符：获取变量的类型。 注：null运算后得到的是object 运算符 一元运算符：只有一个运算数的运算符 ​ ++，– ， +(正号) ++ –: 自增(自减) ++(–) 在前，先自增(自减)，再运算 ++(–) 在后，先运算，再自增(自减) +(-)：正负号 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 其他类型转number： string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） boolean转number：true转为1，false转为0 算数运算符 + - * / % ... 12343. ``` 赋值运算符 = += -+.... &#96;&#96;&#96;比较运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;(全等于) 123456789 - 比较方式 1. 类型相同：直接比较 - 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 2. 类型不同：先进行类型转换，再比较 - ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false5. 逻辑运算符 &amp;&amp; || ! 123456789 - 其他类型转boolean： 1. number：0或NaN为假，其他为真 2. string：除了空字符串(&quot;&quot;)，其他都是true 3. null&amp;undefined:都是false 4. 对象：所有对象都为true6. 三元运算符 ? : 表达式 var a = 3; var b = 4; var c = a &gt; b ? 1:0; 1234567891011121314151617181920212223242526 - 语法： - 表达式? 值1:值2; - 判断表达式的值，如果是true则取值1，如果是false则取值2；- 流程控制语句： 1. if...else... 2. switch: - 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) - switch(变量): case 值: - 在JS中,switch语句可以接受任意的原始数据类型 3. while 4. do...while 5. for- JS特殊语法： 1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 2. 变量的定义使用var关键字，也可以不使用 - 用： 定义的变量是局部变量 - 不用：定义的变量是全局变量(不建议)- 练习：99乘法表 &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td&#123; border: 1px solid; &#125; &lt;/style&gt; &lt;script&gt; document.write(&quot;&lt;table align=&#39;center&#39;&gt;&quot;); //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) &#123; document.write(&quot;&lt;tr&gt;&quot;); for (var j = 1; j &lt;=i ; j++) &#123; document.write(&quot;&lt;td&gt;&quot;); //输出 1 * 1 = 1 document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;); document.write(&quot;&lt;/td&gt;&quot;); &#125; /*//输出换行 document.write(&quot;&lt;br&gt;&quot;);*/ document.write(&quot;&lt;/tr&gt;&quot;); &#125; //2.完成表格嵌套 document.write(&quot;&lt;/table&gt;&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; - 基本对象： 1. Function：函数(方法)对象 1. 创建： 1. var fun = new Function(形式参数列表,方法体); //忘掉吧 2. function 方法名称(形式参数列表)&#123; 方法体 &#125; 3. var 方法名 = function(形式参数列表)&#123; 方法体 &#125; 2. 方法： 3. 属性： length:代表形参的个数 4. 特点： 1. 方法定义是，形参的类型不用写,返回值类型也不写。 2. 方法是一个对象，如果定义名称相同的方法，会覆盖 3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关 4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 5. 调用： 1. 方法名称(实际参数列表); 2. Array:数组对象 1. 创建： 1. var arr = new Array(元素列表); 2. var arr = new Array(默认长度); 3. var arr = [元素列表]; 2. 方法 ​ join(参数):将数组中的元素按照指定的分隔符拼接为字符串 ​ push() 向数组的末尾添加一个或更多元素，并返回新的长度。 3. 属性 1. length:数组的长度 4. 特点： 1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。 3. Boolean 4. Date：日期对象 1. 创建： 1. var date = new Date(); 2. 方法： 1. toLocaleString()：返回当前date对象对应的时间本地字符串格式 2. getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 5. Math：数学对象 1. 创建： - 特点：Math对象不用创建，直接使用。 Math.方法名(); 2. 方法： 1. random():返回 0 ~ 1 之间的随机数。 含0不含1 2. ceil(x)：对数进行上舍入。 3. floor(x)：对数进行下舍入。 4. round(x)：把数四舍五入为最接近的整数。 3. 属性： 1. PI 6. Number 7. String 8. RegExp：正则表达式对象 1. 正则表达式：定义字符串的组成规则。 1. 单个字符:[] 如： [a] [ab] [a-zA-Z0-9_] * 特殊符号代表特殊含义的单个字符: \\d:单个数字字符 [0-9] \\w:单个单词字符[a-zA-Z0-9_] 2. 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 &#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n * m如果缺省： &#123;,n&#125;:最多n次 * n如果缺省：&#123;m,&#125; 最少m次 3. 开始结束符号 - ^:开始 - $:结束 2. 正则对象： 1. 创建 1. var reg = new RegExp(&quot;正则表达式&quot;); 2. var reg = /正则表达式/; 2. 方法 1. test(参数):验证指定的字符串是否符合正则定义的规范 9. Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名(); 2. 方法： 1. encodeURI():url编码 2. decodeURI():url解码 3. encodeURIComponent():url编码,编码的字符更多 4. decodeURIComponent():url解码 5. parseInt():将字符串转为数字 1. 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number 6. isNaN():判断一个值是否是NaN 1. NaN六亲不认，连自己都不认。NaN参与的==比较全部问false 7. eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。 3. URL编码 1. 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"HTML&CSS","slug":"HTML-CSS","date":"2022-04-01T07:31:37.000Z","updated":"2022-04-02T09:44:04.782Z","comments":true,"path":"2022/04/01/HTML-CSS/","link":"","permalink":"http://example.com/2022/04/01/HTML-CSS/","excerpt":"","text":"HTML标签：表单标签 表单 概念：用于采集用户输入的数据的。用于和服务器进行交互。 form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 属性： action：指定提交数据的URL method:指定提交方式 分类：一共7种，2种比较常用 get： 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 请求参数大小是有限制的。 不太安全。 Post: 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 请求参数的大小没有限制。 较为安全。 表单项中的数据要想被提交：必须指定其name属性 表单项标签： input：可以通过type属性值，改变元素展示的样式 type属性： text：文本输入框，默认值 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 password：密码输入框 radio:单选框 注意 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 checkbox：复选框 注意： 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息。 按钮： submit：提交按钮。可以提交表单 button：普通按钮 image：图片提交按钮 src属性指定图片的路径 label：指定输入项的文字描述信息 注意： label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 select: 下拉列表 子元素：option，指定列表项 selected：默认选择 textarea：文本域 cols：指定列数，每一行有多少个字符 rows：默认多少行。 CSS：页面美化和布局控制 概念：Cascading Style Sheets 层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 CSS的使用：CSS与html结合方式 内联样式 在标签内使用style属性指定css代码 1如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 12345678如： &lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 1234567* a.css文件： div&#123; color:green; &#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; - 注意 - 1,2,3种方式 css作用范围越来越大 - 1方式不常用，后期常用2,3 - 3种格式可以写为： 123&lt;style&gt; @import &quot;css/a.css&quot;; &lt;/style&gt; css语法： 格式： 12345选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ... &#125; ​ 选择器:筛选具有相似特征的元素 注意： 每一对属性需要使用；隔开，最后一对属性可以不加； 选择器：筛选具有相似特征的元素 分类： 基础选择器 id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素 语法： 标签名称{} 注意：id选择器优先级高于元素选择器 类选择器：选择具有相同的class属性值的元素。 语法：.class属性值{} 注意：类选择器选择器优先级高于元素选择器 扩展选择器： 选择所有元素： 语法： *{} 并集选择器： 选择器1,选择器2{} 子选择器：筛选选择器1元素下的选择器2元素 语法： 选择器1 选择器2{} 父选择器：筛选选择器2的父元素选择器1 语法： 选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名&#x3D;属性值的元素 语法： 元素名称[属性名&#x3D;”属性值”]{} 伪类选择器：选择一些元素具有的状态 语法： 元素:状态{} 如： 状态： link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态 属性 字体、文本 font-size：字体大小 color：文本颜色 text-align：对其方式 line-height：行高 背景 background： 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;style&gt; *&#123; margin: 0px; padding: 0px; box-sizing: border-box; &#125; body&#123; background: url(&quot;img/register_bg.png&quot;) no-repeat center; padding-top: 25px; &#125; .rg_layout&#123; width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*让div水平居中*/ margin: auto; &#125; .rg_left&#123; /*border: 1px solid red;*/ float: left; margin: 15px; &#125; .rg_left &gt; p:first-child&#123; color:#FFD026; font-size: 20px; &#125; .rg_left &gt; p:last-child&#123; color:#A6A6A6; font-size: 20px; &#125; .rg_center&#123; float: left; /* border: 1px solid red;*/ &#125; .rg_right&#123; /*border: 1px solid red;*/ float: right; margin: 15px; &#125; .rg_right &gt; p:first-child&#123; font-size: 15px; &#125; .rg_right p a &#123; color:pink; &#125; .td_left&#123; width: 100px; text-align: right; height: 45px; &#125; .td_right&#123; padding-left: 50px ; &#125; #username,#password,#email,#name,#tel,#birthday,#checkcode&#123; width: 251px; height: 32px; border: 1px solid #A6A6A6 ; /*设置边框圆角*/ border-radius: 5px; padding-left: 10px; &#125; #checkcode&#123; width: 110px; &#125; #img_check&#123; height: 32px; vertical-align: middle; &#125; #btn_sub&#123; width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026 ; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;rg_layout&quot;&gt; &lt;div class=&quot;rg_left&quot;&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;rg_center&quot;&gt; &lt;div class=&quot;rg_form&quot;&gt; &lt;!--定义表单 form--&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt; &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;rg_right&quot;&gt; &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"HTML","slug":"HTML","date":"2022-03-31T00:42:45.000Z","updated":"2022-04-01T07:31:00.519Z","comments":true,"path":"2022/03/31/HTML/","link":"","permalink":"http://example.com/2022/03/31/HTML/","excerpt":"","text":"web概念概述 JavaWeb： 使用Java语言开发基于互联网的项目 软件架构： C&#x2F;S: Client&#x2F;Server 客户端&#x2F;服务器端 ​ 在用户本地有一个客户端程序，在远程有一个服务器端程序 如：QQ，迅雷… 优点 用户体验好 缺点： 开发、安装，部署，维护 麻烦 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序 优点 开发、安装，部署，维护 简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高 B&#x2F;S架构详解 资源分类： 静态资源： 使用静态网页开发技术发布的资源。 特点： 所有用户访问，得到的结果是一样的。 如：文本，图片，音频、视频, HTML,CSS,JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源： 使用动态网页技术发布的资源。 特点： 所有用户访问，得到的结果可能不一样。 如：jsp&#x2F;servlet,php,asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源！ 静态资源： HTML：用于搭建基础网页，展示页面的内容 CSS：用于美化页面，布局页面 JavaScript：控制页面的元素，让页面有一些动态的效果 HTML 概念：是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本: 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. 标记语言: 由标签构成的语言。&lt;标签名称&gt; 如 html，xml 标记语言不是编程语言 快速入门： 语法： html文档后缀名 .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 自闭和标签：开始标签和结束标签在一起。如 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 12错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写。 123456789101112131415* 代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color=&#x27;red&#x27;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&#x27;green&#x27;&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 标签学习 文件标签：构成html最基本的标签 html:html文档的根标签 head：头标签。用于指定html文档的一些属性。引入外部的资源 title：标题标签。 body：体标签 1&lt;!DOCTYPE html&gt;：html 5 中定义该文档是html文档 文本标签：和文本有关的标签 12345678910111213141516171819202122* 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签 * &lt;br&gt;：换行标签 * &lt;hr/&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;font&gt;:字体标签 * &lt;center&gt;:文本居中 * 属性： * color：颜色 * size：大小 * face：字体 12345678* 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width=&#x27;20&#x27; ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 12345678910111213141516171819202122232425262728293031323334353637383940414243* 案例：公司简介 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;ch&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;黑马程序员简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 公司简介 &lt;/h1&gt; &lt;hr color=&quot;#ffd700&quot;&gt; &lt;p&gt; &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。 &lt;/p&gt; &lt;p&gt; 目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。 &lt;/p&gt; &lt;p&gt; 黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。 中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。 &lt;/p&gt; &lt;p&gt; 一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。 &lt;/p&gt; &lt;hr color=&quot;#ffd700&quot;&gt; &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt; &lt;center&gt; 江苏传智播客教育科技股份有限公司&lt;br&gt; 版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882 &lt;/center&gt; &lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 图片标签： img：展示图片 属性： src：指定图片的位置 代码： 1234567891011121314&lt;!--展示一张图片 img--&gt; &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt; &lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 --&gt; &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt; &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt; 列表标签： 有序列表： ol: li: 无序列表： ul: li: 链接标签： a:定义一个超链接 属性： href：指定访问资源的URL(统一资源定位符) target：指定打开资源的方式 _self:默认值，在当前页面打开 _blank：在空白页面打开 代码： 12345678910111213141516&lt;!--超链接 a--&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt; div和span： div:每一个div占满一整行。块级标签 span：文本信息在一行展示，行内标签 内联标签 语义化标签：html5中为了提高程序的可读性，提供了一些标签。 121. &lt;header&gt;：页眉2. &lt;footer&gt;：页脚 表格标签： 123456789101112131415161718* table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 案例：旅游网站首页分析 123456781. 确定使用table来完成布局 2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用 &lt;tr&gt; &lt;td&gt; &lt;table&gt;&lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;黑马旅游网&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--采用table来完成布局--&gt; &lt;!--最外层的table，用于整个页面的布局--&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;!-- 第1行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第2行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第3行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt; &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第4行 轮播图 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第5行 黑马精选--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt; 黑马精选 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第6行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第7行 国内游 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt; 国内游 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第8行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt; &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第9行 境外游 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt; 境外游 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第10行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt; &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第11行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第12行 --&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt; &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882 &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"计算机系统基础1.0","slug":"计算机系统基础1-0","date":"2022-03-30T14:28:23.000Z","updated":"2022-04-27T08:38:41.500Z","comments":true,"path":"2022/03/30/计算机系统基础1-0/","link":"","permalink":"http://example.com/2022/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%801-0/","excerpt":"","text":"C语言程序举例用“系统思维”分析问题123456#include&lt;stdio.h&gt;main()&#123; double a = 10; println(&quot;a = %d&quot;,a);&#125; 问题：在IA-32上运行时，打印结果为a&#x3D;0 在x86-64上运行时，打印出来的a是一个不确定值 理解该问题需要知道 IEEE 754 的表示 X87 FPU的体系结构 IA-32和x86-64中过程调用的参数传递 计算机内部的运算电路 什么是计算机系统？计算机系统抽象层的转换![截屏2022-03-30 22.49.52](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机系统基础1-0&#x2F;截屏2022-03-30 22.49.52.png) 计算机系统基础 内容提要使学生清楚理解计算机是如何生产和运行可执行文件的为什么学习这门课程 为了编程时少错误 可以找出错误 明白程序是怎样在计算机上执行的 1.2.1 冯.诺依曼结构主要思想任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需要操作人员干预下，自动完成逐条取出指令和执行指令任务。 计算机应由运算器，控制器，存储器，输入设备和输出设备五个基本部件组成。 各基本部件的功能是： 存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令 控制器应能自动取出指令来执行 运算器应能进行加&#x2F;减&#x2F;乘&#x2F;除四种基本算术运算，并且能进行一些逻辑运算和附加运算； 操作人员可以通过输入设备，输出设备和主机进行通信。 内部以二进制表示指令和数据。每条指令由操作码和地址码两部分组成。操作码指出操作类型，地址码指出操作数的地址。由一串指令组成程序。 采用“存储程序”工作方式 1.2.2现代计算机结构模型及工作原理MDR：Memory Data Register，存储器数据寄存器 ALU：Arithmetic Logic Unit，算术逻辑单元 GPR,General Purpose Register通用寄存器,s表复数 PC,program counter 程序计数器 ![截屏2022-04-27 16.14.40](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机系统基础1-0&#x2F;截屏2022-04-27 16.14.40.png) CPU:中央处理器; PC:程序计数器; MAR:存储器地址寄存器 ALU:算术逻辑部件; IR:指令寄存器; MDR:存储器数据寄存器 程序在执行前数据和指令事先存放在存储器中，每条指令和每个数据都有地址，指令按序存放，指令由OP，ADDR字段组成，程序启始地址置PC 开始执行程序 根据PC取指令 指令译码 取操作数 指令执行 回写结果 修改PC的值 继续执行下一条指令 指令和数据 程序启动前，指令和数据都存放在存储器中，形式上没有差别，都是0&#x2F;1序列 采用“存储程序”工作方式： 程序由指令组成，程序被启动后，计算机能自动取出一条一条指令执行，在执行过程中无需人的干预 指令中需要给出的信息：操作性质（操作码）源操作数1 或 源操作数2（立即数，寄存器编号，存储地址）目的操作数地址（寄存器编号，存储地址）存储地址的描述与操作数的数据结构有关","categories":[],"tags":[{"name":"计算机系统基础","slug":"计算机系统基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"JDBC连接池&JDBCTemplate","slug":"JDBC连接池-JDBCTemplate","date":"2022-03-30T00:33:17.000Z","updated":"2022-03-30T08:23:56.979Z","comments":true,"path":"2022/03/30/JDBC连接池-JDBCTemplate/","link":"","permalink":"http://example.com/2022/03/30/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0-JDBCTemplate/","excerpt":"","text":"数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 用户访问高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0：数据库连接池技术 步骤 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接： getConnection 1234//1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 获取连接：getConnection 12345678//3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 定义工具类 定义一个类 JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class JDBCUtils &#123; private static DataSource ds; static &#123; Properties pro = new Properties(); try &#123; pro.load(DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static DataSource getDataSource()&#123; return ds; &#125; &#125; Spring JDBC Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template &#x3D; new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 练习 需求 修改1号数据的 salary 为 10000 添加一条记录 删除刚才添加的记录 查询id为1的记录，将其封装为Map集合 查询所有记录，将其封装为List 查询所有记录，将其封装为Emp对象的List集合 查询总记录数 12//1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); 123456789101112/** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1()&#123; //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); &#125; 12345678910/** * 2. 添加一条记录 */ @Test public void test2()&#123; String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); &#125; 123456789/** * 3.删除刚才添加的记录 */ @Test public void test3()&#123; String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); &#125; 123456789101112/** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; 123456789101112/** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; 123456789101112/** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; 123456789101112/** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637/** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"操作系统上的程序","slug":"操作系统上的程序","date":"2022-03-29T13:27:57.000Z","updated":"2022-03-30T00:30:10.496Z","comments":true,"path":"2022/03/29/操作系统上的程序/","link":"","permalink":"http://example.com/2022/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"状态机与数字电路状态机：复习概念：https://blog.csdn.net/pingxiaozhao/article/details/109239311 数字逻辑电路 状态&#x3D;寄存器保存的值（flip-flop） 初始状态&#x3D;RESET（implementation dependent） 迁移&#x3D;组合逻辑电路计算寄存器下一周期的值 例子： 12X′=¬X∧YY′=¬X∧¬Y 什么是程序（源代码视角）","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"JDBC","slug":"JDBC","date":"2022-03-27T07:22:27.000Z","updated":"2022-03-29T08:25:20.674Z","comments":true,"path":"2022/03/27/JDBC/","link":"","permalink":"http://example.com/2022/03/27/JDBC/","excerpt":"","text":"JDBC: 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门 步骤 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键–&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 代码实现 12345678910111213141516//1. 导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 3.详解各个对象 DriverManager：驱动管理对象 功能： 注册驱动：告诉程序该使用哪一个数据库驱动jarstatic void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。写代码使用： Class.forName(“com.mysql.jdbc.Driver”);通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 1234567static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2.获取数据库连接： 方法：static Connection getConnection(String url, String user, String password) 参数 url：指定连接的路径 语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称 例子：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称 user：用户名 password：密码 2.Connection：数据库连接对象 功能： 获取执行sql 的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 执行sql boolean execute(String sql) ：可以执行任意的sql 了解 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是 ResultSet executeQuery(String sql) ：执行DQL（select)语句 3.Statement：执行sql的对象 执行sql boolean execute(String sql) ：可以执行任意的sql 了解 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 练习 account表 添加一条记录 account表 修改记录 account表 删除一条记录 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445Statement stmt = null; Connection conn = null; try &#123; //1. 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 定义sql String sql = &quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;; //3.获取Connection对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0)&#123; System.out.println(&quot;添加成功！&quot;); &#125;else&#123; System.out.println(&quot;添加失败！&quot;); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4.ResultSet：结果集对象,封装查询结果 boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 注意： 使用步骤： 游标向下移动一行 判断是否有数据 获取数据 12345678910//循环判断游标是否是最后一行末尾。while(rs.next())&#123;//获取数据//6.2 获取数据int id = rs.getInt(1);String name = rs.getString(&quot;name&quot;);double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);&#125; 练习 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 定义Emp类 定义方法 public List findAll(){} 实现方法 select * from emp; 5.PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户随便，输入密码：a’ or ‘a’ &#x3D; ‘a sql：select * from user where username &#x3D; ‘fhdsjkf’ and password &#x3D; ‘a’ or ‘a’ &#x3D; ‘a’ 解决sql注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username &#x3D; ? and password &#x3D; ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法： setXxx(参数1,参数2) 参数1：？的位置编号 从1 开始 参数2：？的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 抽取JDBC工具类 ： JDBCUtils 目的 分析 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件 1234jdbc.properties url= user= password= 抽取一个方法释放资源 代码实现： 123456789101112131415161718192021222324252627282930313233343536public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static&#123; //读取资源文件，获取值。 try &#123; //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(&quot;D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties&quot;)); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); //4. 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; 12345678910111213141516171819202122232425262728293031/** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn)&#123; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031/** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn)&#123; if( rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 练习 需求： 通过键盘录入用户名和密码 判断用户是否登录成功 select * from user where username &#x3D; “” and password &#x3D; “”; 如果这个sql有查询结果，则成功，反之，则失败 步骤 创建数据库表 user 123456789CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,&#x27;zhangsan&#x27;,&#x27;123&#x27;); INSERT INTO USER VALUES(NULL,&#x27;lisi&#x27;,&#x27;234&#x27;) 2.代码实现 12345678910111213141516171819public class JDBCDemo9 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag)&#123; //登录成功 System.out.println(&quot;登录成功！&quot;); &#125;else&#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; 3.登录方法 123456789101112131415161718192021222324252627282930313233343536/** * 登录方法 */ public boolean login(String username ,String password)&#123; if(username == null || password == null)&#123; return false; &#125; //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try &#123; conn = JDBCUtils.getConnection(); //2.定义sql String sql = &quot;select * from user where username = &#x27;&quot;+username+&quot;&#x27; and password = &#x27;&quot;+password+&quot;&#x27; &quot;; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next())&#123;//如果有下一行，则返回true return true; &#125;else&#123; return false; &#125;*/ return rs.next();//如果有下一行，则返回true &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(rs,stmt,conn); &#125; return false; &#125; &#125; JDBC控制事务： 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;; //2.2 李四 + 500 String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MySQL多表和事物","slug":"MySQL多表和事物","date":"2022-03-26T01:03:21.000Z","updated":"2022-03-29T01:33:49.837Z","comments":true,"path":"2022/03/26/MySQL多表和事物/","link":"","permalink":"http://example.com/2022/03/26/MySQL%E5%A4%9A%E8%A1%A8%E5%92%8C%E4%BA%8B%E7%89%A9/","excerpt":"","text":"多表查询 查询语法 select 列名列表 from 表名列表 where…. 准备sql 123456创建部门表CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO dept (NAME) VALUES (&#x27;开发部&#x27;),(&#x27;市场部&#x27;),(&#x27;财务部&#x27;); 123456789101112131415创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;孙悟空&#x27;,&#x27;男&#x27;,7200,&#x27;2013-02-24&#x27;,1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;猪八戒&#x27;,&#x27;男&#x27;,3600,&#x27;2010-12-02&#x27;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;唐僧&#x27;,&#x27;男&#x27;,9000,&#x27;2008-08-08&#x27;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;白骨精&#x27;,&#x27;女&#x27;,5000,&#x27;2015-10-07&#x27;,3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;蜘蛛精&#x27;,&#x27;女&#x27;,4500,&#x27;2011-03-14&#x27;,1); 笛卡尔积 有两个集合A,B .取这两个集合的所有组成情况。 要完成多表查询，需要消除无用的数据 多表查询的分类： 内连接查询： 隐式内连接：使用where条件消除无用数据 例 12345678910111213141516-- 查询所有员工信息和对应的部门信息SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 查询员工表的名称，性别。部门表的名称 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; 显式内连接： 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 例 SELECT * FROM emp INNER JOIN dept ON emp.dept_id &#x3D; dept.id; SELECT * FROM emp JOIN dept ON emp.dept_id &#x3D; dept.id; 内连接查询： 从哪些表中查询数据 条件是什么 查询哪些字段 外链接查询： 左外连接： 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； 查询的是左表所有数据以及其交集部分。 例子 12-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接： 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； 查询的是右表所有数据以及其交集部分。 例子 1SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 子查询： 概念：查询中嵌套查询，称嵌套查询为子查询。 123456789-- 查询工资最高的员工信息 -- 1 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); 子查询的不同种情况 子查询的结果是单行单列的： 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D; 12-- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 子查询的结果是多行单列的： 子查询可以作为条件，使用运算符in来判断 12345-- 查询&#x27;财务部&#x27;和&#x27;市场部&#x27;所有的员工信息 SELECT id FROM dept WHERE NAME = &#x27;财务部&#x27; OR NAME = &#x27;市场部&#x27;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;-- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#x27;财务部&#x27; OR NAME = &#x27;市场部&#x27;); 子查询的结果是多行多列的： 子查询可以作为一张虚拟表参与查询 12345678-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息-- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#x27;2011-11-11&#x27;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &#x27;2011-11-11&#x27; 练习 表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273-- 部门表 CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,&#x27;教研部&#x27;,&#x27;北京&#x27;), (20,&#x27;学工部&#x27;,&#x27;上海&#x27;), (30,&#x27;销售部&#x27;,&#x27;广州&#x27;), (40,&#x27;财务部&#x27;,&#x27;深圳&#x27;); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, &#x27;董事长&#x27;, &#x27;管理整个公司，接单&#x27;), (2, &#x27;经理&#x27;, &#x27;管理部门员工&#x27;), (3, &#x27;销售员&#x27;, &#x27;向客人推销产品&#x27;), (4, &#x27;文员&#x27;, &#x27;使用办公软件&#x27;); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&#x27;孙悟空&#x27;,4,1004,&#x27;2000-12-17&#x27;,&#x27;8000.00&#x27;,NULL,20), (1002,&#x27;卢俊义&#x27;,3,1006,&#x27;2001-02-20&#x27;,&#x27;16000.00&#x27;,&#x27;3000.00&#x27;,30), (1003,&#x27;林冲&#x27;,3,1006,&#x27;2001-02-22&#x27;,&#x27;12500.00&#x27;,&#x27;5000.00&#x27;,30), (1004,&#x27;唐僧&#x27;,2,1009,&#x27;2001-04-02&#x27;,&#x27;29750.00&#x27;,NULL,20), (1005,&#x27;李逵&#x27;,4,1006,&#x27;2001-09-28&#x27;,&#x27;12500.00&#x27;,&#x27;14000.00&#x27;,30), (1006,&#x27;宋江&#x27;,2,1009,&#x27;2001-05-01&#x27;,&#x27;28500.00&#x27;,NULL,30), (1007,&#x27;刘备&#x27;,2,1009,&#x27;2001-09-01&#x27;,&#x27;24500.00&#x27;,NULL,10), (1008,&#x27;猪八戒&#x27;,4,1004,&#x27;2007-04-19&#x27;,&#x27;30000.00&#x27;,NULL,20), (1009,&#x27;罗贯中&#x27;,1,NULL,&#x27;2001-11-17&#x27;,&#x27;50000.00&#x27;,NULL,10), (1010,&#x27;吴用&#x27;,3,1006,&#x27;2001-09-08&#x27;,&#x27;15000.00&#x27;,&#x27;0.00&#x27;,30), (1011,&#x27;沙僧&#x27;,4,1004,&#x27;2007-05-23&#x27;,&#x27;11000.00&#x27;,NULL,20), (1012,&#x27;李逵&#x27;,4,1006,&#x27;2001-12-03&#x27;,&#x27;9500.00&#x27;,NULL,30), (1013,&#x27;小白龙&#x27;,4,1004,&#x27;2001-12-03&#x27;,&#x27;30000.00&#x27;,NULL,20), (1014,&#x27;关羽&#x27;,4,1007,&#x27;2002-01-23&#x27;,&#x27;13000.00&#x27;,NULL,10); -- 工资等级表 CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资 ); -- 添加5个工资等级 INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); 需求 需求1 1234567891011121314151617-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 /* 分析： 1.员工编号，员工姓名，工资，需要查询emp表 职务名称，职务描述 需要查询job表 2.查询条件 emp.job_id = job.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description` -- 职务描述 FROM emp t1, job t2 WHERE t1.`job_id` = t2.`id`; 需求2 12345678910111213141516171819-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 /* 分析： 1. 员工编号，员工姓名，工资 emp 职务名称，职务描述 job 部门名称，部门位置 dept 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description`, -- 职务描述 t3.`dname`, -- 部门名称 t3.`loc` -- 部门位置 FROM emp t1, job t2,dept t3 WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`; 需求3 12345678910111213-- 3.查询员工姓名，工资，工资等级 /* 分析： 1.员工姓名，工资 emp 工资等级 salarygrade 2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */ SELECT t1.ename , t1.`salary`, t2.* FROM emp t1, salarygrade t2 WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`; 需求4 123456789101112131415161718192021-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 /* 分析： 1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept 工资等级 salarygrade 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */ SELECT t1.`ename`, t1.`salary`, t2.`jname`, t2.`description`, t3.`dname`, t3.`loc`, t4.`grade` FROM emp t1,job t2,dept t3,salarygrade t4 WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`; 需求5 12345678910111213141516171819-- 5.查询出部门编号、部门名称、部门位置、部门人数 /* 分析： 1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表 2.使用分组查询。按照emp.dept_id完成分组，查询count(id) 3.使用子查询将第2步的查询结果和dept表进行关联查询 */ SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.total FROM dept t1, (SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2 WHERE t1.`id` = t2.dept_id; 需求6 123456789101112131415161718192021222324252627282930-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 /* 分析： 1.姓名 emp， 直接上级的姓名 emp * emp表的id 和 mgr 是自关联 2.条件 emp.id = emp.mgr 3.查询左表的所有数据，和 交集数据 * 使用左外连接查询 */ /* select t1.ename, t1.mgr, t2.`id`, t2.ename from emp t1, emp t2 where t1.mgr = t2.`id`; */ SELECT t1.ename, t1.mgr, t2.`id`, t2.`ename` FROM emp t1 LEFT JOIN emp t2 ON t1.`mgr` = t2.`id`; 事物 事物的基本介绍 概念 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作 开启事务： start transaction; 回滚：rollback; 提交：commit; 例子： 12345678CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES (&#x27;zhangsan&#x27;, 1000), (&#x27;lisi&#x27;, 1000); 1234567891011121314-- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &#x27;zhangsan&#x27;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &#x27;lisi&#x27;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4.MySQL数据库中事务默认自动提交 事务提交的两种方式： 自动提交：- mysql就是自动提交的- 一条DML(增删改)语句会自动提交一次事务。 手动提交： Oracle 数据库默认是手动提交事务 需要先开启事务，再提交 修改事务的默认提交方式： 查看事务的默认提交方式：SELECT @@autocommit; – 1 代表自动提交 0 代表手动提交 修改默认提交方式： set @@autocommit &#x3D; 0; 事务的四大特征： 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 事务的隔离级别（了解） 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别 read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 serializable：串行化 * 可以解决所有的问题 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别： * select @@tx_isolation; 数据库设置隔离级别： * set global transaction isolation level 级别字符串; 演示： 12345set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2; DCL: SQL分类： DDL：操作数据库和表 DML：增删改表中数据 DQL：查询表中数据 DCL：管理用户，授权 DBA：数据库管理员 DCL：管理用户，授权 管理用户 添加用户： 语法：CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’; 删除用户： 语法：DROP USER ‘用户名‘@’主机名’; 修改用户密码： 12345UPDATE USER SET PASSWORD = PASSWORD(&#x27;新密码&#x27;) WHERE USER = &#x27;用户名&#x27;; UPDATE USER SET PASSWORD = PASSWORD(&#x27;abc&#x27;) WHERE USER = &#x27;lisi&#x27;; SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; = PASSWORD(&#x27;新密码&#x27;); SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;123&#x27;); mysql中忘记了root用户的密码？ cmd – &gt; net stop mysql 停止mysql服务 需要管理员运行该cmd 使用无验证方式启动mysql服务： mysqld –skip-grant-tables 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 use mysql; update user set password &#x3D; password(‘你的新密码’) where user &#x3D; ‘root’; 关闭两个窗口 打开任务管理器，手动结束mysqld.exe 的进程 启动mysql服务 使用新密码登录。 查询用户： 切换到mysql数据库 USE myql; 查询user表 SELECT * FROM USER; 通配符： % 表示可以在任意主机使用用户登录数据库 2.权限管理： 查询权限： 123-- 查询权限 SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;; SHOW GRANTS FOR &#x27;lisi&#x27;@&#x27;%&#x27;; 授予权限： 12345-- 授予权限 grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;; 撤销权限 123-- 撤销权限： revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;; REVOKE UPDATE ON db3.`account` FROM &#x27;lisi&#x27;@&#x27;%&#x27;;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"四级词汇1-6串词","slug":"四级单词1-6串词","date":"2022-03-24T14:36:21.000Z","updated":"2022-05-04T08:19:26.165Z","comments":true,"path":"2022/03/24/四级单词1-6串词/","link":"","permalink":"http://example.com/2022/03/24/%E5%9B%9B%E7%BA%A7%E5%8D%95%E8%AF%8D1-6%E4%B8%B2%E8%AF%8D/","excerpt":"","text":"四级词汇第一串词：view（看；被看见的）view v.认为 n.观点；风景re - : 再一次 review n.v.回顾；复习；评论 inter - : 相互 interview n. v. 采访；面试；面谈 interviewee n. 被面试者，被接见者，被访问者 interviewer n.采访者；见面者；进行面试 employer 雇主 employee 雇员 第二串词：quire&#x2F;quest&#x2F;quer(to ask 询问，to seek 寻找)question n.问题 v.质疑；怀疑-tion ：名词词尾request n. v. 请求；需要（“请”） guest 客人（正式，客气） re - ：再 restart 重启 request sb to do sth 请求某人做某事 require v.需要；要求（&#x3D; need） 中性词 requirement n. 要求；必要条件 to meet&#x2F;satisfy the requirements 符合条件 acquire v. 获得；取得；学到（技巧，学问） ac - ：强调 技巧 kill inquire v.询问；查究 in - ：进来，向内 income 收入 conquer v. 征服 con - ：共同，强调 conquer your fear 克服恐惧 conquer the world 征服世界 overcome 克服小问题 第3串词：duce&#x2F;duct&#x2F;duc（to lead 引导；拉）produce v.生产；引起；创作 pro - ：向前 educate v. 教育；培养 e - （ex - ）：出（out） -ate：动词词尾 （正式）教育，内容比teach广泛（周围人言传身教，家庭的影响，熏陶） train ：训练，培养 tutor：一对一 teach：“教”：最普通用语，教授具体知识，技能 education n. 教育；培养 higher education 高等教育（指含大学以上的教育） educational adj.教育的；有教育意义的 educational reform 教育改革 product n. 产品；产物production n. 生产；制造produce v.生产；引起；创作producer n. 生产商producetive adj.多产的；有成效的 productive workers 高效（多产的）工人 a productive meeting 有成效的会议 byproduct n.副产品（中性词） by your side 在你身边 side effect 副作用（中性词） productivity n.生产力；生产率conduct n.行为 v.实施；引导；指挥；传导（热，电） con-&#x2F;com-：共同，强调 conduct business 做生意 I am deeply hurt by her conduct. 她的行为深深地伤害了我 induce v.诱导，劝说；导致（中性词） in-：进来，向内 induce me to take the jib 诱使我接受这份工作 Some drugs will induce sleep 有些药物会使人昏昏欲睡 reduce v.减少；降低 re-：向后，往回 reduce the speed 减速 reduce the risk of heart disease 降低心脏病风险 reduction n.减少;下降Introduce v.介绍；引进 introduced A to B 把A介绍给B The new law was introduced in 1991. 这项法律是于1991年开始实施 introduce the technology to the world。 把这项技术推向世界 introduction n.介绍;引进 Intro-:在内，向内（within） reproduce v.复制；繁殖reproduction n.繁殖；复制reproductive adj.繁殖的 re-:再 第四串词：fess（to say，to talk 说）Professor n.教授；教师profession n.职业，专业；声明 -sion:名词词尾 The medical&#x2F;legal profession 医学专业,法律专业 professional adj.专业的；职业的 n.专家；专门人才 -al：形容词，名词词尾 Professional skills 专业技能 health professionals 健康方面的专门人才 第5串词：just&#x2F;jur&#x2F;jud(law 法律，right 正义)just adj.公正的，合理的；正直的 adv.只是；刚才 I just saw him. 我刚才还见过他 a just decision&#x2F;society 一个公正的决定&#x2F;社会 justice n.公正，公平 -ce：名词词尾 justify v.证明正确；替…辩护（解释） -fy：动词词尾 beautify 美化 Justify a war 证明战争是正确的 Justify your wrong actions 为了你的错误行为辩护 adjust v.调整；校准 ad-：向着 adjustment n.调整,调节injure v.伤害，损害 in-：否定前zu injury n.伤害,损伤judge n.法官；裁判员 v.判断；裁判；评价第6串词：mean（中间的）mean n.平均值 v.意味着 adj.刻薄的;平均的means n.手段；方法 单复数同行 meaning n.意义；含义meaningful adj.有意义的；意味深长的 a meaningful discussion 意义非凡的讨论 meanwhile adv.同时，其间 副词","categories":[],"tags":[{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"}]},{"title":"MySQL约束","slug":"MySQL约束","date":"2022-03-24T07:03:27.000Z","updated":"2022-03-25T07:44:57.979Z","comments":true,"path":"2022/03/24/MySQL约束/","link":"","permalink":"http://example.com/2022/03/24/MySQL%E7%BA%A6%E6%9D%9F/","excerpt":"","text":"DQL:查询语句1.排序查询 语法：order by 子句 order by 排序字段1 排序方式1 ， 排序字段2 排序方式2… 排序方式： ASC：升序，默认的。 DESC：降序。 注意 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 2.聚合函数将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注意 聚合函数的计算，排除null值。 解决方案 选择不包含非空的列进行计算 IFNULL函数 1SELECT COUNT(english) FROM student; 3.分组查询 语法：group by 分组字段； 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 12345678910111213-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 4.分页查询 语法：limit 开始的索引,每页查询的条数; 公式：开始的索引 &#x3D; （当前的页码 - 1） * 每页显示的条数 limit 是一个MySQL”方言” 123456-- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 非空约束：not null，某一列的值不能为null 创建表时添加约束 1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); - 创建表完后，添加非空约束 1ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; - 删除name的非空约束 1ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束：unique，某一列的值不能重复 注意 唯一约束可以有NULL值，但是只能有一条记录为null 在创建表时，添加唯一约束 &#96;&#96;&#96;CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE – 手机号 );12345- 删除唯一约束 - ``` ALTER TABLE stu DROP INDEX phone_number; 在表创建完后，添加唯一约束 &#96;&#96;&#96;ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;123456789101112131415161718 - - 主键约束：primary key。 - 注意： - 含义：非空且唯一 - 一张表只能有一个字段为主键 - 主键就是表中记录的唯一标识 - 在创建表时，添加主键约束 - ``` create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 12345- 创建完表后，添加主键- ``` ALTER TABLE stu MODIFY id INT PRIMARY KEY; 自动增长 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 12345- 删除自动增长- ``` ALTER TABLE stu MODIFY id INT; 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 123456789101112131415 - - 外键约束 - foreign key,让表与表产生关系，从而保证数据的正确性。 - 在创建表时，可以添加外键 - ``` create table 表名( .... --外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 删除外键 &#96;&#96;&#96;ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;12345- 创建表之后，添加外键 - ``` ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作 添加级联操作 &#96;&#96;&#96;语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ;12345678910111213141516171819202122232425262728293031 - 分类： - 级联更新：ON UPDATE CASCADE - 级联删除：ON DELETE CASCADE ## 数据库的设计1. 多表之间的关系 1. 分类： 1. 一对一(了解)： - 如：人和身份证 - 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： - 如：部门和员工 - 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： - 如：学生和课程 - 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： - 如：部门和员工 - 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： - 如：学生和课程 - 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： - 如：人和身份证 - 实现方式：一对一关系实现，可以在任意一方添加唯一（unique）外键指向另一方的主键。 3. 案例 多表之间的关系 分类： 一对一(了解)： 如：人和身份证 分析：一个人只有一个身份证，一个身份证只能对应一个人 一对多(多对一)： 如：部门和员工 分析：一个部门有多个员工，一个员工只能对应一个部门 多对多： 如：学生和课程 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 实现关系： 一对多(多对一)： 如：部门和员工 实现方式：在多的一方建立外键，指向一的一方的主键。 多对多： 如：学生和课程 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 一对一(了解)： 如：人和身份证 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 案例 – 创建旅游线路分类表 tab_category – cid 旅游线路分类主键，自动增长 – cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); – 创建旅游线路表 tab_route &#x2F;* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 *&#x2F; CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); &#x2F;*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 *&#x2F; CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT ‘男’, telephone VARCHAR(11), email VARCHAR(100) ); &#x2F;* 创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 *&#x2F; CREATE TABLE tab_favorite ( rid INT, – 线路id DATE DATETIME, uid INT, – 用户id – 创建复合主键 PRIMARY KEY(rid,uid), – 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 2.数据库设计的范式 - 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 - 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 - 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 - 分类 - 第一范式（1NF）：每一列都是不可分割的原子数据项 - 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） - 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） - 主属性：码属性组中的所有属性 - 非主属性：除过码属性组的属性 - 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） ## 数据库的备份与还原 1. 命令行： - 语法： - 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 - 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径 2. 图形化工具：","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MySQL基础","slug":"MySQL基础","date":"2022-03-22T03:13:04.000Z","updated":"2022-03-23T15:18:09.256Z","comments":true,"path":"2022/03/22/MySQL基础/","link":"","permalink":"http://example.com/2022/03/22/MySQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 – SQL 常见的数据库软件 MySQL MySQL数据库软件Mac安装 参考文献：https://www.jianshu.com/p/a8e4068a7a8a/ https://zhuanlan.zhihu.com/p/360858309 Mac卸载 参考文献：https://www.jianshu.com/p/276c1271ae14 配置 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 Mac参考文献：https://blog.csdn.net/qq_36004521/article/details/80637886 MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql –host&#x3D;ip –user&#x3D;root –password&#x3D;连接目标的密码 * MySQL退出 1. exit 2. quit Mac mysql的命令参考文献：https://www.jianshu.com/p/c4756bcd6cbc https://blog.csdn.net/qq_19484963/article/details/80431703 MySQL目录结构 MySQL安装目录：basedir&#x3D;”D:&#x2F;develop&#x2F;MySQL&#x2F;“ 1. 配置文件 my.ini MySQL数据目录：datadir&#x3D;”C:&#x2F;ProgramData&#x2F;MySQL&#x2F;MySQL Server 5.5&#x2F;Data&#x2F;“ * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据 SQL基本概念什么是SQL Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3 种注释 单行注释: – 注释内容 或 # 注释内容(mysql 特有) 多行注释: &#x2F;* 注释 *&#x2F; SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1.操作数据库：CRUD1.C（Create）：创建 创建数据库： create database 数据库名称; 创建数据库，判断不存在，再创建： create database if not exists 数据库 名称 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 练习 创建db4数据库，判断是否存在，并制定字符集为gbk create database if not exists db4 character set gbk; 2.R（Retrieve）：查询 查询所有数据库的名称: - show databases; 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; 3.U(Update):修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; 4.D(Delete):删除 删除数据库 drop database 数据库名称; 判断数据库存在，存在再删除 drop database if exists 数据库名称; 5.使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 * use 数据库名称; 操作表1.C（Create）：创建 语法： create table 表名(列名1 数据类型1,列名2 数据类型2,….列名n 数据类型n); 注意：最后一列，不需要加逗号（,） 数据库类型： int：整数类型 age int, double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串 name varchar(20):姓名最大20个字符 zhangsan 8个字符 张三 2个字符 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); 复制表 create table 表名 like 被复制的表名; 2,R(Retrieve):查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; 3.U（Updata）：修改 修改表名 alter table 表名 rename to 新的表名; 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; 4.D（Delete）：删除 drop table 表名; drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中的数据1.添加数据 语法 insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,…值n); 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2.删除数据 语法 select * from 表名; delete from 表名 [where 条件] 注意 如果不加条件，则删除表中所有记录。 如果要删除所有记录 delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3.修改数据 语法 update 表名 set 列名1 &#x3D; 值1, 列名2 &#x3D; 值2,… [where 条件]; 注意 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录 select * from 表名; 语法 select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 基础查询 多个字断查询 select 字段名1，字段名2… from 表名； 注意 如果查询所有字段，则可以使用*来替代字段列表。 去除重复： distinct select distinct 字段名1 from 表名; 1234567- ​ 计算列 - 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） - ``` select name,math,english,math+english from student; - ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 如果该字段为null后的替换值 表达式2。 起别名 as：as也可以省略 1select name,math,english,math + ifnull(english,0) as 总分 from student; 条件查询 where子句后跟条件 运算符 &#x2F;&gt;、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt; BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; or 或 || not 或 ! 例子 123456789101112131415161718192021222324252627-- 查询年龄大于20岁SELECT * FROM student WHERE age &gt; 20;SELECT * FROM student WHERE age &gt;= 20;-- 查询年龄等于20岁SELECT * FROM student WHERE age = 20;-- 查询年龄不等于20岁SELECT * FROM student WHERE age != 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄大于等于20 小于等于30SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30;SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄22岁，18岁，25岁的信息SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25;SELECT * FROM student WHERE age IN (22,18,25);-- 查询英语成绩为nullSELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为nullSELECT * FROM student WHERE english IS NOT NULL; 1234567891011-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE &#x27;马%&#x27;;-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE &#x27;___&#x27;;-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE &#x27;%德%&#x27;;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"注解","slug":"注解","date":"2022-03-21T03:06:08.000Z","updated":"2022-03-22T03:09:19.683Z","comments":true,"path":"2022/03/21/注解/","link":"","permalink":"http://example.com/2022/03/21/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解概念：说明程序的。给计算机看的 注释：用文字描述程序的。给程序员看的 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 概念描述： * JDK1.5之后的新特性 * 说明程序的 * 使用注解：@注解名称 作用分类： ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 DK中预定义的一些注解 * @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 * @Deprecated：该注解标注的内容，表示已过时 * @SuppressWarnings：压制警告 * 一般传递参数all @SuppressWarnings(“all”) 自定义注解 格式： 元注解 public @interface 注解名称{ 属性列表; } 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 * public interface MyAnno extends java.lang.annotation.Annotation {} 属性：接口中的抽象方法 属性的返回值类型有下列取值 * 基本数据类型 * String * 枚举 * 注解 * 以上类型的数组 定义了属性，在使用时需要给属性赋值 1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 参考Java运行三个阶段 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 在程序使用(解析)注解：获取注解中定义的属性值 1. 获取注解定义的位置的对象 （Class，Method,Field） 1. public class ProImpl implements Pro&#123; public String className()&#123; return &quot;cn.itcast.annotation.Demo1&quot;; &#125; public String methodName()&#123; return &quot;show&quot;; &#125; &#125; 3. 调用注解中的抽象方法获取配置的属性值 1. 2. 获取指定的注解 * getAnnotation(Class) //其实就是在内存中生成了一个该注解接口的子类实现对象 案例：简单的测试框架 小结： 以后大多数时候，我们会使用注解，而不是自定义注解 注解给谁用？ 编译器 给解析程序用 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MQTT基础协议（上）","slug":"MQTT基础协议（上）","date":"2022-03-20T18:37:12.000Z","updated":"2022-03-20T18:44:14.033Z","comments":true,"path":"2022/03/21/MQTT基础协议（上）/","link":"","permalink":"http://example.com/2022/03/21/MQTT%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"1.1 MQTT是什么MQTT是一个客户端服务端架构的发布&#x2F;订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。 易于实现 数据传输的服务质量可控 占用带宽小 传输数据内容不可预知 设备连接状态可知 目前MQTT主流版本有两个，分别是MQTT3.1.1和MQTT5。MQTT3.1.1是在2014年10月发布的，而MQTT5是在2019年3月发布的。由于MQTT3.1.1与MQTT5的时间相差了将近五年，且MQTT5的发布时间距今不久，因此在本文书写时（2020年10月），MQTT3.1.1仍然主流版本。","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"Junit和反射和注解","slug":"Junit和反射和注解","date":"2022-03-20T08:54:35.000Z","updated":"2022-03-20T13:39:55.668Z","comments":true,"path":"2022/03/20/Junit和反射和注解/","link":"","permalink":"http://example.com/2022/03/20/Junit%E5%92%8C%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Junit单元测试：测试分类： 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 白盒测试：需要写代码的。关注程序具体的执行流程。 Junit使用：白盒测试 步骤 1.定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2.定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3.给方法加@Test 4.导入junit依赖环境 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 1Assert.assertEquals(期望的结果,运算的结果); 补充： @Before: 修饰的方法会在测试方法之前被自动执行 用于资源的申请 @After: 修饰的方法会在测试方法执行之后自动被执行 用于资源的释放 反射：框架设计的灵魂框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 反射：将类的各个组成部分封装为其他对象，这就是反射机制 ​ 好处 可以在程序运行过程中，操作这些对象。代码提示也是利用特性 可以解耦，提高程序的可扩展性。 获取Class对象的方法： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 结论 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 Class对象功能： ​ 获取功能： 1. 获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们： Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取全类名 String getName() 1.获取成员变量方法参数 Field：成员变量 ​ 操作： 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 忽略访问权限修饰符的安全检查 setAccessible(true):暴力反射 2.获取构造方法参数 Constructor:构造方法 ​ 创建对象： T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 3.获取成员方法参数 Method：方法对象 ​ 执行方法： Object invoke(Object obj, Object… args) （参数，实参列表） 获取方法名称： String getName:获取方法名","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"操作系统概述","slug":"操作系统概述","date":"2022-03-20T06:13:34.000Z","updated":"2022-03-20T14:08:36.978Z","comments":true,"path":"2022/03/20/操作系统概述/","link":"","permalink":"http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","excerpt":"","text":"为什么要学习操作系统 目的你体内的 “编程力量” 尚未完全觉醒 每天都在用的东西，你还没搞明白 窗口是怎么创建的？为什么 Ctrl-C 有时不能退出程序？ 组里的服务器有 128 个处理器，但你的程序却只能用一个 😂 你每天都在用的东西，你却实现不出来 浏览器、编译器、IDE、游戏&#x2F;外挂、任务管理器、杀毒软件、病毒…… 什么是操作系统 操作系统：事实上，是一个软件体系，负责使程序易于运行（甚至让你看起来可以同时运行多个程序），允许程序共享内存，允许程序与设备交互，以及其他类似的有趣事情。 管理软&#x2F;硬件资源、为程序提供服务” 的程序 理解操作系统 问出正确的问题：操作系统如何从一开始变成现在这样的？ 三个重要的线索 计算机 (硬件) 程序 (软件) 操作系统 (管理软件的软件) 本课程狭义的操作系统 例：win liunx 1940s的计算机电子计算机的实现 逻辑门：真空电子管 存储器：延迟线 (delay lines) 输入&#x2F;输出：打孔纸带&#x2F;指示灯 没有操作系统 能把程序放上去就很了不起了 程序直接用指令操作硬件 不需要画蛇添足的程序来管理它 1950s计算机更快更小的逻辑门 (晶体管)、更大的内存 (磁芯)、丰富的 I&#x2F;O 设备 I&#x2F;O 设备的速度已经严重低于处理器的速度，中断机制出现 (1953) 1960s计算机集成电路、总线出现 更快的处理器 更快、更大的内存；虚拟存储出现 可以同时载入多个程序而不用 “换卡” 了 更丰富的 I&#x2F;O 设备；完善的中断&#x2F;异常机制 1960s操作系统能载入多个程序到内存且灵活调度它们的管理程序，包括程序可以调用的 API。 同时将多个程序载入内存是一项巨大的能力 有了进程 (process) 的概念 进程在执行 I&#x2F;O 时，可以将 CPU 让给另一个进程 在多个地址空间隔离的程序之间切换 虚拟存储使一个程序出 bug 不会 crash 整个系统 操作系统中自然地增加进程管理 API 基于中断 (例如时钟) 机制 时钟中断：使程序在执行时，异步地插入函数调用 由操作系统 (调度策略) 决定是否要切换到另一个程序执行 Multics (MIT, 1965) 现代操作系统诞生 1970s+计算机和操作系统和现代大差不差 今天的操作系统通过 “虚拟化” 硬件资源为程序运行提供服务的软件。 空前复杂的系统之一 更复杂的处理器和内存 非对称多处理器 (ARM big.LITTLE; Intel P&#x2F;E-cores) Non-uniform Memory Access (NUMA) 更多的硬件机制 Intel-VT&#x2F;AMD-V, TrustZone&#x2F;SGX, TSX, … 更多的设备和资源 网卡、SSD、GPU、FPGA… 复杂的应用需求和应用环境 服务器、个人电脑、智能手机、手表、手环、IoT&#x2F;微控制器…… 理解操作系统：三个根本问题操作系统服务谁？ 程序 &#x3D; 状态机 课程涉及：多线程 Linux 应用程序 (设计&#x2F;应用视角) 操作系统为程序提供什么服务？ 操作系统 &#x3D; 对象 + API 课程涉及：POSIX + 部分 Linux 特性 (实现&#x2F;硬件视角) 如何实现操作系统提供的服务？ 操作系统 &#x3D; C 程序 完成初始化后就成为 interrupt&#x2F;trap&#x2F;fault handler 课程涉及：xv6, 自制迷你操作系统 如何学习操作系统计算机专业学生必须具备的核心素质。 是一个合格的操作系统用户 会 STFW&#x2F;RTFM 自己动手解决问题 不怕使用任何命令行工具 vim, tmux, grep, gcc, binutils, … 不惧怕写代码 能管理一定规模 (数千行) 的代码 能在出 bug 时默念 “机器永远是对的、我肯定能调出来的” 然后开始用正确的工具&#x2F;方法调试 给 “学渣” 们的贴心提示：补基础、补基础、补基础","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"模块化","slug":"模块化","date":"2022-03-19T08:51:45.000Z","updated":"2022-03-20T05:53:50.771Z","comments":true,"path":"2022/03/19/模块化/","link":"","permalink":"http://example.com/2022/03/19/%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"1.模块化1.1 模块化概述Java语言随着这些年的发展已经成为了一门影响深远的编程语言，无数平台，系统都采用Java语言编写。但是，伴随着发展，Java也越来越庞大，逐渐发展成为一门“臃肿”的语言。而且，无论是运行一个大型的软件系统，还是运行一个小的程序，即使程序只需要使用Java的部分核心功能，JVM也要加载整个JRE环境。为了给Java“瘦身”，让Java实现轻量化，Java 9正式的推出了模块化系统。Java被拆分为N多个模块，并允许Java程序可以根据需要选择加载程序必须的Java模块，这样就可以让Java以轻量化的方式来运行其实，Java 7的时候已经提出了模块化的概念，但由于其过于复杂，Java 7，Java 8都一直未能真正推出，直到Java9才真正成熟起来。对于Java语言来说，模块化系统是一次真正的自我革新，这种革新使得“古老而庞大”的Java语言重新焕发年轻的活力 1.2 模块的基本使用步骤模块的使用步骤 在项目中创建两个模块。一个是myOne,一个是myTwo 在myOne模块中创建以下包和以下类，并在类中添加方法 在myTwo模块中创建以下包和以下类，并在类中创建别的模块对象并使用 在myOne模块中src目录下，创建module-info.java，并写入exports+包名 在myTwo模块中src目录下，创建module-info.java，并写入require+模块名 如果出错，按下alt+enter 选择依赖 1.3 模块服务的使用模块服务使用使用步骤 在myOne模块中新建一个包，提供一个接口和两个实现类 在myOne模块中修改module-info.java文件，添加以下内容 导出模块：export com.itheima_03; 服务提供：provides MyService with itheima; 指定MyService的服务实现类是itheima 在myTwo这个文件的描述文件中添加如下配置 声明服务接口：uses MyService 在myTwo这个模块的类中使用MySerrive结构提供的服务 ServiceLoader：一种加载服务实现的工具","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"野格","slug":"野格","date":"2022-03-19T02:12:34.000Z","updated":"2022-03-22T15:57:02.042Z","comments":true,"path":"2022/03/19/野格/","link":"","permalink":"http://example.com/2022/03/19/%E9%87%8E%E6%A0%BC/","excerpt":"","text":"野格酒标上的单词来自德语单词 jager代表猎人 meister代表大师的意思 酿酒历史第一代酿酒人柯特*迈斯特是一位英勇的猎手，野格的前生并不是酒，而是印有鹿头的止咳药水，德国冬天异常寒冷，猎人在行动时容易染上风寒，为了解决这个问题，野格一代目在止咳水的基础上，添加了酒精，配上一些帮助消化，缓解呼吸道症状的草药来帮助猎手，猎手在行动中容易掉装备，所有选择这种最抗摔的墨绿色方瓶子，到1934年，纳粹德国颁布了帝国狩猎法，在这个法律中规定只有最杰出的猎手，才可以冠名“猎人大师“的名号，野格一代目也是在这是创建了商标，赚了一波热度 鹿头来源基督教中的两位猎人守护神，传闻中他们皈依耶稣时，看到了圣鹿出现在十字架中央 成分德国本土草本利口酒，其中成分含有56种不同的药材，水果，植物根茎以及辛香料 已公开的有杜松子，人参，甘草，肉桂，茴香，生姜，柑橘类果皮等等 制作工艺野格采用风干材料，把晒干的草本在中性酒精里浸泡三天，得到基础的香气以及颜色，整个浸泡工序要反反复复进行多次，大概要持续五个月，才进行首次过滤，放到橡木桶里进行陈年，经过365天的窖藏，药草酒得到了进一步成熟，酒液里杂醇类物质也会被逐渐分解，提高整体的口感，特别是经过橡木桶的润色之后，这个野格的酒体颜色会变更加深邃，同时减少草本植物带来的青涩味道，增强酒体结构，更加突出橡木的香气与果香，野格35度并不是来自蒸馏，它是在桶成一年后再次加入中性酒精，水，焦糖以及白砂糖，最终调整成品， 为什么加酒精光他本身的材料没有足够的糖分无法合成很多的酒精，所以要加中性酒精。 两大配方用料草本风味来自 甘草 增加天然甜味 药用价值 甘草素野格甜味之一，当年糖值钱 葑酮，香水中会用 茴香稀，遇水乳化，使酒浑浊乳白色 茴香 重要香料 大量茴香稀 拧烯，提供柠檬香气 桉油醇，樟脑丸气息","categories":[],"tags":[{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"}]},{"title":"类加载器和反射","slug":"类加载器和反射","date":"2022-03-17T07:32:30.000Z","updated":"2022-03-20T13:39:54.105Z","comments":true,"path":"2022/03/17/类加载器和反射/","link":"","permalink":"http://example.com/2022/03/17/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"","text":"1.类加载器1.1 类加载当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化 类的加载 就是指将class文件读入内存，并为之创建一个java.lang.Class对象 任何类被使用时，系统都会为之建立一个java.lang.Class对象 类的连接 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致 准备阶段：负责为类的类变量分配内存，并设置默认初始化值 解析阶段：将类的二进制数据中的符号引用替换为直接引用 类的初始化 在该阶段，主要就是对类变量进行初始化 类的初始化步骤 假如类还未被加载和连接，则程序先加载并连接该类 假如该类的直接父类还未被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3 类的初始化时机 创建类的实例 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 1.2 类加载器类加载器作用 负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。 虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！ JVM的类加载机制 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区 Java中内置类加载器 Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null，并且没有父null Platform class loader：平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类 System class loader：它也被称为应用程序类加载器，与平台类加载器不同。系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap ClassLoader中的两个方法 static ClassLoader getSystemClassLoader() 返回用于委派的系统类加载器 ClassLoader getParent() 返回父类加载器进行委派 1234567891011121314public class ClassLoaderDemo&#123;public static void main(String[]args)&#123; //static ClassLoader getSystemClassLoader():返回用于委派的系统类加载器 ClassLoader c = ClassLoader.getSystemClassLoader(); System.out.println(c);//AppClassLoader //ClassLoader getParent():返回父类加载器进行委派 ClassLoader c2 = c.getParent(); System.out.println(c2); //PlatformClassLoader ClassLoader c3 = c2.getParent(); System.out.println(c3);//null &#125;&#125; 2.反射2.1 反射的概述 是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展 可以访问一些类的私有成员 2.2 获取class类的对象三种方法 类名.class属性 对象名.getClass()方法 该方法是Object类中方法，所有Java对象都可以调用此方法 Class.forName(全类名)方法，需要传入字符串参数，该字符串参数是某个类的全路径，也是完整包名的路径 123456789101112131415161718192021public class ReflectDemo&#123; public static void main(String[] args)throwsClassNotFoundException&#123;//使用类的class属性来获取该类对应的Class对象 Class&lt;Student&gt;c1=Student.class; System.out.println(c1); Class&lt;Student&gt;c2=Student.class; System.out.println(c1==c2); System.out.println(&quot;--------&quot;); //调用对象的getClass()方法，返回该对象所属类对应的Class对象 Student s = new Student(); Class&lt;? extends Student&gt; c3 = s.getClass(); System.out.println(c1==c3); System.out.println(&quot;--------&quot;); //使用Class类中的静态方法 forName(String className) Class&lt;?&gt; c4 = Class.forName(&quot;com.itheima_02.Student&quot;); System.out.println(c1 == c4); &#125;&#125; 2.3 反射获取构造方法并使用Class类获取构造方法对象的方法 Constructor&lt;?&gt;[] getConstructors() 返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回所有构造方法对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 返回单个公共构造方法对象 Constructor getDeclaredConstructor(Class&lt;?&gt;…parameterTypes) 返回单个构造方法对象 12345678910111213141516171819202122232425//获取Class对象 Class&lt;?&gt;c=Class.forName(&quot;com.itheima_02.Student&quot;);//Constructor&lt;?&gt;[] getConstructors() 返回一个包含 Constructor对象的数组，Constructor对象反映了由该Class对象表示的类的所有公共构造函数、 Constructor&lt;?&gt;[]cons=c.getConstructors();//Constructor&lt;?&gt;[]getDeclaredConstructors()返回反映由该Class对象表示的类声明的所有构造函数的Constructor对象的数组 Constructor&lt;?&gt;[] cons = c.getDeclaredConstructors(); for(Constructor con : cons)&#123; System.out.println(con);&#125; System.out.println(&quot;--------&quot;);//Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;...parameterTypes) 返回一个Constructor对象，该对象反映由该Class对象表示的类的指定公共构造函数//参数：你要获取的构造方法的参数的个数和数据类型对应的字节码文件对象 Constructor&lt;?&gt; con = c.getConstructor();//Constructor提供了一个类的单个构造函数的信息和访问权限//T newInstance(Object...i nitargs) 使用由此 Constructor 对象表示的构造函数，使用指定的初始化参数来创建和初始化构造函数的声明类的新实例 Object obj = con.newInstance(); System.out.println(obj); &#125;&#125; Constructor类用于创建对象的方法 T newInstance(Object…initargs) 根据指定的构造方法创建对象 2.4 反射获取构造方法并使用练习通过反射获取构造方法并创建对象 12345678910111213public class ReflectDemo02 &#123; public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123; //获取Class类型 Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); //获取带三个参数带构造方法 Constructor&lt;?&gt; con = c.getConstructor(String.class, int.class, String.class); //创造新的对象 Object obj = con.newInstance(&quot;马宏跃&quot;,&quot;20&quot;,&quot;内蒙古&quot;); System.out.println(obj); &#125;&#125; 练习2 获取私有构造方法 12345678910 Class&lt;?&gt; c = Class.forName(&quot;com.itheima_02.Student&quot;); Constructor&lt;?&gt; con =c.getDeclaredConstructor(String.class); //暴力反射//public void setAccessible(booleanflag):值为true，取消访问检查 con.setAccessible(true); Object obj = con.newInstance(&quot;林青霞&quot;); Systeam.out.println(obj); 2.5 反射获取成员变量并使用方法 Field[] getFields() 返回所有公共成员变量对象的数组 Field[] getDeclaredFields() 返回所有成员变量对象的数组 Field getField(String name) 返回单个公共成员变量对象 Field getDeclaredField(String name) 返回单个成员变量对象 1234567891011121314151617181920public class ReflectDemo01 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; //获取对象 Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Field[] fields = c.getDeclaredFields(); for(Field field : fields)&#123; System.out.println(field); &#125; System.out.println(&quot;-----------&quot;); Field addressField = c.getField(&quot;address&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); addressField.set(obj,&quot;西安&quot;); System.out.println(obj); &#125;&#125; Field类中用于给成员变量赋值的方法 void set(Object obj,Object value) 给obj对象的成员变量赋值为value 2.6 反射获取成员变量并且使用练习1234567891011121314public class ReflectDemo02 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); Field nameField = c.getDeclaredField(&quot;name&quot;); //取消限制 nameField.setAccessible(true); nameField.set(obj,&quot;马宏跃&quot;); System.out.println(obj); &#125;&#125; 2.7 反射获取成员方法并使用方法 Method[] getMethods() 返回所有公共成员方法对象的数组，包括继承的 Method[] getDeclaredMethods() 返回所有成员方法对象的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt;…parameterTypes) 返回单个公共成员方法对象 Method getDeclaredMethod(String name, Class&lt;?&gt;…parameterTypes) 返回单个成员方法对象 用于执行方法的方法 Objectinvoke(Object obj,Object… args) 调用obj对象的成员方法，参数是args,返回值是Object类型 123456789101112public class ReflectDemo01 &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Method m = c.getMethod(&quot;method1&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); m.invoke(obj); &#125;&#125; 2.8 反射获取成员方法并且使用练习12345678910111213141516171819public class ReflectDemo02 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); Method m2 = c.getMethod(&quot;method2&quot; , String.class); Object i2 = m2.invoke(obj,&quot;马宏跃&quot;); Method m3 = c.getMethod(&quot;method3&quot; , String.class, int.class); Object i3 = m3.invoke(obj,&quot;马宏跃&quot;,30); System.out.println(i3); Method f1 = c.getDeclaredMethod(&quot;function&quot;); f1.setAccessible(true); System.out.println(f1); &#125;&#125; 2.9 反射练习在Integer的集合中，加入字符串数据 1234567891011121314151617public class RelectTest_01 &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(10); array.add(20); Class&lt;? extends ArrayList&gt; c = array.getClass(); Method m = c.getMethod(&quot;add&quot; , Object.class); m.invoke(array,&quot;hello&quot;); m.invoke(array,&quot;world&quot;); m.invoke(array,&quot;Java&quot;); System.out.println(array); &#125;&#125; 练习2 通过配置文件来创建任何类，并且使用方法 1234567891011121314151617181920212223public class RelectTest_02 &#123; public static void main(String[] args) &#123; Properties prop = new Properties(); FileReader fr = new FileReader(&quot;MyReflect\\\\class.txt&quot;); prop.load(fr); fr.close(); String className = prop.getProperty(&quot;className&quot;); String methodName = prop.getProperty(&quot;methodName&quot;); /* className=com.itheima_05.Student methodName=study */ Class&lt;?&gt; c = Class.forName(className); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); Method m = c.getMethod(methodName); m.invoke(obj); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"SUZE龙胆酒","slug":"SUZE龙胆酒","date":"2022-03-16T15:22:58.000Z","updated":"2022-03-16T15:41:31.697Z","comments":true,"path":"2022/03/16/SUZE龙胆酒/","link":"","permalink":"http://example.com/2022/03/16/SUZE%E9%BE%99%E8%83%86%E9%85%92/","excerpt":"","text":"SUZE龙胆酒一句话概括这是一种以龙胆植物作为主要原料，搭配了像香草，橙子，以及其他多种草药作为辅料的法国利口酒 味道苦中带甜，闻上去草本气息非常突出，还会有浓郁的花香，有甘草橙皮，姜黄的味道 原料龙胆植物，十年左右壮年龙胆 做法采摘后的龙胆需要切割，完了后放在食用酒精浸泡一年，然后取一部分龙胆根，挤成汁放进去一起蒸馏，最后和浸泡液一起调配，我们需要加水，加糖，大概稀释到20度左右进行装瓶 品牌故事费尔南德穆勒发明 起初接受家族酒厂生意不景气，遇到酿酒黑天鹅事件，根瘤蚜虫病，让很多葡萄酒白兰地行业受到很大打击，他和儿子进行发明，大胆使用龙胆发明 冰镇开胃，1889获得了世博会金奖，官网讲说他跟嫂子关系好，使用用嫂子的名字 推荐白尼格罗尼 喝法少数可以直接饮用，加冰块","categories":[],"tags":[{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"}]},{"title":"计算机的基本组成","slug":"计算机的基本组成","date":"2022-03-16T10:48:08.000Z","updated":"2022-03-24T07:00:45.839Z","comments":true,"path":"2022/03/16/计算机的基本组成/","link":"","permalink":"http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/","excerpt":"","text":"1.2 计算机的基本组成一. 冯.诺依曼计算机的特点 计算机由五大部件组成 运算器 控制器 存储器 输入设备 输出设备 指令和数据以同等地位存于存储器，可按地址寻址 混合存储 指令和数据用二进制表示 指令由操作码和地址码 存储程序（核心） 以运算器为中心 算数运算 逻辑运算 ![截屏2022-03-16 18.59.22](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机的基本组成&#x2F;截屏2022-03-16 18.59.22.png) 缺点：什么都要经过运算器，运算器过于繁忙 二.计算机硬件框图1.以存储器为中心的计算机硬件框图 系统复杂性管理方法（3Y） 层次化：将被设计的系统划分为多个模块或子模块 模块化：有明确定义的功能和接口 规则性：模块更容易被重用 三.计算机的工作步骤 上机前的准备 建立数学模型 确定计算方法 编制解题程序 程序–运算的全部步骤 指令–每一个步骤 指令格式：操作码+地址码 指令和数据都是保存着存储器中的 (1)存储器的基本组成存储体-存储单元-存储元件（0&#x2F;1） 大楼 - 房间 -床号 （无人&#x2F;有人） 存储单元 存放一串二进制代码 存储字 存储单元中二进制代码组合 存储字长 存储单元中二进制代码位数 ​ 每一个存储单元有一个地址 按地址寻址 MAR 地址寄存器，反映存储单元的个数 MDR 数据寄存器，反映存储字长 (2)运算器的基本组成及操作过程MQ 乘商寄存器 ACC 累加器 ALU 算术逻辑单元 X 操作寄存器 ![截屏2022-03-24 09.30.02](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机的基本组成&#x2F;截屏2022-03-24 09.30.02.png)","categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"Stream流","slug":"Stream流","date":"2022-03-16T08:42:39.000Z","updated":"2022-03-17T07:28:48.781Z","comments":true,"path":"2022/03/16/Stream流/","link":"","permalink":"http://example.com/2022/03/16/Stream%E6%B5%81/","excerpt":"","text":"1 Stream流1.1 体验Stream流使用Stream流的方式完成过滤操作 1list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println); 直接阅读代码的字面意思就可理解语意：生成流，过滤姓张，过滤长度为3，逐一打印 Stream流把真正的函数式风格引入Java中 1.2 Stream流的生成方式Stream流的使用 生成流 通过数据源（集合，数组等）生成流 list.stream() 中间操作 一个流后面可以跟随零个或多个中间操作，主要为了打开流，做出某种程度的数据过滤&#x2F;映射，然后返回一个新的流，交给下一个操作使用 filter() 终结操作 一个流只能有一个终结操作，当这个操作执行后，流就被使用“光”了，无法在被操作，所以这必定是流的最后一个操作 forEach() Stream流的常见生成方式 Collection 体系的集合可以使用默认方法stream()生成流 default Streamstream() Map体系的集合间接的生成流 数组可以通过Stream接口的静态方法of(T…..values)生成流 1234567891011121314151617181920212223public class StreamDemo &#123; public static void main(String[] args) &#123; //Collection体系集合可以使用默认stream()生成流 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); //Map体系集合间接生成流 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; IntStream = map.values().stream(); Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; entryStream = map.entrySet().stream(); //数组可以通过Stream接口的静态方法of(T...values)生成流 String[] strArray = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Stream&lt;String&gt; strArrayStream = Stream.of(strArray); Stream&lt;String&gt; strArrayStream1 = Stream.of(&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;); Stream&lt;Integer&gt; inArrayStream = Stream.of(10,20,30); &#125;&#125; 1.3 Stream流的常见中间操作 Streamfilter(Predicate predicate): 用于对流中的数据进行过滤 Predicate接口中的方法 Boolean test(T t): 对给定的参数进行判断，返回一个布尔值 1list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println); Streamlimit(long maxSize): 返回此流中的元素组成的流，截取前指定参数个数数据 Streamskip(long n): 跳过指定参数个数数据，返回由该流的剩余元素组成的流 1list.stream().skip(2).limit(2).forEach(System.out::println); static Streamconcat(Stream a,Stream b): 合并a和b两个流为一个流 Stream distinct(): 返回由该流的不同元素(根据Object.equals(Object))组合的流 1Stream.concat(s1,s2).forEach(System.out::println); 1Stream.concat(s1,s2).distinct().forEach(System.out::println); Stream sorted(): 返回由此流的元素组成的流，根据自然顺序排序 Stream sorted(Comparator comparator): 返回由该流的元素组成的流，根据提供的Comparator进行排序 根据比较器来排序 1list.stream().sorted().forEach(System.out::println); 12345list.stream().sorted((s1,s2) -&gt; &#123; int num = s1.length()-s2.langth(); int num2 = num==0?s1.compareTo(s2):num; return num2;&#125;).forEach(System.out::println); Stream map(Function mapper): 返回由给定函数应用于此流的元素的结果组成的流 Function接口中的方法 R apply(T t) IntStream mapToInt(TonIntFunction mapper): 返回一个Instream其中包含将给定函数应用用于此流的元素结果 InStream：表示原始int流 ToIntFunction接口中的方法 int applyAsInt(T value) int sum(): 返回此流中元素总和 1list.stream().map(Integer::parseInt).forEach(System.out::println); 1int result = list.stream().mapTiInt(Intrger::parseInt).sum(); 1.4 Stream流的常见终结操作方法Stream流的常见终结操作方法 void forEach(Consumer action): 对此流的每一个元素执行操作 Consumer接口中的方法 void accept(T t): 对给定的参数执行此操作 ling count(): 返回此流中的元素数 1list.stream().forEach(System.out::println); 1long count = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).count(); 1.5 Stream流的收集操作Stream流的收集方法 R collect(Collector collector) 但是这个收集方法的参数是一个Collector接口 工具类Collectors提供了具体的收集方法 public static Collector toList(): 把元素收集到List集合中 public static Collector toSet(): 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper): 把元素收集到Map集合中 1list&lt;String&gt; names = listStream.collect(Collectors.tolist()); 1Map&lt;String,Integer&gt; map = arrsyStream.collect(Collectors.toMap(s -&gt; s.split(&quot;,&quot;)[0]),s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) );","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"百利甜","slug":"百利甜","date":"2022-03-15T15:06:50.000Z","updated":"2022-03-15T15:46:16.948Z","comments":true,"path":"2022/03/15/百利甜/","link":"","permalink":"http://example.com/2022/03/15/%E7%99%BE%E5%88%A9%E7%94%9C/","excerpt":"","text":"百利甜 Baileys特点 香甜滑腻，充满了奶油的风味质感 原因：酒液里添加了优质的爱尔兰奶油，顺便还搭配了一些可可，香草的提取物来丰富他们的味道层次 酒精来自爱尔兰本地的威士忌 在一众利口酒中属于酒精度偏低的一类，仅有17%左右的酒精含量 历史 由帝亚吉欧的前身国际蒸馏酒公司出品 创始人汤姆·贾戈在20世纪70年代经过一系列的调研，先后研发出两款酒，马利宝椰子朗姆酒，百利奶油甜酒 时代背景，以前威士忌不受欢迎，被吐槽为“像白水一样寡淡”，另外爱尔兰奶制品十分发达，产能过剩，启发了发明的研发团队，做出奶+酒的尝试 基酒 特别选用以玉米为主导的爱尔兰威士忌，所以会让酒液富含更多奶油香草气息 百利甜的威士忌基酒都是需要三年桶陈的，很少见 这些基酒会提前添加可可，香草提取物，并且用焦糖上色 爱尔兰奶油，牛奶会过的十分舒服 调酒过程 由于酒和奶的密度不同，百利甜需要一些专业的均质机进行混合才能保证成品不会分层 由于它本身高糖，低酒精的特点容易造成酒体不稳定 成分检验十分严格 注意事项 酒液比较娇贵，放在阴凉避光处 高糖低酒精，带有蛋奶成分的酒更加容易变质 采用深色瓶子罐装 不开封保质期两年 利口酒最好在开封后一个月内快速消灭 复杂性和平衡度 百利甜很甜，很奶，但处了奶油的口感之外没有其他的风味表达 混合鸡尾酒非常容易破坏饮品的平衡度 参考文献https://www.bilibili.com/video/BV1KK4y1S7E7?spm_id_from=333.1007.top_right_bar_window_history.content.click","categories":[],"tags":[{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"}]},{"title":"计算机系统简介","slug":"计算机系统简介","date":"2022-03-15T09:23:04.000Z","updated":"2022-03-15T10:16:06.287Z","comments":true,"path":"2022/03/15/计算机系统简介/","link":"","permalink":"http://example.com/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"第一章计算机系统概论1.1计算机系统简介现代计算机系统是由哪两部分组成？ 硬件 计算机实体，如主机，外设 软件 由具有各类特殊功能的信息(程序)组成 软件分类 软件：用来管理整个计算机系统 语言处理程序 操作系统 服务性程序 数据库管理系统 网络软件 应用软件 按任务需要编制成各种程序 ![截屏2022-03-15 17.42.26](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机系统简介&#x2F;截屏2022-03-15 17.42.26.png) 系统复杂性管理的方法—–抽象：指高级的模型，和低级的实体相对，隐藏系统中不重要的细节 二 计算机系统的层次结构 计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性 （指令系统，数据类型，寻找技术，I&#x2F;O机理） 例：有无乘法指令 计算机组成：实现计算机体系结构所体现的属性 （具体指令的实现） 例：如何实现乘法指令","categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"函数式接口","slug":"函数式接口","date":"2022-03-15T07:01:28.000Z","updated":"2022-03-16T08:41:59.322Z","comments":true,"path":"2022/03/15/函数式接口/","link":"","permalink":"http://example.com/2022/03/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"1 函数式接口有且仅有一个抽象方法接口 Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且只有一个抽象方法，Java中的Lambda才能顺利地进行推导 command+B 可以看源码 看注解判断是否为函数式接口 option+command+v 补足代码 1234@FunctionalInterface//函数式接口注解public interface myInterface &#123; void show();&#125; 123456public class myInterfaceDemo &#123; public static void main(String[] args) &#123; myInterface my = () -&gt; System.out.println(&quot;函数式接口&quot;); my.show(); &#125;&#125; 1.2 函数式接口作为方法的参数如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递 1startThread(() -&gt; System.out.println(Thread.currentTgread&#123;&#125;.getname()+&quot;线程启动了&quot;)) 1.3 函数式接口作为方法的返回值12345678910111213141516private static Comparator&lt;String&gt; getComparator()&#123; //方法一 return new Comparator&lt;String&gt;()&#123; @Override public int compare(String s1,String s2)&#123; return s1.length()-s2.length(); &#125; &#125; //方法二 return (String s1,String s2) -&gt; &#123; return s1.length()-s2.length(); &#125;; //方法三 return (s1,s2) -&gt; s1.length() - s2.length();&#125; 如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回 1.4常用的函数式接口重点有以下几个 Supplier接口 Consumer接口 Predicate接口 Function接口 1.5 SupplierSupplier：包含一个无参的方法 T get():获得结果 要导包 该方法不需要参数，他会按照某种实现逻辑（由Lambda表达式实现）返回一个数据 Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生成什么类型的数据供我们使用 1234//定义一个方法，返回一个整数数据private static Integer getInteger(Supplier&lt;Integer&gt; sup)&#123; return sup.get();&#125; Tips： 装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型 直观的使用上的区别：基本数据类型不能为null，而包装器类可以为null 1234567891011121314151617181920public class SupplierText &#123; public static void main(String[] args) &#123; int[] arr = &#123;19,50,28,37,46&#125;; int Maxx = getMax(() -&gt; &#123; int Max = arr[0]; for (int i=1;i&lt;arr.length;i++)&#123; if(arr[i]&gt;Max)&#123; Max = arr[i]; &#125; &#125; return Max; &#125;); System.out.println(Maxx); &#125; private static int getMax(Supplier&lt;Integer&gt; sub)&#123; return sub.get(); &#125;&#125; 1.6 Consumer接口Consumer：包含两个方法 void accrpt：对给定的参数执行此操作 default ConsumerandThen(Consumer after)：返回一个组合的Consumer，依次执行此操作，如何执行after操作 Consumer接口也被称为消费型接口，它消费的数据的数据类型由泛型指定 1234567891011121314151617181920212223public class ConsumerDemo &#123; public static void main(String[] args) &#123; operatorString(&quot;马宏跃&quot;,(String s) -&gt; &#123; System.out.println(s); &#125;);//消费一次 operatorString(&quot;马宏跃&quot;,s -&gt; System.out.println(s));//消费两次 operatorString(&quot;马宏跃&quot;,s -&gt; System.out.println(s),s -&gt; System.out.println(new StringBuffer(s).reverse().toString())); &#125; private static void operatorString(String name,Consumer&lt;String&gt; num,Consumer&lt;String&gt; nbm)&#123; //方法一 num.accept(name); nbm.accept(name); //方法二 num.andThen(nbm).accept(name); &#125;//消费一次 private static void operatorString(String name, Consumer&lt;String&gt; sum)&#123; sum.accept(name); &#125;&#125; 练习 将字符串分离，按照格式打开 12345678910111213141516171819public class ConsumerTest &#123; public static void main(String[] args) &#123; String[] strArray = &#123;&quot;马宏跃,20&quot;,&quot;杜宇卓,19&quot;,&quot;卢世文,19&quot;&#125;; printInfo(strArray,(String str) -&gt; &#123; String name = str.split(&quot;,&quot;)[0]; System.out.print(&quot;姓名&quot;+name); &#125;,(String str) -&gt; &#123; int age = Integer.parseInt(str.split(&quot;,&quot;)[1]); System.out.println(&quot;,年龄&quot;+age); &#125;); &#125; private static void printInfo(String[] Array, Consumer&lt;String&gt; sum1,Consumer&lt;String&gt; sum2)&#123; for(String str : Array)&#123; sum1.andThen(sum2).accept(str); &#125; &#125;&#125; 1.7 Predicate接口Predicate: 常用的四个方法 boolean test(T t): 对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值。 default Predicatenegate: 返回一个逻辑的否定，对应逻辑非 default Predicateand(Predicate other): 返回一个组合判断，对应短路与 default Predicateor(Predicate other): 返回一个组合判断，对应短路或 Predicate接口通常用于判断参数是否满足指定的条件 12345678910111213public class PreducateDemo &#123; public static void main(String[] args) &#123; boolean b1 = checkString(&quot;hello&quot;,s -&gt; s.length()&gt;5); System.out.println(b1); &#125; private static boolean checkString(String s, Predicate&lt;String&gt; pr)&#123; //正常逻辑 //return pr.test(s); //逻辑非 return pr.negate().test(s); &#125;&#125; 1234567891011public class PreductDemo_01 &#123; public static void main(String[] args) &#123; boolean b1 = checkString(&quot;hello&quot;,s -&gt; s.length()&gt;5,s -&gt; s.length()&lt;12); System.out.println(b1); &#125; private static boolean checkString(String s, Predicate&lt;String&gt; pr1,Predicate&lt;String&gt; pr2)&#123; // return pr1.and(pr2).test(s); return pr1.or(pr2).test(s); &#125;&#125; 练习 筛选满足条件的数据 1234567891011121314151617181920public class PreductTest &#123; public static void main(String[] args) &#123; String[] str0 = &#123;&quot;马宏跃,187&quot;,&quot;雷惊讶,160&quot;,&quot;龙宇凡,183&quot;,&quot;张被轮,183&quot;,&quot;李瑞,158&quot;,&quot;卢世文,184&quot;&#125;; ArrayList&lt;String&gt; Str4 = checkString(str0,s -&gt;s.split(&quot;,&quot;)[0].length()&gt;2, s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1])&gt;180); System.out.println(Str4); &#125; private static ArrayList&lt;String&gt; checkString(String[] strArray, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)&#123; ArrayList&lt;String&gt; str1 = new ArrayList&lt;String&gt;(); for(String str2:strArray)&#123; if(pre1.and(pre2).test(str2))&#123; str1.add(str2); &#125; &#125; return str1; &#125;&#125; 1.8 Function接口Funtion&lt;T,R&gt;: 常用的两种方法 R apply(T t): 将此函数应用于给定的参数 default Function andThen(Function after): 返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果 Function&lt;T,R&gt; 函数通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值 12345678910public class FunctionDemo &#123; public static void main(String[] args) &#123; convert(&quot;110&quot;,s -&gt; Integer.parseInt(s)); &#125; private static void convert(String A, Function&lt;String,Integer&gt; fun1)&#123; int i = fun1.apply(A); System.out.println(i); &#125;&#125; 1String ss = fun1.andThen(fun2).apply(s); 练习 按照要求转换 加数字 1234567891011public class FunctionTest &#123; public static void main(String[] args) &#123; String s = &quot;马宏跃,20&quot;; convert(s,ss -&gt; ss.split(&quot;,&quot;)[1],ss -&gt; Integer.parseInt(ss),i -&gt; i+80); &#125; private static void convert(String s, Function&lt;String,String&gt; fun1,Function&lt;String,Integer&gt; fun2,Function&lt;Integer,Integer&gt; fun3)&#123; int i = fun1.andThen(fun2).andThen(fun3).apply(s); System.out.println(i); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"方法引用","slug":"方法引用","date":"2022-03-14T11:30:40.000Z","updated":"2022-03-15T06:42:31.767Z","comments":true,"path":"2022/03/14/方法引用/","link":"","permalink":"http://example.com/2022/03/14/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"1 方法引用1.1体验方法引用![截屏2022-03-14 下午7.33.44](&#x2F;方法引用&#x2F;截屏2022-03-14 下午7.33.44.png) 12345usePrintable(s -&gt; System.out.println(s));//方法引用符 ：：usePrintable(System.out::Println);//可推导就是可以省略的//上面两条语句输出内容相同 1.2方法引用符方法引用符 ::该符号为引用运算符，而它所在的表达式被称为方法引用 推导与省略 如果使用方法引用，和Lambda一样，可以进行上下文进行推导 方法引用是Lambda的孪生兄弟 1.3 Lambda表达式支持的方法引用常见的引用方法 引用类方法 引用对象的实例方法 引用类的实例方法 引用构造器 1.4 引用类方法引用类方法，其实就是引用类的静态方法 格式：类名::静态方法 范例：Integer::parseInt ​ Integer类的方法：public static int parsenInt(String s) 将String转换为int数据类型 练习![截屏2022-03-15 上午9.11.42](&#x2F;方法引用&#x2F;截屏2022-03-15 上午9.11.42.png) 1234接口Converterpublic interface Converter &#123; int convert(String s);&#125; 1234567891011121314测试类ConverterDemo.javapublic class ConverterDemo &#123; public static void main(String[] args) &#123; useConverter(s -&gt; Integer.parseInt(s)); //用引用类方法 useConverter(Integer::parseInt); &#125; private static void useConverter(Converter c)&#123; int number = c.convert(&quot;666&quot;); System.out.println(number); &#125;&#125; Lambda表达式被类方法替代的时候，他的形式参数全部传递给静态方法作为参数 1.5引用对象的实例方法 格式：对象::成员方法 范例：“HelloWorld”::toUpperCase 1usePrinter(s -&gt; Systrm.out.println(s.toUppercase())) 12PrintString ps = new printString();usePrinter(ps::printUpper); Lambda表达式被对象的实例方法替代的时候，他的形式参数全部传递给该方法作为参数 1.6引用类的实例方法 格式：类名::成员方法 范例：String::substring String类中的substring方法 1useMyString((s,x,y) -&gt; s.substring(x,y)); 12//引用类的实例方法useMyString(String::substring); Lambda表达式被类的实例方法替代的时候，第一个参数作为调用者，后面的参数全部传递给该方法作为参数 1.7引用构造器引用构造方法 格式：类名::new 范例：Student::new Student是一个类 1useStudentBuilder((name,age) -&gt; new Student(name,age)); 12//引用构造器useStudentBuilder(Student::new); Lambda表达式被构造器替代时，他的形式参数全部传递给构造器作为参数","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"接口的组成更新","slug":"接口的组成更新","date":"2022-03-14T10:33:49.000Z","updated":"2022-03-14T11:29:42.210Z","comments":true,"path":"2022/03/14/接口的组成更新/","link":"","permalink":"http://example.com/2022/03/14/%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0/","excerpt":"","text":"1.接口的组成更新1.1 接口组成更新概述接口的组成 常量 ​ -public static final 抽象方法 ​ -public abstract 默认方法（Java 8） 静态方法（Java 8） 私有方法（Java 9） 1.2接口中默认方法定义格式 格式：public default 返回值类型 方法名(参数列表){ } 范例：public default void show3(){ } 注意事项 默认方法不是抽象方法，所有不强制被重写，但可以被重写，重写时要去掉default关键字。 public可以被省略，但default不可以被省略。 案例：实际开发中更新接口中的抽象方法，有些不用更新但如果使用此接口就必须写更新的抽象方法，如果创建新的接口来继承上一个接口，这样更新多的话就会使系统变得非常复杂，所有接口中的默认方法可以解决此问题。 1.3接口中的静态方法定义格式 格式：public static 返回值类型 方法名(参数列表){ } 范例：public static void show(){ } 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 1.4接口中私有方法定义格式 格式1：private 返回值类型 方法名(参数列表){ } 范例1：private void show(){ } 格式2：private static 返回值类型 方法名(参数列表){ } 范例2：private static void method(){ } 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只可以调用私有的静态方法 案例：当两个默认方法或者静态方法中含有一段相同的代码，可以将这段相同的代码合成一个私有方法，但是在默认方法或静态方法中可以调用此私有方法避免重复。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Lambdab表达式","slug":"Lambda-方法引用","date":"2022-03-13T10:19:44.000Z","updated":"2022-03-15T06:43:42.662Z","comments":true,"path":"2022/03/13/Lambda-方法引用/","link":"","permalink":"http://example.com/2022/03/13/Lambda-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"1.Lambda表达式1.1 函数式编程思想概述强调做什么，而不是以什么形式去做 1.2 体验Lambda表达式12345678public class LambdaDemo &#123; public static void main(String[] args) &#123; //Lanbda表达式 new Thread(()-&gt;&#123; System.out.println(&quot;多线程程序启动了&quot;); &#125;).start(); &#125;&#125; 1.3 Lambda表达式的标准格式![截屏2022-03-14 上午9.48.26](&#x2F;Lambda-方法引用&#x2F;截屏2022-03-14 上午9.48.26.png) 1.4Lambda表达式练习Lambda表达式使用前提 有一个接口 有且只有一个抽象方法 练习1![截屏2022-03-14 上午10.10.24](&#x2F;Lambda-方法引用&#x2F;截屏2022-03-14 上午10.10.24.png) 1234接口类Eatable.javapublic interface Eatable &#123; void eat();&#125; 123456789101112测试类EatableDemo.javapublic class EatableDemo &#123; public static void main(String[] args) &#123; useEatable(()-&gt;&#123; System.out.println(&quot;一天一苹果，医生远离我&quot;); &#125;); &#125; private static void useEatable(Eatable e)&#123; e.eat(); &#125;&#125; 练习2![截屏2022-03-14 上午10.29.40](&#x2F;Lambda-方法引用&#x2F;截屏2022-03-14 上午10.29.40.png) 1234接口类Addable.javapublic interface Addable &#123; int add(int a,int b);&#125; 12345678910111213测试类AddableDemo.javapublic class AddableDemo &#123; public static void main(String[] args) &#123; useAddable((int x,int y)-&gt;&#123; return x+y; &#125;); &#125; private static void useAddable(Addable a)&#123; int sum = a.add(10,20); System.out.println(sum); &#125;&#125; 相当于在调用useAddable方法是重写的接口中add方法 1.5Lambda省略模式12345参考练习2public static void main(String[] args) &#123; useAddable((int x,int y)-&gt;&#123; return x+y; &#125;); \u0015参数的类型可以省略 但是有多个参数的情况下，不能只省略一个 12参考练习2useAddable((x,y) -&gt; x+y) 如果参数有且仅有一个，那么小括号可以省略 如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 1.6 Lambda表达式的注意事项 使用Lambda必须要有接口，并且要求接口中有且只有一个抽象方法 必须要有上下文环境，才能推导出Lambda表达式对应接口 ​ -局部变量的赋值 ​ -调用方法的参数 1.7 Lambda表达式与匿名内部类的区别匿名内部类 可以说接口，抽象类，具体了 接口中有且只有一个抽象方法可以使用Lambda表达式，也可以使用匿名内部类 编译之后会产生一个单独的.class文件 Lambda表达式 只能是接口 如果接口中多了一个抽象方法就只能使用匿名内部类 编译之后没有单独的.class字节码文件，对应的字节码会在运行的时候动态生成","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"在mac搭建个人博客并且部署到github上","slug":"在mac搭建个人博客并且部署到github上","date":"2022-03-13T08:37:42.000Z","updated":"2022-03-15T08:03:42.731Z","comments":true,"path":"2022/03/13/在mac搭建个人博客并且部署到github上/","link":"","permalink":"http://example.com/2022/03/13/%E5%9C%A8mac%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%94%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/","excerpt":"","text":"MAC搭建博客大体步骤 安装Node.js 安装Git 安装Hexo 本地运行测试 注册github并创建仓库 部署到github中去 1.安装Node.js在终端里运行命令 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 安装后 1brew install node 验证 12node -vnpm -v 有版本号代表成功 更新 123456//单独运行brew updatebrew upgrade nodenpm install -g npm//一条运行brew update &amp;&amp; brew upgrade node &amp;&amp; npm install -g npm 2.安装Git终端里输入 1brew install git 验证 1git --version 3.安装Hexo打开终端 输入 1pwd 看自己所在路径 在&#x2F;Userse&#x2F;你的用户名 输入 1mkdir blog 在输入 1cd blog 进入该文件 在此输入pwd 检查路径是不是在 &#x2F;Userse&#x2F;你的用户名&#x2F;blog 确定的话 输入 12345npm install -g hexo-cli//每条分别输入hexo init//分别输入npm install 本地启动 1234//分别输入hexo g//分别输入hexo s 访问本地链接 http://localhost:4000 这是你会发现一个网址 恭喜你 你已经创建了一个博客了 控制台这时什么都操作不了 按control+c 结束 4.注册github并创建仓库没有就现在注册一个 来得及 自己从网上查 ![截屏2022-03-13 下午5.02.51](&#x2F;在mac搭建个人博客并且部署到github上&#x2F;截屏2022-03-13 下午5.02.51.png) 点 New reposiory ![截屏2022-03-13 下午5.04.05](&#x2F;在mac搭建个人博客并且部署到github上&#x2F;截屏2022-03-13 下午5.04.05.png) 名字严格按照 Name.github.io 创建 我的意见创建过了 所有有感叹号 Name是你github的名字 5.配置SSH并且生成SSH key1ssh-keygen -t rsa -C 你的邮箱 1cd ../../../ 到跟目录 1cd var 1sudo su 输入密码 1cd root 1cd .ssh 1vim id_rsa.pub 把里面的所有东西都复制出来 不要修改 从文件出来 按esc 1:wq 登录Github，右上角 头像 -&gt; Settings —&gt; SSH nd GPG keys —&gt; New SSH key 。把复制的内容粘贴到key中，填好title并点击 Add SSH key 验证一下 1ssh -T git@github.com 出现hello….. 就代表成功 在设置一下 12git config --global user.name your namegit config --global user.email your_email@youremail.com 名字是你git的名字 邮箱是你绑定git邮箱 6.部署到git上1npm install hexo-deployer-git --save 重启终端 1cd blog 1vim _config.yml 找到最底下 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:youname/youname.github.io.git branch: master 修改repo 找到刚刚创建的git仓库 选择ssh 将链接复制到 repo 要有空格 按a进行修改 修改完后按esc 输入 1:wq 最后输入 123hexo cleanhexo ghexo d 部署完成后可在浏览器输入 yourname.github.io 这样就能看到自己一个属于自己的博客了，由于github是属于国外的服务器，访问起来有点慢，你也可以部署到coding中去，步骤类似，如果失败不要灰心 多试几次 多查查资料 我也忙活了一下午才整好 加油 以后上传更新博客 必须要进管理员模式 参考文献https://www.jianshu.com/p/0c545b6f601a https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.-1 https://zhuanlan.zhihu.com/p/111014448","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"Markdown使用介绍","slug":"Markdown使用介绍","date":"2022-03-13T06:45:30.000Z","updated":"2022-03-14T10:10:58.200Z","comments":true,"path":"2022/03/13/Markdown使用介绍/","link":"","permalink":"http://example.com/2022/03/13/Markdown%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一.创建文章进入hexo的文件夹中 hexo n &quot;要取的文章名字&quot; 不要用管理员进行创建 否则没有权限编辑不了文章 这个问题困扰我好久 二.编写文章(1)标题#一级标题 ##二级标题 …… ######六级标题 Typora 快捷键： 一级标题：*（⌘ + 1）* 二级标题：*（⌘ + 2）* 三级标题：*（⌘ + 3）* 四级标题：*（⌘ + 4）* … 六级标题：*（⌘+6）* (2)粗体、斜体、删除线和下划线斜体粗体加粗斜体删除线 下划线 *斜体* **粗体** ***加粗斜体*** ~~删除线~~ Typora 快捷键： （⌘ + i）：斜体 （⌘ + b）：粗体 （^ + ⇧ + &#96;）：删除线（⌘ + u）下划线(3)引用块&gt;文字引用 这个就是一个引用 Typora 快捷键： （⌥ + ⌘ + q） (4)代码块1234`行内代码````多行代码``` Typora 快捷键： （⌘ + ⌥ + c）(5) 公式块123$$数学公式$$ （⌘ + ⌥ + B）(6) 分割线123451.---2.+++3.*** （— + enter 或 ⌘ + ⌥ + -）(7) 列表12345671. 有序列表项* 无序列表项+ 无序列表项- 无序列表项 Typora 快捷键： 有序列表项：（⌥ + ⌘ + o） 无序列表项：（⌥ + ⌘ + u） 任务列表：（⌥ + ⌘ + x） (8) 表格Typora 快捷键： (⌘ + ⌥ + T） (9)超链接12345方法一：[链接文字](链接地址 &quot;链接描述&quot;)例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt; 快捷键：（⌘ + k） (10)插入图片12![图片文字](图片地址 &quot;图片描述&quot;)例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;) （鼠标直接拖拽） hexo博客 1![想输入的提示名字，可不输入](/images/xx.jpg) (11)文章跳转跳转至文章开头（⌘ + 向上箭头）跳转至文章结尾（⌘ + 向下箭头） (12)选中英文单词&#x2F;中文单词选中英文单词或连续的中文 （⌘ + d）选中光标左边英文单词&#x2F;中文 （⌘+⌥+左方向）选中光标左边英文单词&#x2F;中文 （⌘+⌥+右方向） (13)按行选中（⌘ + l）(14)查找替换（⌘ + f）(15)插入表情mac输入 *⌃ + ⌘ + space* 弹出符号对话框 (16)新建文件（⌘ + n）(17)显示和隐藏侧边栏（⇧ + ⌘ + L）(18)标题居中支持html语言 h1表示一级标题，h6表示六级标题 1&lt;h1 align = &quot;center&quot;&gt;居中的标题&lt;h1&gt; (19)文本居中1&lt;div align = &quot;center&quot;&gt;文本居中&lt;/div&gt; 小总结从网上查的文章结合自己使用的写出来的 日后还有补充 方便自己复习看 参考文献https://blog.csdn.net/wsmrzx/article/details/81478945 https://zhuanlan.zhihu.com/p/354088977","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-13T06:28:23.857Z","updated":"2022-03-13T06:33:07.383Z","comments":true,"path":"2022/03/13/hello-world/","link":"","permalink":"http://example.com/2022/03/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating ssDeploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://example.com/tags/Mybatis/"},{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"Java-Spring","slug":"Java-Spring","permalink":"http://example.com/tags/Java-Spring/"},{"name":"小程序","slug":"小程序","permalink":"http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"},{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"},{"name":"英语","slug":"英语","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"算法题","slug":"算法题","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"计算机系统基础","slug":"计算机系统基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]}