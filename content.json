{"meta":{"title":"mhy-blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2022-03-29T01:43:16.362Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-03-29T01:43:16.389Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-29T01:43:16.403Z","updated":"2022-03-25T10:27:57.833Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-03-29T01:43:16.416Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-29T01:43:16.376Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2022-03-29T01:43:16.348Z","updated":"2022-03-25T10:27:57.833Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"标签","date":"2022-03-29T01:43:16.429Z","updated":"2022-03-25T10:27:57.834Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Servleat&HTTP&Request","slug":"Servleat-HTTP-Request","date":"2022-04-09T05:32:51.000Z","updated":"2022-04-10T09:19:25.447Z","comments":true,"path":"2022/04/09/Servleat-HTTP-Request/","link":"","permalink":"http://example.com/2022/04/09/Servleat-HTTP-Request/","excerpt":"","text":"Servlet： 概念 步骤 执行原理 生命周期 Servlet3.0 注解配置 Servlet的体系结构 12345Servlet -- 接口 |GenericServlet -- 抽象类 |HttpServlet -- 抽象类 GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可 HttpServlet：对http协议的一种封装，简化操作 定义类继承HttpServlet 复写doGet&#x2F;doPost方法 Servlet相关配置 urlpartten:Servlet访问路径 一个Servlet可以定义多个访问路径 ： @WebServlet({“&#x2F;d4”,”&#x2F;dd4”,”&#x2F;ddd4”}) 路径定义规则： &#x2F;xxx：路径匹配 &#x2F;xxx&#x2F;xxx:多层路径，目录结构 *.do：扩展名匹配 HTTP： 概念：Hyper Text Transfer Protocol 超文本传输协议 传输协议：定义了，客户端和服务器端通信时，发送数据的格式 特点： 基于TCP&#x2F;IP的高级协议 默认端口号:80 基于请求&#x2F;响应模型的:一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 历史版本： 1.0：每一次请求响应都会建立新的连接 1.1：复用连接 请求消息数据格式 请求行 12请求方式 请求url 请求协议/版本GET /login.html HTTP/1.1 请求方式： HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求头：客户端浏览器告诉服务器一些信息 请求头名称: 请求头值 ​ 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？ 作用： 防盗链： 统计工作： 请求空行 空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)： 封装POST请求消息的请求参数的 字符串格式： 1234567891011POST /login.html HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://localhost/login.html Connection: keep-alive Upgrade-Insecure-Requests: 1 username=zhangsan 响应消息数据格式 Request： request对象和response对象的原理 request和response对象是由服务器创建的。我们来使用它们 request对象是来获取请求消息，response对象是来设置响应消息 request对象继承体系结构： 12345ServletRequest -- 接口 | 继承HttpServletRequest -- 接口 | 实现org.apache.catalina.connector.RequestFacade 类(tomcat) request功能： 获取请求消息数据 获取请求行数据 GET &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1 方法： 获取请求方式 ：GET String getMethod() (*)获取虚拟目录：&#x2F;day14 String getContextPath() 获取Servlet路径: &#x2F;demo1 String getServletPath() 获取get方式请求参数：name&#x3D;zhangsan String getQueryString() (*)获取请求URI：&#x2F;day14&#x2F;demo1 String getRequestURI(): &#x2F;day14&#x2F;demo1 StringBuffer getRequestURL() :http://localhost/day14/demo1 URL:统一资源定位符 ： http://localhost/day14/demo1 中华人民共和国 URI：统一资源标识符 : &#x2F;day14&#x2F;demo1 共和国 获取协议及版本：HTTP&#x2F;1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr() 获取请求头数据 方法： (*)String getHeader(String name):通过请求头的名称获取请求头的值 &#96;&#96;&#96;Enumeration getHeaderNames():获取所有的请求头名称 123456789101112131415161718192021 3. 获取请求体数据: - 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 - 步骤： 1. 获取流对象 - BufferedReader getReader()：获取字符输入流，只能操作字符数据 - ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 - 在文件上传知识点后讲解 2. 再从流对象中拿数据2. 其他功能： 1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 1. String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game 3. ``` Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数 名称 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题： get方式：tomcat 8 已经将get方式乱码问题解决了 post方式：会乱码 解决：在获取参数前，设置request的编码request.setCharacterEncoding(“utf-8”); 请求转发：一种在服务器内部的资源跳转方式 步骤： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中。 转发是一次请求 共享数据： 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj):存储数据 Object getAttitude(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContext： ServletContext getServletContext() 案例：用户登录 用户登录案例需求： 编写login.html登录页面 username &amp; password 两个输入框 使用Druid数据库连接池技术,操作mysql，day14数据库中user表 使用JdbcTemplate技术封装JDBC 登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 分析 开发步骤 创建项目，导入html页面，配置文件，jar包 创建数据库环境 12345678CREATE DATABASE day14; USE day14; CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32) UNIQUE NOT NULL, PASSWORD VARCHAR(32) NOT NULL ); 创建包cn.itcast.domain,创建类User 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.itcast.domain; /** * 用户的实体类 */ public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; &#125; 创建包cn.itcast.util,编写工具类JDBCUtils 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast.util; import com.alibaba.druid.pool.DruidDataSourceFactory; import javax.sql.DataSource; import javax.xml.crypto.Data; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.SQLException; import java.util.Properties; /** * JDBC工具类 使用Durid连接池 */ public class JDBCUtils &#123; private static DataSource ds ; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; &#125; 创建包cn.itcast.dao,创建类UserDao,提供login方法 123456789101112131415161718192021222324252627282930313233343536package cn.itcast.dao; import cn.itcast.domain.User; import cn.itcast.util.JDBCUtils; import org.springframework.dao.DataAccessException; import org.springframework.jdbc.core.BeanPropertyRowMapper; import org.springframework.jdbc.core.JdbcTemplate; /** * 操作数据库中User表的类 */ public class UserDao &#123; //声明JDBCTemplate对象共用 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); /** * 登录方法 * @param loginUser 只有用户名和密码 * @return user包含用户全部数据,没有查询到，返回null */ public User login(User loginUser)&#123; try &#123; //1.编写sql String sql = &quot;select * from user where username = ? and password = ?&quot;; //2.调用query方法 User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; &#125; catch (DataAccessException e) &#123; e.printStackTrace();//记录日志 return null; &#125; &#125; &#125; 编写cn.itcast.web.servlet.LoginServlet类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package cn.itcast.web.servlet; import cn.itcast.dao.UserDao; import cn.itcast.domain.User; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(&quot;/loginServlet&quot;) public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(&quot;utf-8&quot;); //2.获取请求参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null)&#123; //登录失败 req.getRequestDispatcher(&quot;/failServlet&quot;).forward(req,resp); &#125;else&#123; //登录成功 //存储数据 req.setAttribute(&quot;user&quot;,user); //转发 req.getRequestDispatcher(&quot;/successServlet&quot;).forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125; &#125; 编写FailServlet和SuccessServlet类 12345678910111213141516171819202122232425262728293031@WebServlet(&quot;/successServlet&quot;) public class SuccessServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //获取request域中共享的user对象 User user = (User) request.getAttribute(&quot;user&quot;); if(user != null)&#123; //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录成功！&quot;+user.getUsername()+&quot;,欢迎您&quot;); &#125; &#125; @WebServlet(&quot;/failServlet&quot;) public class FailServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //给页面写一句话 //设置编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //输出 response.getWriter().write(&quot;登录失败，用户名或密码错误&quot;); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125; &#125; login.html中form表单的action路径的写法 虚拟目录+Servlet的资源路径 BeanUtils工具类，简化数据封装 用于封装JavaBean的 JavaBean：标准的Java类 要求： 类必须被public修饰 必须提供空参的构造器 成员变量必须使用private修饰 提供公共setter和getter方法 功能：封装数据 概念： 成员变量： 属性：setter和getter方法截取后的产物 例如：getUsername() –&gt; Username–&gt; username 方法： setProperty() getProperty() populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"Tomcat&Servlet","slug":"Tomcat-Servlet","date":"2022-04-08T01:11:56.000Z","updated":"2022-04-08T15:30:57.605Z","comments":true,"path":"2022/04/08/Tomcat-Servlet/","link":"","permalink":"http://example.com/2022/04/08/Tomcat-Servlet/","excerpt":"","text":"web相关概念回顾 软件架构 C&#x2F;S：客户端&#x2F;服务器端 B&#x2F;S：浏览器&#x2F;服务器端 资源分类 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析 如： html,css,JavaScript 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器 如：servlet&#x2F;jsp,php,asp…. 网络通信三要素 IP：电子设备(计算机)在网络中的唯一标识。 端口：应用程序在计算机中的唯一标识。 0~65536 传输协议：规定了数据传输的规则 基础协议： tcp:安全协议，三次握手。 速度稍慢 udp：不安全协议。 速度快 web服务器软件： 服务器：安装了服务器软件的计算机 服务器软件：接收用户的请求，处理请求，做出响应 web服务器软件：接收用户的请求，处理请求，做出响应。 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目 web容器 常见的java相关的web服务器软件： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet&#x2F;jsp。开源的，免费的。 JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范 Tomcat：web服务器软件 下载：http://tomcat.apache.org/ 安装：解压压缩包即可。 注意：安装目录建议不要有中文和空格 卸载：删除目录就行了 启动： bin&#x2F;startup.bat ,双击运行该文件即可 访问：浏览器输入：http://localhost:8080 回车访问自己 http:&#x2F;&#x2F;别人的ip:8080 访问别人 可能遇到的问题： 黑窗口一闪而过： 原因： 没有正确配置JAVA_HOME环境变量 解决方案：正确配置JAVA_HOME环境变量 启动报错： 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程 netstat -ano 温柔：修改自身的端口号 conf&#x2F;server.xml 123&lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8445&quot; /&gt; 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。 好处：在访问时，就不用输入端口号 关闭： 正常关闭： bin&#x2F;shutdown.bat ctrl+c 强制关闭： 点击启动窗口的× 配置: 部署项目的方式： 直接将项目放到webapps目录下即可。 &#x2F;hello：项目的访问路径–&gt;虚拟目录 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩 配置conf&#x2F;server.xml文件 12在&lt;Host&gt;标签体中配置 &lt;Context docBase=&quot;D:\\hello&quot; path=&quot;/hehe&quot; /&gt; docBase:项目存放的路径 path：虚拟目录 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 1&lt;Context docBase=&quot;D:\\hello&quot; /&gt; 虚拟目录：xml文件的名称 静态项目和动态项目： 目录结构 java动态项目的目录结构： 12345-- 项目的根目录 -- WEB-INF目录： -- web.xml：web项目的核心配置文件 -- classes目录：放置字节码文件的目录 -- lib目录：放置依赖的jar包 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。 Servlet： server applet 概念：运行在服务器端的小程序 Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。 将来我们自定义一个类，实现Servlet接口，复写方法。 快速入门： 创建JavaEE项目 定义一个类，实现Servlet接口 public class ServletDemo1 implements Servlet 实现接口中的抽象方法 配置Servlet 1234567891011在web.xml中配置： &lt;!--配置Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 执行原理： 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。 1233. ``` 如果有，则在找到对应的&lt;servlet-class&gt;全类名 tomcat会将字节码文件加载进内存，并且创建其对象 调用其方法 Servlet中的生命周期方法： 被创建：执行init方法，只执行一次 Servlet什么时候被创建？ 默认情况下，第一次被访问时，Servlet被创建 可以配置执行Servlet的创建时机。 &#96;&#96;&#96;在标签下配置123451. 第一次被访问时，创建 - ``` &lt;load-on-startup&gt;的值为负数 在服务器启动时，创建 &#96;&#96;&#96;的值为0或正整数1234567891011121314151617181920212223242526272829303132 - Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的 - 多个用户同时访问时，可能存在线程安全问题。 - 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值 2. 提供服务：执行service方法，执行多次 - 每次访问Servlet时，Service方法都会被调用一次。 3. 被销毁：执行destroy方法，只执行一次 - Servlet被销毁时执行。服务器关闭时，Servlet被销毁 - 只有服务器正常关闭时，才会执行destroy方法。 - destroy方法在Servlet被销毁之前执行，一般用于释放资源- Servlet3.0： - 好处： - 支持注解配置。可以不需要web.xml了。 - 步骤： 1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml 2. 定义一个类，实现Servlet接口 3. 复写方法 4. 在类上使用@WebServlet注解，进行配置 @WebServlet(“资源路径”) @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface WebServlet { String name() default “”;&#x2F;&#x2F;相当于 String[] value() default &#123;&#125;;//代表urlPatterns()属性配置 String[] urlPatterns() default &#123;&#125;;//相当于&lt;url-pattern&gt; int loadOnStartup() default -1;//相当于&lt;load-on-startup&gt; WebInitParam[] initParams() default &#123;&#125;; boolean asyncSupported() default false; String smallIcon() default &quot;&quot;; String largeIcon() default &quot;&quot;; String description() default &quot;&quot;; String displayName() default &quot;&quot;; &#125; &#96;&#96;&#96; IDEA与tomcat的相关配置 IDEA会为每一个tomcat部署的项目单独建立一份配置文件 查看控制台的log：Using CATALINA_BASE: “C:\\Users\\fqy.IntelliJIdea2018.1\\system\\tomcat_itcast” 工作空间项目 和 tomcat部署的web项目 tomcat真正访问的是“tomcat部署的web项目”，”tomcat部署的web项目”对应着”工作空间项目” 的web目录下的所有资源 WEB-INF目录下的资源不能被浏览器直接访问。 断点调试：使用”小虫子”启动 dubug 启动","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"xml","slug":"xml","date":"2022-04-07T00:52:36.000Z","updated":"2022-04-07T15:36:56.924Z","comments":true,"path":"2022/04/07/xml/","link":"","permalink":"http://example.com/2022/04/07/xml/","excerpt":"","text":"XML: 概念：Extensible Markup Language 可扩展标记语言 可扩展：标签都是自定义的。 1&lt;user&gt; &lt;student&gt; 功能 存储数据 配置文件 在网络中传输 xml与html的区别 xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 w3c:万维网联盟 语法： 基本语法： xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 123456789101112131415&lt;?xml version=&#x27;1.0&#x27; ?&gt; &lt;users&gt; &lt;user id=&#x27;1&#x27;&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id=&#x27;2&#x27;&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分： 文档声明 格式： 1&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 指令(了解)：结合css的 &#96;&#96;&#96; 12345678910111213141516171819- 标签：标签名称自定义的 - 规则： - 名称可以包含字母、数字以及其他的字符 - 名称不能以数字或者标点符号开始 - 名称不能以字母 xml（或者 XML、Xml 等等）开始 - 名称不能包含空格 - 属性： - id属性值唯一- 文本： - CDATA区：在该区域中的数据会被原样展示 - ``` 格式： &lt;![CDATA[ 数据 ]]&gt; 约束：规定xml文档的书写规则 作为框架的使用者(程序员)： 能够在xml中引入约束文档 能够简单的读懂约束文档 分类： DTD:一种简单的约束技术 Schema:一种复杂的约束技术 DTD: 引入dtd文档到xml文档中 内部dtd：将约束规则定义在xml文档中 外部dtd：将约束的规则定义在外部的dtd文件中 &#96;&#96;&#96;本地：123- ``` 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; Schema: 引入： 填写xml文档的根元素 引入xsi前缀. 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 引入xsd文件命名空间. 1xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot; 为每一个xsd约束声明一个前缀,作为标识 1xmlns=&quot;http://www.itcast.cn/xml&quot; 123&lt;students xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itcast.cn/xml&quot; xsi:schemaLocation=&quot;http://www.itcast.cn/xml student.xsd&quot;&gt; 解析：操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式： DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见的解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 快速入门： 步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 代码 12345678910111213//2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.获取元素对象 Element Elements elements = document.getElementsByTag(&quot;name&quot;); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); 对象的使用： Jsoup：工具类，可以解析html或xml文档，返回Document parse：解析html或xml文档，返回Document parse(File in, String charsetName)：解析xml或html文件的。 parse(String html)：解析xml或html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树 获取Element对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。 1可以当做 ArrayList&lt;Element&gt;来使用 Element：元素对象 获取子元素对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) Node：节点对象 是Document和Element的父类 快捷查询方式： selector:选择器 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 查询w3cshool参考手册，使用xpath的语法完成查询 代码 12345678910111213141516171819202122232425262728293031323334353637//1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath(); //2.获取Document对象 Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); &#125; System.out.println(&quot;--------------------&quot;); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&#x27;itcast&#x27;]&quot;); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); &#125;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"BootStrap","slug":"BootStrap","date":"2022-04-06T07:38:24.000Z","updated":"2022-04-06T14:44:10.231Z","comments":true,"path":"2022/04/06/BootStrap/","link":"","permalink":"http://example.com/2022/04/06/BootStrap/","excerpt":"","text":"Bootstrap： 概念：一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。 好处： 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。 响应式布局。 同一套页面可以兼容不同分辨率的设备。 快速入门 下载Bootstrap 在项目中将这三个文件夹复制 创建html页面，引入必要的资源文件 1dayd 响应式布局 同一套页面可以兼容不同分辨率的设备。 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子 步骤： 定义容器。相当于之前的table、 容器分类： container：两边留白 container-fluid：每一种设备都是100%宽度 定义行。相当于之前的tr 样式：row 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目 设备代号： xs：超小屏幕 手机 (&lt;768px)：col-xs-12 sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 注意： 一行中如果格子数目超过12，则超出部分自动换行。 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。 CSS样式和JS插件文档：https://v3.bootcss.com/css/#forms 全局CSS样式： 按钮：class&#x3D;”btn btn-default” 图片： class&#x3D;”img-responsive”：图片在任意尺寸都占100% 图片形状 1&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;：方形 1&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt; ： 圆形 1&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt; ：相框 表格 table table-bordered table-hover 表单 给表单项添加：class&#x3D;”form-control” 组件： 导航条 分页条 插件： 轮播图 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap HelloWorld&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .paddtop&#123; padding-top: 10px; &#125; .search-btn&#123; float: left; border:1px solid #ffc900; width: 90px; height: 35px; background-color:#ffc900 ; text-align: center; line-height: 35px; margin-top: 15px; &#125; .search-input&#123; float: left; border:2px solid #ffc900; width: 400px; height: 35px; padding-left: 5px; margin-top: 15px; &#125; .jx&#123; border-bottom: 2px solid #ffc900; padding: 5px; &#125; .company&#123; height: 40px; background-color: #ffc900; text-align: center; line-height:40px ; font-size: 8px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1.页眉部分--&gt; &lt;header class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img src=&quot;img/top_banner.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;img src=&quot;img/logo.jpg&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-md-5&quot;&gt; &lt;input class=&quot;search-input&quot; placeholder=&quot;请输入线路名称&quot;&gt; &lt;a class=&quot;search-btn&quot; href=&quot;#&quot;&gt;搜索&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;img src=&quot;img/hotel_tel.png&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--导航栏--&gt; &lt;div class=&quot;row&quot;&gt; &lt;nav class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;!-- 定义汉堡按钮 --&gt; &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#bs-example-navbar-collapse-1&quot; aria-expanded=&quot;false&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;Toggle navigation&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;bs-example-navbar-collapse-1&quot;&gt; &lt;ul class=&quot;nav navbar-nav&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Link &lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt; &lt;/nav&gt; &lt;/div&gt; &lt;!--轮播图--&gt; &lt;div class=&quot;row&quot;&gt; &lt;div id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot;&gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;2&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img src=&quot;img/banner_1.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/banner_2.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;img src=&quot;img/banner_3.jpg&quot; alt=&quot;...&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;!-- 2.主体部分--&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row jx&quot;&gt; &lt;img src=&quot;img/icon_5.jpg&quot;&gt; &lt;span&gt;黑马精选&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row jx&quot;&gt; &lt;img src=&quot;img/icon_6.jpg&quot;&gt; &lt;span&gt;国内游&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;row paddtop&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;img src=&quot;img/guonei_1.jpg&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-md-8&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-4&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 3.页脚部分--&gt; &lt;footer class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;img src=&quot;img/footer_service.png&quot; class=&quot;img-responsive&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row company&quot;&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882 &lt;/div&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"四级词汇7-12串词","slug":"四级词汇7-12串词","date":"2022-04-05T03:30:39.000Z","updated":"2022-04-10T09:44:21.284Z","comments":true,"path":"2022/04/05/四级词汇7-12串词/","link":"","permalink":"http://example.com/2022/04/05/%E5%9B%9B%E7%BA%A7%E8%AF%8D%E6%B1%877-12%E4%B8%B2%E8%AF%8D/","excerpt":"","text":"第7串词：-ageage n.年龄；时代 v.变老 Stan Age 石器时代 People age 人是会衰老的 aging n.老化；老龄化 aging process 衰老过程 average adj.平均的；普通的 n.平均；平均数manage v.管理；勉强完成 man- &#x3D; hand(手) management n.管理advantage n.优势；利益 advance- &#x3D; 前进的 take advantage of sth&#x2F;sb 占便宜&#x2F;充分利用 disadvantage n.缺点；不利条件damage n.损害 v.损毁message n.消息 v.发消息 mess-&#x2F;miss- &#x3D; to send (送), to throw (投) text me 编短信 marriage n.婚姻wage n.工资（周薪） wage：（按周发钱） salary：（按月发钱） income：（收入，所得） image n.影像；想像 v.想象；反映；象征 public image 公众形象 package n.包裹 v.打包luggage n.行李（英）baggage n.行李（美）shortage n.缺乏；不足stage n.舞台；阶段第8串词：techn （art&#x2F;skill 技艺&#x2F;技术）technology n.科技；技术 -ology 名词结尾 technological adj.科技的；工艺的；技术的 -cal 形容词词尾 technique n.技巧；技术technical adj.技能的；专门技术的technician n.技术员第9串词：fer(to carry 拿来，to bring 带来)offer v.提供 n.工作邀请 of-：朝向 refer v.查阅；参考；提及 refer to A as B：把A称作B reference n.参考differ v.不同于（&#x3D; be different） di-：away 分开 indifferent adj.漠不关心 an indifferent society 一个冷漠的社会 in-：not 不 prefer v.较喜欢 pre- ：before 先 preschool adj.学龄前的 prehistory n.史前时代 preference n.偏爱；偏好suffer v.受苦；遭受… sub-（suc-,suf-,sug-,sum-,sup-,sur-,sus-）&#x3D; under 在下面 conference n.会议 con-：共同，一起 -ence：名词结尾 meeting 碰头会 infer v.推断 in-：向内，里面 interfere v.干涉 inter-：between&#x2F;among 在…之间 interfere in 某人进入情况内部“插手” interfere with 人或物“影响” interference n.干涉transfer v.转学，调用；转移 trans-：across 转移，贯穿 从A到B 读音不同词性不同 名前动后 n.转移；换乘 transfer station 换乘站 第10串词：lead（引导，领导） leader n.领导者 lead v.领导；导致；n.领先地位 lead to 引发 took&#x2F;lost the lead 领先&#x2F;落后 leading adj.最重要的；领先的（&#x3D;top） leadership adj.最重要的；领先的 mislead v.误导 mis-：错误的，不好的 misleading adj.误导的 第11串词： economy n.经济；节约 a market economy 市场经济 economic adj.经济上的；经济学的 economical adj.省钱的 economics n.经济学 economist n.经济学者 economically adv.经济上地 support sb economically 经济上支持某人 第12串词： 所以词都可以加economic crisis n.危机 an economic crisis 一次经济危机 decline n.下降；衰退 v.下降；衰退；婉拒 a rapid decline 迅速下降 refuse&#x2F;decline his help 断然拒绝&#x2F;谢绝他的帮助 recession n.经济衰退 re- ：回，向后 -cess ：行走 depression n.抑郁；萧条期 de-：向下 press-：压，压制 fall v.落下；减少 n.衰退；瀑布；秋天 downturn n.(商业经济)的衰退","categories":[],"tags":[{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"}]},{"title":"Javascript高级","slug":"Javascript高级","date":"2022-04-04T10:22:35.000Z","updated":"2022-04-06T02:44:07.863Z","comments":true,"path":"2022/04/04/Javascript高级/","link":"","permalink":"http://example.com/2022/04/04/Javascript%E9%AB%98%E7%BA%A7/","excerpt":"","text":"DOM简单学习：为了满足案例要求 功能：控制html文档的内容 获取页面标签(元素)对象：Element document.getElementById(“id值”):通过元素的id获取元素对象 操作Element对象： 修改属性值： 明确获取的对象是哪一个？ 查看API文档，找其中有哪些属性可以设置 修改标签体内容： 属性：innerHTML 获取元素对象 使用innerHTML属性修改标签体内容 事件简单学习 功能：某些组件被执行了某些操作后，触发某些代码的执行。 造句：xxx被xxx,我就xxx 我方水晶被摧毁后，我就责备对友。 敌方水晶被摧毁后，我就夸奖自己。 如何绑定事件 直接在html标签上，指定事件的属性(操作)，属性值就是js代码 事件：onclick— 单击事件 通过js获取元素对象，指定事件属性，设置一个函数 代码1234567891011121314151617181920&lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot; onclick=&quot;fun();&quot;&gt; &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt; &lt;script&gt; function fun()&#123; alert(&#x27;我被点了&#x27;); alert(&#x27;我又被点了&#x27;); &#125; function fun2()&#123; alert(&#x27;咋老点我？&#x27;); &#125; //1.获取light2对象 var light2 = document.getElementById(&quot;light2&quot;); //2.绑定事件 light2.onclick = fun2; &lt;/script&gt; &lt;/body&gt; 案例1:电灯开关 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;电灯开关&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt; &lt;script&gt; /* 分析： 1.获取图片对象 2.绑定单击事件 3.每次点击切换图片 * 规则： * 如果灯是开的 on,切换图片为 off * 如果灯是关的 off,切换图片为 on * 使用标记flag来完成 */ //1.获取图片对象 var light = document.getElementById(&quot;light&quot;); var flag = false;//代表灯是灭的。 off图片 //2.绑定单击事件 light.onclick = function()&#123; if(flag)&#123;//判断如果灯是开的，则灭掉 light.src = &quot;img/off.gif&quot;; flag = false; &#125;else&#123; //如果灯是灭的，则打开 light.src = &quot;img/on.gif&quot;; flag = true; &#125; &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; BOM: 概念：Browser Object Model 浏览器对象模型 将浏览器的各个组成部分封装成对象。 组成： Window：窗口对象 Navigator：浏览器对象 Screen：显示器屏幕对象 History：历史记录对象 Location：地址栏对象 Window：窗口对象 创建 不需要创建 方法 与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。 返回值：获取用户输入的值 与打开关闭有关的方法： close() 关闭浏览器窗口。 谁调用我 ，我关谁 open() 打开一个新的浏览器窗口 返回新的Window对象 与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。 参数： js代码或者方法对象 毫秒值 返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。 setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。 属性： 获取其他BOM对象： history location Navigator Screen: 获取DOM对象 document 特点 Window对象不需要创建可以直接使用 window使用。 window.方法名(); window引用可以省略。 方法名(); Location：地址栏对象 创建(获取)： window.location location 方法： reload() 重新加载当前文档。刷新 属性 href 设置或返回完整的 URL。 History：历史记录对象 创建(获取)： window.history history 方法： back() 加载 history 列表中的前一个 URL。 forward() 加载 history 列表中的下一个 URL。 go(参数) 加载 history 列表中的某个具体页面。 参数： 正数：前进几个历史记录 负数：后退几个历史记录 属性： length 返回当前窗口历史列表中的 URL 数量。 DOM： 概念： Document Object Model 文档对象模型 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作 W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 Document：文档对象 Element：元素对象 Attribute：属性对象 Text：文本对象 Comment:注释对象 Node：节点对象，其他5个的父对象 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 核心DOM模型： Document：文档对象 创建(获取)：在html dom模型中可以使用window对象来获取 window.document document 方法： 获取Element对象： getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一 getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组 getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组 getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组 创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode() 属性 Element：元素对象 获取&#x2F;创建：通过document来获取和创建 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node：节点对象，其他5个的父对象 特点：所有dom对象都可以被认为是一个节点 方法： CRUD dom树： appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild() ：删除（并返回）当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 属性： parentNode 返回节点的父节点。 HTML DOM 标签体的设置和获取：innerHTML 使用html元素对象的属性 控制元素样式 使用元素的style属性来设置 123456如： //修改样式方式1 div1.style.border = &quot;1px solid red&quot;; div1.style.width = &quot;200px&quot;; //font-size--&gt; fontSize div1.style.fontSize = &quot;20px&quot;; 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。 事件监听机制： 概念：某些组件被执行了某些操作后，触发某些代码的执行。 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了 事件源：组件。如： 按钮 文本输入框… 监听器：代码。 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。 常见的事件： 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件 onblur：失去焦点 一般用于表单校验 onfocus:元素获得焦点。 加载事件： onload：一张页面或一幅图像完成加载。 鼠标事件： onmousedown 鼠标按钮被按下。 定义方法时，定义一个形参，接受event对象 event对象的button属性可以获取鼠标那个键被点击了 onmouseup 鼠标按键被松开。 onmousemove 鼠标被移动。 onmouseover 鼠标移到某元素之上。 onmouseout 鼠标从某元素移开。 键盘事件： onkeydown 某个键盘按键被按下。 onkeyup 某个键盘按键被松开。 onkeypress 某个键盘按键被按下并松开。 选择和改变 onchange 域的内容被改变。 onselect 文本被选中。 表单事件： onsubmit 确认按钮被点击。 可以阻止表单的提交 方法返回false onreset 重置按钮被点击。","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"2012年c B组省赛真题","slug":"2012年c-B组省赛真题","date":"2022-04-04T03:12:11.000Z","updated":"2022-04-04T10:20:09.831Z","comments":true,"path":"2022/04/04/2012年c-B组省赛真题/","link":"","permalink":"http://example.com/2022/04/04/2012%E5%B9%B4c-B%E7%BB%84%E7%9C%81%E8%B5%9B%E7%9C%9F%E9%A2%98/","excerpt":"","text":"第一题：微生物增殖题目描述假设有两种微生物X和Y，X出生后每隔3分钟分裂一次（数目加倍），Y出生后每隔2分钟分裂一次（数目加倍）。一个新出生的X，半分钟之后吃掉1个Y，且从此开始每隔1分钟吃掉1个Y。已知新出生的X&#x3D;10，Y&#x3D;89，求60分钟后Y的数目。若X&#x3D;10，Y&#x3D;90呢？本题的要求就是写出这两种初始条件下，60分钟后Y的数目。题目的结果令你震惊吗？这不是简单的数字游戏！真实的生物圈有着同样脆弱的性质！也许因为你消灭的那只Y就是最终导致Y种群灭绝的最后一根稻草！ 题目分析通过画表格得知 时间 0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 X 10 10(吃Y) 10 10(吃Y) 10 10(吃Y) 20(分裂) 20(新生的和以前的X都吃Y) 20 20（吃Y） 从上面表格可以分析出不论是新出生的还是以前的X,都是每半分钟进行吃Y的操作，每3分钟进行一次分裂，故这题的操作如下在60分钟内进行判断： 1.如果为每个0.5分钟 Y&#x3D;Y-X2.如果为每个3分钟 X*&#x3D;23.如果为每个2分钟 Y*&#x3D;2 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; long long x = 10; long long y = 89; for(int i = 1;i &lt;= 120 ;i++)&#123; if( i % 2 == 1)&#123; y = y - x; &#125; if( i % 4 == 0)&#123; y = y * 2; &#125; if( i % 6 == 0)&#123; x = x * 2; &#125; &#125; cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; endl &lt;&lt; &quot;y=&quot; &lt;&lt; y &lt;&lt; endl; return 0;&#125; 结果 12x = 10485760y = -979369984//表示微生物Y为0,灭绝 第二题：古堡算式题目描述福尔摩斯到某古堡探险，看到门上写着一个奇怪的算式：ABCDE*?&#x3D;EDCBA。他对华生说：“ABCDE应该代表不同的数字，问号也代表某个数字！” 华生：“我猜也是！”，于是，两人沉默了好久，还是没有算出合适的结果来。 请你利用计算机的优势，找到破解的答案，把ABCDE所代表的数字写出来。 题目分析使用numArray数组的前6个数分别表示ABCDE和？,最后判断条件即可。暴力杯的由来，暴力枚举所有可能，这里用的可能跟其他不一样，使用next_permutation()函数 函数参考文献：函数用法 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int main()&#123; int arraynumber[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; while(next_permutation(arraynumber,arraynumber+10))&#123; if(arraynumber[0] != 0&amp;&amp; arraynumber[4] != 0)&#123; int leftnum = arraynumber[0]*10000 + arraynumber[1]*1000 + arraynumber[2]*100 + arraynumber[3]*10 + arraynumber[4]; int rightnum = arraynumber[4]*10000 + arraynumber[3]*1000 + arraynumber[2]*100 + arraynumber[1]*10 + arraynumber[0]; int temp = arraynumber[5]; if(leftnum * temp == rightnum)&#123; cout &lt;&lt; arraynumber[0] &lt;&lt; arraynumber[1] &lt;&lt; arraynumber[2] &lt;&lt; arraynumber[3] &lt;&lt; arraynumber[4] &lt;&lt; endl &lt;&lt; &quot;?=&quot; &lt;&lt; arraynumber[5]; break; &#125; &#125; &#125; return 0;&#125; 结果 1221978?=4% 第三题：比酒量题目描述有一群海盗（不多于20人），在船上比拼酒量。过程如下：打开一瓶酒，所有在场的人平分喝下，有几个人倒下了。再打开一瓶酒平分，又有倒下的，再次重复—-直到开了第4瓶酒，坐着的已经所剩无几，海盗船长也在其中。当第4瓶酒平分喝下后，大家都倒下了。等船长醒来，发现海盗船搁浅了。他在航海日志中写到：“…昨天，我正好喝了一瓶…奉劝大家，开船不喝酒，喝酒别开船…”请你根据这些信息，推断开始有多少人，每一轮喝下来还剩多少人。如果有多个可能的答案，请列出所有答案，每个答案占一行。格式是：人数，人数，…例如，有一种可能是：20,5,4,2,0 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main()&#123; int i,j,k,l,m; //i为总人数 for(i=20;i&gt;0;i--)&#123; //j为第一次剩余的人，第一次至少倒下一人 for(j=i-1;j&gt;0;j--)&#123; //k为第二次剩余的人，第二次至少又倒下一人，...... for(k=j-1;k&gt;0;k--)&#123; for(m=k-1;m&gt;0;m--)&#123; if((1.0/i + 1.0/j + 1.0/k + 1.0/m) == 1) cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot;&lt;&lt;&quot;0&quot; &lt;&lt; endl; &#125; &#125; &#125; &#125; return 0;&#125; 结果 123420 5 4 2 018 9 3 2 015 10 3 2 012 6 4 2 0","categories":[],"tags":[{"name":"算法题","slug":"算法题","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2022-04-02T09:42:26.000Z","updated":"2022-04-04T03:06:45.946Z","comments":true,"path":"2022/04/02/JavaScript/","link":"","permalink":"http://example.com/2022/04/02/JavaScript/","excerpt":"","text":"JavaScript： 概念：一门客户端脚本语言 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎 脚本语言：不需要编译，直接就可以被浏览器解析执行了 功能 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。 JavaScript发展史： 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C– ，后来更名为：ScriptEase 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript 1996年，微软抄袭JavaScript开发出JScript语言 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。 JavaScript &#x3D; ECMAScript + JavaScript自己特有的东西(BOM+DOM) ECMAScript：客户端脚本语言的标准 基本语法： 与html结合方式 内部JS： 1定义&lt;script&gt;，标签体内容就是js代码 外部JS： 1定义&lt;script&gt;，通过src属性引入外部的js文件 注意 121. &lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。2. &lt;script&gt;可以定义多个。 注释 121. 单行注释：//注释内容2. 多行注释：/*注释内容*/ 数据类型： 原始数据类型(基本数据类型)： number：数字。 整数&#x2F;小数&#x2F;NaN(not a number 一个不是数字的数字类型) string：字符串。 字符串 “abc” “a” ‘abc’ boolean: true和false null：一个对象为空的占位符 undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined 引用数据类型：对象 变量 变量：一小块存储数据的内存空间 Java语言是强类型语言，而JavaScript是弱类型语言。 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 语法： var 变量名 &#x3D; 初始化值; typeof运算符：获取变量的类型。 注：null运算后得到的是object 运算符 一元运算符：只有一个运算数的运算符 ​ ++，– ， +(正号) ++ –: 自增(自减) ++(–) 在前，先自增(自减)，再运算 ++(–) 在后，先运算，再自增(自减) +(-)：正负号 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 其他类型转number： string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字） boolean转number：true转为1，false转为0 算数运算符 + - * / % ... 12343. ``` 赋值运算符 = += -+.... &#96;&#96;&#96;比较运算符 &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D;&#x3D; &#x3D;&#x3D;&#x3D;(全等于) 123456789 - 比较方式 1. 类型相同：直接比较 - 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。 2. 类型不同：先进行类型转换，再比较 - ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false5. 逻辑运算符 &amp;&amp; || ! 123456789 - 其他类型转boolean： 1. number：0或NaN为假，其他为真 2. string：除了空字符串(&quot;&quot;)，其他都是true 3. null&amp;undefined:都是false 4. 对象：所有对象都为true6. 三元运算符 ? : 表达式 var a = 3; var b = 4; var c = a &gt; b ? 1:0; 1234567891011121314151617181920212223242526 - 语法： - 表达式? 值1:值2; - 判断表达式的值，如果是true则取值1，如果是false则取值2；- 流程控制语句： 1. if...else... 2. switch: - 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7) - switch(变量): case 值: - 在JS中,switch语句可以接受任意的原始数据类型 3. while 4. do...while 5. for- JS特殊语法： 1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议) 2. 变量的定义使用var关键字，也可以不使用 - 用： 定义的变量是局部变量 - 不用：定义的变量是全局变量(不建议)- 练习：99乘法表 &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;99乘法表&lt;/title&gt; &lt;style&gt; td&#123; border: 1px solid; &#125; &lt;/style&gt; &lt;script&gt; document.write(&quot;&lt;table align=&#39;center&#39;&gt;&quot;); //1.完成基本的for循环嵌套，展示乘法表 for (var i = 1; i &lt;= 9 ; i++) &#123; document.write(&quot;&lt;tr&gt;&quot;); for (var j = 1; j &lt;=i ; j++) &#123; document.write(&quot;&lt;td&gt;&quot;); //输出 1 * 1 = 1 document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;); document.write(&quot;&lt;/td&gt;&quot;); &#125; /*//输出换行 document.write(&quot;&lt;br&gt;&quot;);*/ document.write(&quot;&lt;/tr&gt;&quot;); &#125; //2.完成表格嵌套 document.write(&quot;&lt;/table&gt;&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; - 基本对象： 1. Function：函数(方法)对象 1. 创建： 1. var fun = new Function(形式参数列表,方法体); //忘掉吧 2. function 方法名称(形式参数列表)&#123; 方法体 &#125; 3. var 方法名 = function(形式参数列表)&#123; 方法体 &#125; 2. 方法： 3. 属性： length:代表形参的个数 4. 特点： 1. 方法定义是，形参的类型不用写,返回值类型也不写。 2. 方法是一个对象，如果定义名称相同的方法，会覆盖 3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关 4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数 5. 调用： 1. 方法名称(实际参数列表); 2. Array:数组对象 1. 创建： 1. var arr = new Array(元素列表); 2. var arr = new Array(默认长度); 3. var arr = [元素列表]; 2. 方法 ​ join(参数):将数组中的元素按照指定的分隔符拼接为字符串 ​ push() 向数组的末尾添加一个或更多元素，并返回新的长度。 3. 属性 1. length:数组的长度 4. 特点： 1. JS中，数组元素的类型可变的。 2. JS中，数组长度可变的。 3. Boolean 4. Date：日期对象 1. 创建： 1. var date = new Date(); 2. 方法： 1. toLocaleString()：返回当前date对象对应的时间本地字符串格式 2. getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 5. Math：数学对象 1. 创建： - 特点：Math对象不用创建，直接使用。 Math.方法名(); 2. 方法： 1. random():返回 0 ~ 1 之间的随机数。 含0不含1 2. ceil(x)：对数进行上舍入。 3. floor(x)：对数进行下舍入。 4. round(x)：把数四舍五入为最接近的整数。 3. 属性： 1. PI 6. Number 7. String 8. RegExp：正则表达式对象 1. 正则表达式：定义字符串的组成规则。 1. 单个字符:[] 如： [a] [ab] [a-zA-Z0-9_] * 特殊符号代表特殊含义的单个字符: \\d:单个数字字符 [0-9] \\w:单个单词字符[a-zA-Z0-9_] 2. 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 &#123;m,n&#125;:表示 m&lt;= 数量 &lt;= n * m如果缺省： &#123;,n&#125;:最多n次 * n如果缺省：&#123;m,&#125; 最少m次 3. 开始结束符号 - ^:开始 - $:结束 2. 正则对象： 1. 创建 1. var reg = new RegExp(&quot;正则表达式&quot;); 2. var reg = /正则表达式/; 2. 方法 1. test(参数):验证指定的字符串是否符合正则定义的规范 9. Global 1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名(); 2. 方法： 1. encodeURI():url编码 2. decodeURI():url解码 3. encodeURIComponent():url编码,编码的字符更多 4. decodeURIComponent():url解码 5. parseInt():将字符串转为数字 1. 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number 6. isNaN():判断一个值是否是NaN 1. NaN六亲不认，连自己都不认。NaN参与的==比较全部问false 7. eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。 3. URL编码 1. 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"HTML&CSS","slug":"HTML-CSS","date":"2022-04-01T07:31:37.000Z","updated":"2022-04-02T09:44:04.782Z","comments":true,"path":"2022/04/01/HTML-CSS/","link":"","permalink":"http://example.com/2022/04/01/HTML-CSS/","excerpt":"","text":"HTML标签：表单标签 表单 概念：用于采集用户输入的数据的。用于和服务器进行交互。 form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围 属性： action：指定提交数据的URL method:指定提交方式 分类：一共7种，2种比较常用 get： 请求参数会在地址栏中显示。会封装到请求行中(HTTP协议后讲解)。 请求参数大小是有限制的。 不太安全。 Post: 请求参数不会再地址栏中显示。会封装在请求体中(HTTP协议后讲解) 请求参数的大小没有限制。 较为安全。 表单项中的数据要想被提交：必须指定其name属性 表单项标签： input：可以通过type属性值，改变元素展示的样式 type属性： text：文本输入框，默认值 placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息 password：密码输入框 radio:单选框 注意 要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 checkbox：复选框 注意： 一般会给每一个单选框提供value属性，指定其被选中后提交的值 checked属性，可以指定默认值 file：文件选择框 hidden：隐藏域，用于提交一些信息。 按钮： submit：提交按钮。可以提交表单 button：普通按钮 image：图片提交按钮 src属性指定图片的路径 label：指定输入项的文字描述信息 注意： label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 select: 下拉列表 子元素：option，指定列表项 selected：默认选择 textarea：文本域 cols：指定列数，每一行有多少个字符 rows：默认多少行。 CSS：页面美化和布局控制 概念：Cascading Style Sheets 层叠样式表 层叠：多个样式可以作用在同一个html的元素上，同时生效 好处 功能强大 将内容展示和样式控制分离 降低耦合度。解耦 让分工协作更容易 提高开发效率 CSS的使用：CSS与html结合方式 内联样式 在标签内使用style属性指定css代码 1如：&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 内部样式 在head标签内，定义style标签，style标签的标签体内容就是css代码 12345678如： &lt;style&gt; div&#123; color:blue; &#125; &lt;/style&gt; &lt;div&gt;hello css&lt;/div&gt; 外部样式 1. 定义css资源文件。 2. 在head标签内，定义link标签，引入外部的资源文件 1234567* a.css文件： div&#123; color:green; &#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt; &lt;div&gt;hello css&lt;/div&gt; &lt;div&gt;hello css&lt;/div&gt; - 注意 - 1,2,3种方式 css作用范围越来越大 - 1方式不常用，后期常用2,3 - 3种格式可以写为： 123&lt;style&gt; @import &quot;css/a.css&quot;; &lt;/style&gt; css语法： 格式： 12345选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ... &#125; ​ 选择器:筛选具有相似特征的元素 注意： 每一对属性需要使用；隔开，最后一对属性可以不加； 选择器：筛选具有相似特征的元素 分类： 基础选择器 id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一 语法：#id属性值{} 元素选择器：选择具有相同标签名称的元素 语法： 标签名称{} 注意：id选择器优先级高于元素选择器 类选择器：选择具有相同的class属性值的元素。 语法：.class属性值{} 注意：类选择器选择器优先级高于元素选择器 扩展选择器： 选择所有元素： 语法： *{} 并集选择器： 选择器1,选择器2{} 子选择器：筛选选择器1元素下的选择器2元素 语法： 选择器1 选择器2{} 父选择器：筛选选择器2的父元素选择器1 语法： 选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名&#x3D;属性值的元素 语法： 元素名称[属性名&#x3D;”属性值”]{} 伪类选择器：选择一些元素具有的状态 语法： 元素:状态{} 如： 状态： link：初始化的状态 visited：被访问过的状态 active：正在访问状态 hover：鼠标悬浮状态 属性 字体、文本 font-size：字体大小 color：文本颜色 text-align：对其方式 line-height：行高 背景 background： 边框 border：设置边框，符合属性 尺寸 width：宽度 height：高度 盒子模型：控制布局 margin：外边距 padding：内边距 默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 float：浮动 left right 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;style&gt; *&#123; margin: 0px; padding: 0px; box-sizing: border-box; &#125; body&#123; background: url(&quot;img/register_bg.png&quot;) no-repeat center; padding-top: 25px; &#125; .rg_layout&#123; width: 900px; height: 500px; border: 8px solid #EEEEEE; background-color: white; /*让div水平居中*/ margin: auto; &#125; .rg_left&#123; /*border: 1px solid red;*/ float: left; margin: 15px; &#125; .rg_left &gt; p:first-child&#123; color:#FFD026; font-size: 20px; &#125; .rg_left &gt; p:last-child&#123; color:#A6A6A6; font-size: 20px; &#125; .rg_center&#123; float: left; /* border: 1px solid red;*/ &#125; .rg_right&#123; /*border: 1px solid red;*/ float: right; margin: 15px; &#125; .rg_right &gt; p:first-child&#123; font-size: 15px; &#125; .rg_right p a &#123; color:pink; &#125; .td_left&#123; width: 100px; text-align: right; height: 45px; &#125; .td_right&#123; padding-left: 50px ; &#125; #username,#password,#email,#name,#tel,#birthday,#checkcode&#123; width: 251px; height: 32px; border: 1px solid #A6A6A6 ; /*设置边框圆角*/ border-radius: 5px; padding-left: 10px; &#125; #checkcode&#123; width: 110px; &#125; #img_check&#123; height: 32px; vertical-align: middle; &#125; #btn_sub&#123; width: 150px; height: 40px; background-color: #FFD026; border: 1px solid #FFD026 ; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;rg_layout&quot;&gt; &lt;div class=&quot;rg_left&quot;&gt; &lt;p&gt;新用户注册&lt;/p&gt; &lt;p&gt;USER REGISTER&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;rg_center&quot;&gt; &lt;div class=&quot;rg_form&quot;&gt; &lt;!--定义表单 form--&gt; &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt; &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt; &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;rg_right&quot;&gt; &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"HTML","slug":"HTML","date":"2022-03-31T00:42:45.000Z","updated":"2022-04-01T07:31:00.519Z","comments":true,"path":"2022/03/31/HTML/","link":"","permalink":"http://example.com/2022/03/31/HTML/","excerpt":"","text":"web概念概述 JavaWeb： 使用Java语言开发基于互联网的项目 软件架构： C&#x2F;S: Client&#x2F;Server 客户端&#x2F;服务器端 ​ 在用户本地有一个客户端程序，在远程有一个服务器端程序 如：QQ，迅雷… 优点 用户体验好 缺点： 开发、安装，部署，维护 麻烦 只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序 优点 开发、安装，部署，维护 简单 缺点 如果应用过大，用户的体验可能会受到影响 对硬件要求过高 B&#x2F;S架构详解 资源分类： 静态资源： 使用静态网页开发技术发布的资源。 特点： 所有用户访问，得到的结果是一样的。 如：文本，图片，音频、视频, HTML,CSS,JavaScript 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源 动态资源： 使用动态网页技术发布的资源。 特点： 所有用户访问，得到的结果可能不一样。 如：jsp&#x2F;servlet,php,asp… 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器 我们要学习动态资源，必须先学习静态资源！ 静态资源： HTML：用于搭建基础网页，展示页面的内容 CSS：用于美化页面，布局页面 JavaScript：控制页面的元素，让页面有一些动态的效果 HTML 概念：是最基础的网页开发语言 Hyper Text Markup Language 超文本标记语言 超文本: 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本. 标记语言: 由标签构成的语言。&lt;标签名称&gt; 如 html，xml 标记语言不是编程语言 快速入门： 语法： html文档后缀名 .html 或者 .htm 标签分为 围堵标签：有开始标签和结束标签。如 自闭和标签：开始标签和结束标签在一起。如 标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你 12错误：&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;正确：&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt; 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来 html的标签不区分大小写，但是建议使用小写。 123456789101112131415* 代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;FONT color=&#x27;red&#x27;&gt;Hello World&lt;/font&gt;&lt;br/&gt; &lt;font color=&#x27;green&#x27;&gt;Hello World&lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 标签学习 文件标签：构成html最基本的标签 html:html文档的根标签 head：头标签。用于指定html文档的一些属性。引入外部的资源 title：标题标签。 body：体标签 1&lt;!DOCTYPE html&gt;：html 5 中定义该文档是html文档 文本标签：和文本有关的标签 12345678910111213141516171819202122* 注释：&lt;!-- 注释内容 --&gt; * &lt;h1&gt; to &lt;h6&gt;：标题标签 * h1~h6:字体大小逐渐递减 * &lt;p&gt;：段落标签 * &lt;br&gt;：换行标签 * &lt;hr/&gt;：展示一条水平线 * 属性： * color：颜色 * width：宽度 * size：高度 * align：对其方式 * center：居中 * left：左对齐 * right：右对齐 * &lt;b&gt;：字体加粗 * &lt;i&gt;：字体斜体 * &lt;font&gt;:字体标签 * &lt;center&gt;:文本居中 * 属性： * color：颜色 * size：大小 * face：字体 12345678* 属性定义： * color： 1. 英文单词：red,green,blue 2. rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255) 3. #值1值2值3：值的范围：00~FF之间。如： #FF00FF * width： 1. 数值：width=&#x27;20&#x27; ,数值的单位，默认是 px(像素) 2. 数值%：占比相对于父元素的比例 12345678910111213141516171819202122232425262728293031323334353637383940414243* 案例：公司简介 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;ch&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;黑马程序员简介&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 公司简介 &lt;/h1&gt; &lt;hr color=&quot;#ffd700&quot;&gt; &lt;p&gt; &lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。 &lt;/p&gt; &lt;p&gt; 目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。 &lt;/p&gt; &lt;p&gt; 黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。 中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。 &lt;/p&gt; &lt;p&gt; 一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。 &lt;/p&gt; &lt;hr color=&quot;#ffd700&quot;&gt; &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt; &lt;center&gt; 江苏传智播客教育科技股份有限公司&lt;br&gt; 版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882 &lt;/center&gt; &lt;/font&gt; &lt;/body&gt; &lt;/html&gt; 图片标签： img：展示图片 属性： src：指定图片的位置 代码： 1234567891011121314&lt;!--展示一张图片 img--&gt; &lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt; &lt;!-- 相对路径 * 以.开头的路径 * ./：代表当前目录 ./image/1.jpg * ../:代表上一级目录 --&gt; &lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt; &lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt; 列表标签： 有序列表： ol: li: 无序列表： ul: li: 链接标签： a:定义一个超链接 属性： href：指定访问资源的URL(统一资源定位符) target：指定打开资源的方式 _self:默认值，在当前页面打开 _blank：在空白页面打开 代码： 12345678910111213141516&lt;!--超链接 a--&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt; &lt;br&gt; &lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt; div和span： div:每一个div占满一整行。块级标签 span：文本信息在一行展示，行内标签 内联标签 语义化标签：html5中为了提高程序的可读性，提供了一些标签。 121. &lt;header&gt;：页眉2. &lt;footer&gt;：页脚 表格标签： 123456789101112131415161718* table：定义表格 * width：宽度 * border：边框 * cellpadding：定义内容和单元格的距离 * cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、 * bgcolor：背景色 * align：对齐方式 * tr：定义行 * bgcolor：背景色 * align：对齐方式 * td：定义单元格 * colspan：合并列 * rowspan：合并行 * th：定义表头单元格 * &lt;caption&gt;：表格标题 * &lt;thead&gt;：表示表格的头部分 * &lt;tbody&gt;：表示表格的体部分 * &lt;tfoot&gt;：表示表格的脚部分 案例：旅游网站首页分析 123456781. 确定使用table来完成布局 2. 如果某一行只有一个单元格，则使用&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;3. 如果某一行有多个单元格，则使用 &lt;tr&gt; &lt;td&gt; &lt;table&gt;&lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;黑马旅游网&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--采用table来完成布局--&gt; &lt;!--最外层的table，用于整个页面的布局--&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;!-- 第1行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/top_banner.jpg&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第2行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/logo.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/search.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/hotel_tel.png&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第3行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table width=&quot;100%&quot; align=&quot;center&quot;&gt; &lt;tr bgcolor=&quot;#ffd700&quot; align=&quot;center&quot; height=&quot;45&quot; &gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;首页&lt;/a&gt; &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;td&gt; 门票 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第4行 轮播图 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/banner_3.jpg&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第5行 黑马精选--&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_5.jpg&quot; alt=&quot;&quot;&gt; 黑马精选 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第6行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 899&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第7行 国内游 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_6.jpg&quot; alt=&quot;&quot;&gt; 国内游 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第8行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt; &lt;img src=&quot;image/guonei_1.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第9行 境外游 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/icon_7.jpg&quot; alt=&quot;&quot;&gt; 境外游 &lt;hr color=&quot;#ffd700&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第10行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;table align=&quot;center&quot; width=&quot;95%&quot;&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt; &lt;img src=&quot;image/jiangwai_1.jpg&quot; alt=&quot;&quot;&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot; height=&quot;100%&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;td&gt; &lt;img src=&quot;image/jiangxuan_3.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;上海飞三亚五天4晚自由行(春节销售+亲子+蜜月+自由行)&lt;/p&gt; &lt;font color=&quot;red&quot;&gt;&amp;yen; 699&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第11行 --&gt; &lt;tr&gt; &lt;td&gt; &lt;img src=&quot;image/footer_service.png&quot; alt=&quot;&quot; width=&quot;100%&quot;&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第12行 --&gt; &lt;tr&gt; &lt;td align=&quot;center&quot; bgcolor=&quot;#ffd700&quot; height=&quot;40&quot;&gt; &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt; 江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882 &lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"计算机系统基础1.0","slug":"计算机系统基础1-0","date":"2022-03-30T14:28:23.000Z","updated":"2022-03-30T14:56:15.034Z","comments":true,"path":"2022/03/30/计算机系统基础1-0/","link":"","permalink":"http://example.com/2022/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%801-0/","excerpt":"","text":"C语言程序举例用“系统思维”分析问题123456#include&lt;stdio.h&gt;main()&#123; double a = 10; println(&quot;a = %d&quot;,a);&#125; 问题：在IA-32上运行时，打印结果为a&#x3D;0 在x86-64上运行时，打印出来的a是一个不确定值 理解该问题需要知道 IEEE 754 的表示 X87 FPU的体系结构 IA-32和x86-64中过程调用的参数传递 计算机内部的运算电路 什么是计算机系统？计算机系统抽象层的转换![截屏2022-03-30 22.49.52](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机系统基础1-0&#x2F;截屏2022-03-30 22.49.52.png) 计算机系统基础 内容提要使学生清楚理解计算机是如何生产和运行可执行文件的为什么学习这门课程 为了编程时少错误 可以找出错误 明白程序是怎样在计算机上执行的","categories":[],"tags":[{"name":"计算机系统基础","slug":"计算机系统基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"JDBC连接池&JDBCTemplate","slug":"JDBC连接池-JDBCTemplate","date":"2022-03-30T00:33:17.000Z","updated":"2022-03-30T08:23:56.979Z","comments":true,"path":"2022/03/30/JDBC连接池-JDBCTemplate/","link":"","permalink":"http://example.com/2022/03/30/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0-JDBCTemplate/","excerpt":"","text":"数据库连接池 概念：其实就是一个容器(集合)，存放数据库连接的容器。 当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处： 节约资源 用户访问高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取连接：getConnection() 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接 一般我们不去实现它，有数据库厂商来实现 C3P0：数据库连接池技术 Druid：数据库连接池实现技术，由阿里巴巴提供的 C3P0：数据库连接池技术 步骤 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ， 不要忘记导入数据库驱动jar包 定义配置文件： 名称： c3p0.properties 或者 c3p0-config.xml 路径：直接将文件放在src目录下即可。 创建核心对象 数据库连接池对象 ComboPooledDataSource 获取连接： getConnection 1234//1.创建数据库连接池对象 DataSource ds = new ComboPooledDataSource(); //2. 获取连接对象 Connection conn = ds.getConnection(); Druid：数据库连接池实现技术，由阿里巴巴提供的 步骤： 导入jar包 druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory 获取连接：getConnection 12345678//3.加载配置文件 Properties pro = new Properties(); InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //4.获取连接池对象 DataSource ds = DruidDataSourceFactory.createDataSource(pro); //5.获取连接 Connection conn = ds.getConnection(); 定义工具类 定义一个类 JDBCUtils 提供静态代码块加载配置文件，初始化连接池对象 提供方法 获取连接方法：通过数据库连接池获取连接 释放资源 获取连接池的方法 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class JDBCUtils &#123; private static DataSource ds; static &#123; Properties pro = new Properties(); try &#123; pro.load(DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125; public static void close(Statement stmt,Connection conn)&#123; /* if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;*/ close(null,stmt,conn); &#125; public static void close(ResultSet rs , Statement stmt, Connection conn)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close();//归还连接 &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static DataSource getDataSource()&#123; return ds; &#125; &#125; Spring JDBC Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发 步骤 导入jar包 创建JdbcTemplate对象。依赖于数据源DataSource JdbcTemplate template &#x3D; new JdbcTemplate(ds); 调用JdbcTemplate的方法来完成CRUD的操作 update():执行DML语句。增、删、改语句 queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合 注意：这个方法查询的结果集长度只能是1 queryForList():查询结果将结果集封装为list集合 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 query():查询结果，将结果封装为JavaBean对象 query的参数：RowMapper 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装 new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 一般用于聚合函数的查询 练习 需求 修改1号数据的 salary 为 10000 添加一条记录 删除刚才添加的记录 查询id为1的记录，将其封装为Map集合 查询所有记录，将其封装为List 查询所有记录，将其封装为Emp对象的List集合 查询总记录数 12//1. 获取JDBCTemplate对象 private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); 123456789101112/** * 1. 修改1号数据的 salary 为 10000 */ @Test public void test1()&#123; //2. 定义sql String sql = &quot;update emp set salary = 10000 where id = 1001&quot;; //3. 执行sql int count = template.update(sql); System.out.println(count); &#125; 12345678910/** * 2. 添加一条记录 */ @Test public void test2()&#123; String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;; int count = template.update(sql, 1015, &quot;郭靖&quot;, 10); System.out.println(count); &#125; 123456789/** * 3.删除刚才添加的记录 */ @Test public void test3()&#123; String sql = &quot;delete from emp where id = ?&quot;; int count = template.update(sql, 1015); System.out.println(count); &#125; 123456789101112/** * 4.查询id为1001的记录，将其封装为Map集合 * 注意：这个方法查询的结果集长度只能是1 */ @Test public void test4()&#123; String sql = &quot;select * from emp where id = ? or id = ?&quot;; Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002); System.out.println(map); //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125; &#125; 123456789101112/** * 5. 查询所有记录，将其封装为List */ @Test public void test5()&#123; String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); for (Map&lt;String, Object&gt; stringObjectMap : list) &#123; System.out.println(stringObjectMap); &#125; &#125; 123456789101112/** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6_2()&#123; String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class)); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125; 123456789101112/** * 7. 查询总记录数 */ @Test public void test7()&#123; String sql = &quot;select count(id) from emp&quot;; Long total = template.queryForObject(sql, Long.class); System.out.println(total); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637/** * 6. 查询所有记录，将其封装为Emp对象的List集合 */ @Test public void test6()&#123; String sql = &quot;select * from emp&quot;; List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123; @Override public Emp mapRow(ResultSet rs, int i) throws SQLException &#123; Emp emp = new Emp(); int id = rs.getInt(&quot;id&quot;); String ename = rs.getString(&quot;ename&quot;); int job_id = rs.getInt(&quot;job_id&quot;); int mgr = rs.getInt(&quot;mgr&quot;); Date joindate = rs.getDate(&quot;joindate&quot;); double salary = rs.getDouble(&quot;salary&quot;); double bonus = rs.getDouble(&quot;bonus&quot;); int dept_id = rs.getInt(&quot;dept_id&quot;); emp.setId(id); emp.setEname(ename); emp.setJob_id(job_id); emp.setMgr(mgr); emp.setJoindate(joindate); emp.setSalary(salary); emp.setBonus(bonus); emp.setDept_id(dept_id); return emp; &#125; &#125;); for (Emp emp : list) &#123; System.out.println(emp); &#125; &#125;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"操作系统上的程序","slug":"操作系统上的程序","date":"2022-03-29T13:27:57.000Z","updated":"2022-03-30T00:30:10.496Z","comments":true,"path":"2022/03/29/操作系统上的程序/","link":"","permalink":"http://example.com/2022/03/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"状态机与数字电路状态机：复习概念：https://blog.csdn.net/pingxiaozhao/article/details/109239311 数字逻辑电路 状态&#x3D;寄存器保存的值（flip-flop） 初始状态&#x3D;RESET（implementation dependent） 迁移&#x3D;组合逻辑电路计算寄存器下一周期的值 例子： 12X′=¬X∧YY′=¬X∧¬Y 什么是程序（源代码视角）","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"JDBC","slug":"JDBC","date":"2022-03-27T07:22:27.000Z","updated":"2022-03-29T08:25:20.674Z","comments":true,"path":"2022/03/27/JDBC/","link":"","permalink":"http://example.com/2022/03/27/JDBC/","excerpt":"","text":"JDBC: 概念：Java DataBase Connectivity Java 数据库连接， Java语言操作数据库 JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 快速入门 步骤 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键–&gt;Add As Library 注册驱动 获取数据库连接对象 Connection 定义sql 获取执行sql语句的对象 Statement 执行sql，接受返回结果 处理结果 释放资源 代码实现 12345678910111213141516//1. 导入驱动jar包 //2.注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //3.获取数据库连接对象 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; //5.获取执行sql的对象 Statement Statement stmt = conn.createStatement(); //6.执行sql int count = stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); 3.详解各个对象 DriverManager：驱动管理对象 功能： 注册驱动：告诉程序该使用哪一个数据库驱动jarstatic void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。写代码使用： Class.forName(“com.mysql.jdbc.Driver”);通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 1234567static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125; 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。 2.获取数据库连接： 方法：static Connection getConnection(String url, String user, String password) 参数 url：指定连接的路径 语法：jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称 例子：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称 user：用户名 password：密码 2.Connection：数据库连接对象 功能： 获取执行sql 的对象 Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement：执行sql的对象 执行sql boolean execute(String sql) ：可以执行任意的sql 了解 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是 ResultSet executeQuery(String sql) ：执行DQL（select)语句 3.Statement：执行sql的对象 执行sql boolean execute(String sql) ：可以执行任意的sql 了解 int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql) ：执行DQL（select)语句 练习 account表 添加一条记录 account表 修改记录 account表 删除一条记录 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445Statement stmt = null; Connection conn = null; try &#123; //1. 注册驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 定义sql String sql = &quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;; //3.获取Connection对象 conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;); //4.获取执行sql的对象 Statement stmt = conn.createStatement(); //5.执行sql int count = stmt.executeUpdate(sql);//影响的行数 //6.处理结果 System.out.println(count); if(count &gt; 0)&#123; System.out.println(&quot;添加成功！&quot;); &#125;else&#123; System.out.println(&quot;添加失败！&quot;); &#125; &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //stmt.close(); //7. 释放资源 //避免空指针异常 if(stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 4.ResultSet：结果集对象,封装查询结果 boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true getXxx(参数):获取数据 Xxx：代表数据类型 如： int getInt() , String getString() 参数： int：代表列的编号,从1开始 如： getString(1) String：代表列名称。 如： getDouble(“balance”) 注意： 使用步骤： 游标向下移动一行 判断是否有数据 获取数据 12345678910//循环判断游标是否是最后一行末尾。while(rs.next())&#123;//获取数据//6.2 获取数据int id = rs.getInt(1);String name = rs.getString(&quot;name&quot;);double balance = rs.getDouble(3); System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);&#125; 练习 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。 定义Emp类 定义方法 public List findAll(){} 实现方法 select * from emp; 5.PreparedStatement：执行sql的对象 SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题 输入用户随便，输入密码：a’ or ‘a’ &#x3D; ‘a sql：select * from user where username &#x3D; ‘fhdsjkf’ and password &#x3D; ‘a’ or ‘a’ &#x3D; ‘a’ 解决sql注入问题：使用PreparedStatement对象来解决 预编译的SQL：参数使用?作为占位符 步骤： 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar 注册驱动 获取数据库连接对象 Connection 定义sql 注意：sql的参数使用？作为占位符。 如：select * from user where username &#x3D; ? and password &#x3D; ?; 获取执行sql语句的对象 PreparedStatement Connection.prepareStatement(String sql) 给？赋值： 方法： setXxx(参数1,参数2) 参数1：？的位置编号 从1 开始 参数2：？的值 执行sql，接受返回结果，不需要传递sql语句 处理结果 释放资源 注意：后期都会使用PreparedStatement来完成增删改查的所有操作 可以防止SQL注入 效率更高 抽取JDBC工具类 ： JDBCUtils 目的 分析 注册驱动也抽取 抽取一个方法获取连接对象 需求：不想传递参数（麻烦），还得保证工具类的通用性。 解决：配置文件 1234jdbc.properties url= user= password= 抽取一个方法释放资源 代码实现： 123456789101112131415161718192021222324252627282930313233343536public class JDBCUtils &#123; private static String url; private static String user; private static String password; private static String driver; /** * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块 */ static&#123; //读取资源文件，获取值。 try &#123; //1. 创建Properties集合类。 Properties pro = new Properties(); //获取src路径下的文件的方式---&gt;ClassLoader 类加载器 ClassLoader classLoader = JDBCUtils.class.getClassLoader(); URL res = classLoader.getResource(&quot;jdbc.properties&quot;); String path = res.getPath(); System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties //2. 加载文件 // pro.load(new FileReader(&quot;D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties&quot;)); pro.load(new FileReader(path)); //3. 获取数据，赋值 url = pro.getProperty(&quot;url&quot;); user = pro.getProperty(&quot;user&quot;); password = pro.getProperty(&quot;password&quot;); driver = pro.getProperty(&quot;driver&quot;); //4. 注册驱动 Class.forName(driver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; 12345678910111213141516171819202122232425262728293031/** * 获取连接 * @return 连接对象 */ public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; /** * 释放资源 * @param stmt * @param conn */ public static void close(Statement stmt,Connection conn)&#123; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031/** * 释放资源 * @param stmt * @param conn */ public static void close(ResultSet rs,Statement stmt, Connection conn)&#123; if( rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( stmt != null)&#123; try &#123; stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if( conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 练习 需求： 通过键盘录入用户名和密码 判断用户是否登录成功 select * from user where username &#x3D; “” and password &#x3D; “”; 如果这个sql有查询结果，则成功，反之，则失败 步骤 创建数据库表 user 123456789CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(32), PASSWORD VARCHAR(32) ); INSERT INTO USER VALUES(NULL,&#x27;zhangsan&#x27;,&#x27;123&#x27;); INSERT INTO USER VALUES(NULL,&#x27;lisi&#x27;,&#x27;234&#x27;) 2.代码实现 12345678910111213141516171819public class JDBCDemo9 &#123; public static void main(String[] args) &#123; //1.键盘录入，接受用户名和密码 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入用户名：&quot;); String username = sc.nextLine(); System.out.println(&quot;请输入密码：&quot;); String password = sc.nextLine(); //2.调用方法 boolean flag = new JDBCDemo9().login(username, password); //3.判断结果，输出不同语句 if(flag)&#123; //登录成功 System.out.println(&quot;登录成功！&quot;); &#125;else&#123; System.out.println(&quot;用户名或密码错误！&quot;); &#125; &#125; 3.登录方法 123456789101112131415161718192021222324252627282930313233343536/** * 登录方法 */ public boolean login(String username ,String password)&#123; if(username == null || password == null)&#123; return false; &#125; //连接数据库判断是否登录成功 Connection conn = null; Statement stmt = null; ResultSet rs = null; //1.获取连接 try &#123; conn = JDBCUtils.getConnection(); //2.定义sql String sql = &quot;select * from user where username = &#x27;&quot;+username+&quot;&#x27; and password = &#x27;&quot;+password+&quot;&#x27; &quot;; //3.获取执行sql的对象 stmt = conn.createStatement(); //4.执行查询 rs = stmt.executeQuery(sql); //5.判断 /* if(rs.next())&#123;//如果有下一行，则返回true return true; &#125;else&#123; return false; &#125;*/ return rs.next();//如果有下一行，则返回true &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(rs,stmt,conn); &#125; return false; &#125; &#125; JDBC控制事务： 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。 操作 开启事务 提交事务 回滚事务 使用Connection对象来管理事务 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 在执行sql之前开启事务 提交事务：commit() 当所有sql都执行完提交事务 回滚事务：rollback() 在catch中回滚事务 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JDBCDemo10 &#123; public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; //1.获取连接 conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //2.定义sql //2.1 张三 - 500 String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;; //2.2 李四 + 500 String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;; //3.获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //4. 设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //5.执行sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MySQL多表和事物","slug":"MySQL多表和事物","date":"2022-03-26T01:03:21.000Z","updated":"2022-03-29T01:33:49.837Z","comments":true,"path":"2022/03/26/MySQL多表和事物/","link":"","permalink":"http://example.com/2022/03/26/MySQL%E5%A4%9A%E8%A1%A8%E5%92%8C%E4%BA%8B%E7%89%A9/","excerpt":"","text":"多表查询 查询语法 select 列名列表 from 表名列表 where…. 准备sql 123456创建部门表CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO dept (NAME) VALUES (&#x27;开发部&#x27;),(&#x27;市场部&#x27;),(&#x27;财务部&#x27;); 123456789101112131415创建员工表CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;孙悟空&#x27;,&#x27;男&#x27;,7200,&#x27;2013-02-24&#x27;,1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;猪八戒&#x27;,&#x27;男&#x27;,3600,&#x27;2010-12-02&#x27;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;唐僧&#x27;,&#x27;男&#x27;,9000,&#x27;2008-08-08&#x27;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;白骨精&#x27;,&#x27;女&#x27;,5000,&#x27;2015-10-07&#x27;,3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;蜘蛛精&#x27;,&#x27;女&#x27;,4500,&#x27;2011-03-14&#x27;,1); 笛卡尔积 有两个集合A,B .取这两个集合的所有组成情况。 要完成多表查询，需要消除无用的数据 多表查询的分类： 内连接查询： 隐式内连接：使用where条件消除无用数据 例 12345678910111213141516-- 查询所有员工信息和对应的部门信息SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;-- 查询员工表的名称，性别。部门表的名称 SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`; SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; 显式内连接： 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 例 SELECT * FROM emp INNER JOIN dept ON emp.dept_id &#x3D; dept.id; SELECT * FROM emp JOIN dept ON emp.dept_id &#x3D; dept.id; 内连接查询： 从哪些表中查询数据 条件是什么 查询哪些字段 外链接查询： 左外连接： 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； 查询的是左表所有数据以及其交集部分。 例子 12-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; 右外连接： 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； 查询的是右表所有数据以及其交集部分。 例子 1SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; 子查询： 概念：查询中嵌套查询，称嵌套查询为子查询。 123456789-- 查询工资最高的员工信息 -- 1 查询最高的工资是多少 9000 SELECT MAX(salary) FROM emp; -- 2 查询员工信息，并且工资等于9000的 SELECT * FROM emp WHERE emp.`salary` = 9000; -- 一条sql就完成这个操作。子查询 SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); 子查询的不同种情况 子查询的结果是单行单列的： 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;&#x3D; &lt; &lt;&#x3D; &#x3D; 12-- 查询员工工资小于平均工资的人 SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 子查询的结果是多行单列的： 子查询可以作为条件，使用运算符in来判断 12345-- 查询&#x27;财务部&#x27;和&#x27;市场部&#x27;所有的员工信息 SELECT id FROM dept WHERE NAME = &#x27;财务部&#x27; OR NAME = &#x27;市场部&#x27;; SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;-- 子查询 SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#x27;财务部&#x27; OR NAME = &#x27;市场部&#x27;); 子查询的结果是多行多列的： 子查询可以作为一张虚拟表参与查询 12345678-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息-- 子查询 SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#x27;2011-11-11&#x27;) t2 WHERE t1.id = t2.dept_id; -- 普通内连接 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &#x27;2011-11-11&#x27; 练习 表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273-- 部门表 CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); -- 添加4个部门 INSERT INTO dept(id,dname,loc) VALUES (10,&#x27;教研部&#x27;,&#x27;北京&#x27;), (20,&#x27;学工部&#x27;,&#x27;上海&#x27;), (30,&#x27;销售部&#x27;,&#x27;广州&#x27;), (40,&#x27;财务部&#x27;,&#x27;深圳&#x27;); -- 职务表，职务名称，职务描述 CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50) ); -- 添加4个职务 INSERT INTO job (id, jname, description) VALUES (1, &#x27;董事长&#x27;, &#x27;管理整个公司，接单&#x27;), (2, &#x27;经理&#x27;, &#x27;管理部门员工&#x27;), (3, &#x27;销售员&#x27;, &#x27;向客人推销产品&#x27;), (4, &#x27;文员&#x27;, &#x27;使用办公软件&#x27;); -- 员工表 CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id) ); -- 添加员工 INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES (1001,&#x27;孙悟空&#x27;,4,1004,&#x27;2000-12-17&#x27;,&#x27;8000.00&#x27;,NULL,20), (1002,&#x27;卢俊义&#x27;,3,1006,&#x27;2001-02-20&#x27;,&#x27;16000.00&#x27;,&#x27;3000.00&#x27;,30), (1003,&#x27;林冲&#x27;,3,1006,&#x27;2001-02-22&#x27;,&#x27;12500.00&#x27;,&#x27;5000.00&#x27;,30), (1004,&#x27;唐僧&#x27;,2,1009,&#x27;2001-04-02&#x27;,&#x27;29750.00&#x27;,NULL,20), (1005,&#x27;李逵&#x27;,4,1006,&#x27;2001-09-28&#x27;,&#x27;12500.00&#x27;,&#x27;14000.00&#x27;,30), (1006,&#x27;宋江&#x27;,2,1009,&#x27;2001-05-01&#x27;,&#x27;28500.00&#x27;,NULL,30), (1007,&#x27;刘备&#x27;,2,1009,&#x27;2001-09-01&#x27;,&#x27;24500.00&#x27;,NULL,10), (1008,&#x27;猪八戒&#x27;,4,1004,&#x27;2007-04-19&#x27;,&#x27;30000.00&#x27;,NULL,20), (1009,&#x27;罗贯中&#x27;,1,NULL,&#x27;2001-11-17&#x27;,&#x27;50000.00&#x27;,NULL,10), (1010,&#x27;吴用&#x27;,3,1006,&#x27;2001-09-08&#x27;,&#x27;15000.00&#x27;,&#x27;0.00&#x27;,30), (1011,&#x27;沙僧&#x27;,4,1004,&#x27;2007-05-23&#x27;,&#x27;11000.00&#x27;,NULL,20), (1012,&#x27;李逵&#x27;,4,1006,&#x27;2001-12-03&#x27;,&#x27;9500.00&#x27;,NULL,30), (1013,&#x27;小白龙&#x27;,4,1004,&#x27;2001-12-03&#x27;,&#x27;30000.00&#x27;,NULL,20), (1014,&#x27;关羽&#x27;,4,1007,&#x27;2002-01-23&#x27;,&#x27;13000.00&#x27;,NULL,10); -- 工资等级表 CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资 ); -- 添加5个工资等级 INSERT INTO salarygrade(grade,losalary,hisalary) VALUES (1,7000,12000), (2,12010,14000), (3,14010,20000), (4,20010,30000), (5,30010,99990); 需求 需求1 1234567891011121314151617-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 /* 分析： 1.员工编号，员工姓名，工资，需要查询emp表 职务名称，职务描述 需要查询job表 2.查询条件 emp.job_id = job.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description` -- 职务描述 FROM emp t1, job t2 WHERE t1.`job_id` = t2.`id`; 需求2 12345678910111213141516171819-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 /* 分析： 1. 员工编号，员工姓名，工资 emp 职务名称，职务描述 job 部门名称，部门位置 dept 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id */ SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description`, -- 职务描述 t3.`dname`, -- 部门名称 t3.`loc` -- 部门位置 FROM emp t1, job t2,dept t3 WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`; 需求3 12345678910111213-- 3.查询员工姓名，工资，工资等级 /* 分析： 1.员工姓名，工资 emp 工资等级 salarygrade 2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */ SELECT t1.ename , t1.`salary`, t2.* FROM emp t1, salarygrade t2 WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`; 需求4 123456789101112131415161718192021-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 /* 分析： 1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept 工资等级 salarygrade 2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary */ SELECT t1.`ename`, t1.`salary`, t2.`jname`, t2.`description`, t3.`dname`, t3.`loc`, t4.`grade` FROM emp t1,job t2,dept t3,salarygrade t4 WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id` AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`; 需求5 12345678910111213141516171819-- 5.查询出部门编号、部门名称、部门位置、部门人数 /* 分析： 1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表 2.使用分组查询。按照emp.dept_id完成分组，查询count(id) 3.使用子查询将第2步的查询结果和dept表进行关联查询 */ SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.total FROM dept t1, (SELECT dept_id,COUNT(id) total FROM emp GROUP BY dept_id) t2 WHERE t1.`id` = t2.dept_id; 需求6 123456789101112131415161718192021222324252627282930-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 /* 分析： 1.姓名 emp， 直接上级的姓名 emp * emp表的id 和 mgr 是自关联 2.条件 emp.id = emp.mgr 3.查询左表的所有数据，和 交集数据 * 使用左外连接查询 */ /* select t1.ename, t1.mgr, t2.`id`, t2.ename from emp t1, emp t2 where t1.mgr = t2.`id`; */ SELECT t1.ename, t1.mgr, t2.`id`, t2.`ename` FROM emp t1 LEFT JOIN emp t2 ON t1.`mgr` = t2.`id`; 事物 事物的基本介绍 概念 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作 开启事务： start transaction; 回滚：rollback; 提交：commit; 例子： 12345678CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE ); -- 添加数据 INSERT INTO account (NAME, balance) VALUES (&#x27;zhangsan&#x27;, 1000), (&#x27;lisi&#x27;, 1000); 1234567891011121314-- 0. 开启事务 START TRANSACTION; -- 1. 张三账户 -500 UPDATE account SET balance = balance - 500 WHERE NAME = &#x27;zhangsan&#x27;; -- 2. 李四账户 +500 -- 出错了... UPDATE account SET balance = balance + 500 WHERE NAME = &#x27;lisi&#x27;; -- 发现执行没有问题，提交事务 COMMIT; -- 发现出问题了，回滚事务 ROLLBACK; 4.MySQL数据库中事务默认自动提交 事务提交的两种方式： 自动提交：- mysql就是自动提交的- 一条DML(增删改)语句会自动提交一次事务。 手动提交： Oracle 数据库默认是手动提交事务 需要先开启事务，再提交 修改事务的默认提交方式： 查看事务的默认提交方式：SELECT @@autocommit; – 1 代表自动提交 0 代表手动提交 修改默认提交方式： set @@autocommit &#x3D; 0; 事务的四大特征： 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 事务的隔离级别（了解） 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别 read uncommitted：读未提交 * 产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （Oracle） * 产生的问题：不可重复读、幻读 repeatable read：可重复读 （MySQL默认） * 产生的问题：幻读 serializable：串行化 * 可以解决所有的问题 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别： * select @@tx_isolation; 数据库设置隔离级别： * set global transaction isolation level 级别字符串; 演示： 12345set global transaction isolation level read uncommitted; start transaction; -- 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2; DCL: SQL分类： DDL：操作数据库和表 DML：增删改表中数据 DQL：查询表中数据 DCL：管理用户，授权 DBA：数据库管理员 DCL：管理用户，授权 管理用户 添加用户： 语法：CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’; 删除用户： 语法：DROP USER ‘用户名‘@’主机名’; 修改用户密码： 12345UPDATE USER SET PASSWORD = PASSWORD(&#x27;新密码&#x27;) WHERE USER = &#x27;用户名&#x27;; UPDATE USER SET PASSWORD = PASSWORD(&#x27;abc&#x27;) WHERE USER = &#x27;lisi&#x27;; SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; = PASSWORD(&#x27;新密码&#x27;); SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;123&#x27;); mysql中忘记了root用户的密码？ cmd – &gt; net stop mysql 停止mysql服务 需要管理员运行该cmd 使用无验证方式启动mysql服务： mysqld –skip-grant-tables 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 use mysql; update user set password &#x3D; password(‘你的新密码’) where user &#x3D; ‘root’; 关闭两个窗口 打开任务管理器，手动结束mysqld.exe 的进程 启动mysql服务 使用新密码登录。 查询用户： 切换到mysql数据库 USE myql; 查询user表 SELECT * FROM USER; 通配符： % 表示可以在任意主机使用用户登录数据库 2.权限管理： 查询权限： 123-- 查询权限 SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;; SHOW GRANTS FOR &#x27;lisi&#x27;@&#x27;%&#x27;; 授予权限： 12345-- 授予权限 grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;; -- 给张三用户授予所有权限，在任意数据库任意表上 GRANT ALL ON *.* TO &#x27;zhangsan&#x27;@&#x27;localhost&#x27;; 撤销权限 123-- 撤销权限： revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;; REVOKE UPDATE ON db3.`account` FROM &#x27;lisi&#x27;@&#x27;%&#x27;;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"四级英语","slug":"四级单词1-6串词","date":"2022-03-24T14:36:21.000Z","updated":"2022-04-05T03:29:06.396Z","comments":true,"path":"2022/03/24/四级单词1-6串词/","link":"","permalink":"http://example.com/2022/03/24/%E5%9B%9B%E7%BA%A7%E5%8D%95%E8%AF%8D1-6%E4%B8%B2%E8%AF%8D/","excerpt":"","text":"四级词汇第一串词：view（看；被看见的）view v.认为 n.观点；风景re - : 再一次 review n.v.回顾；复习；评论 inter - : 相互 interview n. v. 采访；面试；面谈 interviewee n. 被面试者，被接见者，被访问者 interviewer n.采访者；见面者；进行面试 employer 雇主 employee 雇员 第二串词：quire&#x2F;quest&#x2F;quer(to ask 询问，to seek 寻找)question n.问题 v.质疑；怀疑-tion ：名词词尾request n. v. 请求；需要（“请”） guest 客人（正式，客气） re - ：再 restart 重启 request sb to do sth 请求某人做某事 require v.需要；要求（&#x3D; need） 中性词 requirement n. 要求；必要条件 to meet&#x2F;satisfy the requirements 符合条件 acquire v. 获得；取得；学到（技巧，学问） ac - ：强调 技巧 kill inquire v.询问；查究 in - ：进来，向内 income 收入 conquer v. 征服 con - ：共同，强调 conquer your fear 克服恐惧 conquer the world 征服世界 overcome 克服小问题 第3串词：duce&#x2F;duct&#x2F;duc（to lead 引导；拉）produce v.生产；引起；创作 pro - ：向前 educate v. 教育；培养 e - （ex - ）：出（out） -ate：动词词尾 （正式）教育，内容比teach广泛（周围人言传身教，家庭的影响，熏陶） train ：训练，培养 tutor：一对一 teach：“教”：最普通用语，教授具体知识，技能 education n. 教育；培养 higher education 高等教育（指含大学以上的教育） educational adj.教育的；有教育意义的 educational reform 教育改革 product n. 产品；产物production n. 生产；制造produce v.生产；引起；创作producer n. 生产商producetive adj.多产的；有成效的 productive workers 高效（多产的）工人 a productive meeting 有成效的会议 byproduct n.副产品（中性词） by your side 在你身边 side effect 副作用（中性词） productivity n.生产力；生产率conduct n.行为 v.实施；引导；指挥；传导（热，电） con-&#x2F;com-：共同，强调 conduct business 做生意 I am deeply hurt by her conduct. 她的行为深深地伤害了我 induce v.诱导，劝说；导致（中性词） in-：进来，向内 induce me to take the jib 诱使我接受这份工作 Some drugs will induce sleep 有些药物会使人昏昏欲睡 reduce v.减少；降低 re-：向后，往回 reduce the speed 减速 reduce the risk of heart disease 降低心脏病风险 reduction n.减少;下降Introduce v.介绍；引进 introduced A to B 把A介绍给B The new law was introduced in 1991. 这项法律是于1991年开始实施 introduce the technology to the world。 把这项技术推向世界 introduction n.介绍;引进 Intro-:在内，向内（within） reproduce v.复制；繁殖reproduction n.繁殖；复制reproductive adj.繁殖的 re-:再 第四串词：fess（to say，to talk 说）Professor n.教授；教师profession n.职业，专业；声明 -sion:名词词尾 The medical&#x2F;legal profession 医学专业,法律专业 professional adj.专业的；职业的 n.专家；专门人才 -al：形容词，名词词尾 Professional skills 专业技能 health professionals 健康方面的专门人才 第5串词：just&#x2F;jur&#x2F;jud(law 法律，right 正义)just adj.公正的，合理的；正直的 adv.只是；刚才 I just saw him. 我刚才还见过他 a just decision&#x2F;society 一个公正的决定&#x2F;社会 justice n.公正，公平 -ce：名词词尾 justify v.证明正确；替…辩护（解释） -fy：动词词尾 beautify 美化 Justify a war 证明战争是正确的 Justify your wrong actions 为了你的错误行为辩护 adjust v.调整；校准 ad-：向着 adjustment n.调整,调节injure v.伤害，损害 in-：否定前zu injury n.伤害,损伤judge n.法官；裁判员 v.判断；裁判；评价第6串词：mean（中间的）mean n.平均值 v.意味着 adj.刻薄的;平均的means n.手段；方法 单复数同行 meaning n.意义；含义meaningful adj.有意义的；意味深长的 a meaningful discussion 意义非凡的讨论 meanwhile adv.同时，其间 副词","categories":[],"tags":[{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"}]},{"title":"MySQL约束","slug":"MySQL约束","date":"2022-03-24T07:03:27.000Z","updated":"2022-03-25T07:44:57.979Z","comments":true,"path":"2022/03/24/MySQL约束/","link":"","permalink":"http://example.com/2022/03/24/MySQL%E7%BA%A6%E6%9D%9F/","excerpt":"","text":"DQL:查询语句1.排序查询 语法：order by 子句 order by 排序字段1 排序方式1 ， 排序字段2 排序方式2… 排序方式： ASC：升序，默认的。 DESC：降序。 注意 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 2.聚合函数将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注意 聚合函数的计算，排除null值。 解决方案 选择不包含非空的列进行计算 IFNULL函数 1SELECT COUNT(english) FROM student; 3.分组查询 语法：group by 分组字段； 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 12345678910111213-- 按照性别分组。分别查询男、女同学的平均分SELECT sex , AVG(math) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex;-- 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2;SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; 4.分页查询 语法：limit 开始的索引,每页查询的条数; 公式：开始的索引 &#x3D; （当前的页码 - 1） * 每页显示的条数 limit 是一个MySQL”方言” 123456-- 每页显示3条记录 SELECT * FROM student LIMIT 0,3; -- 第1页 SELECT * FROM student LIMIT 3,3; -- 第2页 SELECT * FROM student LIMIT 6,3; -- 第3页 约束 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性。 分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key 非空约束：not null，某一列的值不能为null 创建表时添加约束 1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name为非空 ); - 创建表完后，添加非空约束 1ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; - 删除name的非空约束 1ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束：unique，某一列的值不能重复 注意 唯一约束可以有NULL值，但是只能有一条记录为null 在创建表时，添加唯一约束 &#96;&#96;&#96;CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE – 手机号 );12345- 删除唯一约束 - ``` ALTER TABLE stu DROP INDEX phone_number; 在表创建完后，添加唯一约束 &#96;&#96;&#96;ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;123456789101112131415161718 - - 主键约束：primary key。 - 注意： - 含义：非空且唯一 - 一张表只能有一个字段为主键 - 主键就是表中记录的唯一标识 - 在创建表时，添加主键约束 - ``` create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 删除主键 -- 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 12345- 创建完表后，添加主键- ``` ALTER TABLE stu MODIFY id INT PRIMARY KEY; 自动增长 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 12345- 删除自动增长- ``` ALTER TABLE stu MODIFY id INT; 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; 123456789101112131415 - - 外键约束 - foreign key,让表与表产生关系，从而保证数据的正确性。 - 在创建表时，可以添加外键 - ``` create table 表名( .... --外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 删除外键 &#96;&#96;&#96;ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;12345- 创建表之后，添加外键 - ``` ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作 添加级联操作 &#96;&#96;&#96;语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ;12345678910111213141516171819202122232425262728293031 - 分类： - 级联更新：ON UPDATE CASCADE - 级联删除：ON DELETE CASCADE ## 数据库的设计1. 多表之间的关系 1. 分类： 1. 一对一(了解)： - 如：人和身份证 - 分析：一个人只有一个身份证，一个身份证只能对应一个人 2. 一对多(多对一)： - 如：部门和员工 - 分析：一个部门有多个员工，一个员工只能对应一个部门 3. 多对多： - 如：学生和课程 - 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 2. 实现关系： 1. 一对多(多对一)： - 如：部门和员工 - 实现方式：在多的一方建立外键，指向一的一方的主键。 2. 多对多： - 如：学生和课程 - 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 3. 一对一(了解)： - 如：人和身份证 - 实现方式：一对一关系实现，可以在任意一方添加唯一（unique）外键指向另一方的主键。 3. 案例 多表之间的关系 分类： 一对一(了解)： 如：人和身份证 分析：一个人只有一个身份证，一个身份证只能对应一个人 一对多(多对一)： 如：部门和员工 分析：一个部门有多个员工，一个员工只能对应一个部门 多对多： 如：学生和课程 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 实现关系： 一对多(多对一)： 如：部门和员工 实现方式：在多的一方建立外键，指向一的一方的主键。 多对多： 如：学生和课程 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 一对一(了解)： 如：人和身份证 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 案例 – 创建旅游线路分类表 tab_category – cid 旅游线路分类主键，自动增长 – cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); – 创建旅游线路表 tab_route &#x2F;* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 *&#x2F; CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); &#x2F;*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 *&#x2F; CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT ‘男’, telephone VARCHAR(11), email VARCHAR(100) ); &#x2F;* 创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 *&#x2F; CREATE TABLE tab_favorite ( rid INT, – 线路id DATE DATETIME, uid INT, – 用户id – 创建复合主键 PRIMARY KEY(rid,uid), – 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); 2.数据库设计的范式 - 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 - 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 - 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 - 分类 - 第一范式（1NF）：每一列都是不可分割的原子数据项 - 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） - 几个概念： 1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号--&gt;姓名。 （学号，课程名称） --&gt; 分数 2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） -- &gt; 姓名 4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号--&gt;系名，系名--&gt;系主任 5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） - 主属性：码属性组中的所有属性 - 非主属性：除过码属性组的属性 - 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） ## 数据库的备份与还原 1. 命令行： - 语法： - 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 - 还原： 1. 登录数据库 2. 创建数据库 3. 使用数据库 4. 执行文件。source 文件路径 2. 图形化工具：","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MySQL基础","slug":"MySQL基础","date":"2022-03-22T03:13:04.000Z","updated":"2022-03-23T15:18:09.256Z","comments":true,"path":"2022/03/22/MySQL基础/","link":"","permalink":"http://example.com/2022/03/22/MySQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 – SQL 常见的数据库软件 MySQL MySQL数据库软件Mac安装 参考文献：https://www.jianshu.com/p/a8e4068a7a8a/ https://zhuanlan.zhihu.com/p/360858309 Mac卸载 参考文献：https://www.jianshu.com/p/276c1271ae14 配置 手动。 2. cmd--&gt; services.msc 打开服务的窗口 3. 使用管理员打开cmd * net start mysql : 启动mysql的服务 * net stop mysql:关闭mysql服务 Mac参考文献：https://blog.csdn.net/qq_36004521/article/details/80637886 MySQL登录 1. mysql -uroot -p密码 2. mysql -hip -uroot -p连接目标的密码 3. mysql –host&#x3D;ip –user&#x3D;root –password&#x3D;连接目标的密码 * MySQL退出 1. exit 2. quit Mac mysql的命令参考文献：https://www.jianshu.com/p/c4756bcd6cbc https://blog.csdn.net/qq_19484963/article/details/80431703 MySQL目录结构 MySQL安装目录：basedir&#x3D;”D:&#x2F;develop&#x2F;MySQL&#x2F;“ 1. 配置文件 my.ini MySQL数据目录：datadir&#x3D;”C:&#x2F;ProgramData&#x2F;MySQL&#x2F;MySQL Server 5.5&#x2F;Data&#x2F;“ * 几个概念 * 数据库：文件夹 * 表：文件 * 数据：数据 SQL基本概念什么是SQL Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3 种注释 单行注释: – 注释内容 或 # 注释内容(mysql 特有) 多行注释: &#x2F;* 注释 *&#x2F; SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 DDL:操作数据库、表1.操作数据库：CRUD1.C（Create）：创建 创建数据库： create database 数据库名称; 创建数据库，判断不存在，再创建： create database if not exists 数据库 名称 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 练习 创建db4数据库，判断是否存在，并制定字符集为gbk create database if not exists db4 character set gbk; 2.R（Retrieve）：查询 查询所有数据库的名称: - show databases; 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; 3.U(Update):修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; 4.D(Delete):删除 删除数据库 drop database 数据库名称; 判断数据库存在，存在再删除 drop database if exists 数据库名称; 5.使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 * use 数据库名称; 操作表1.C（Create）：创建 语法： create table 表名(列名1 数据类型1,列名2 数据类型2,….列名n 数据类型n); 注意：最后一列，不需要加逗号（,） 数据库类型： int：整数类型 age int, double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串 name varchar(20):姓名最大20个字符 zhangsan 8个字符 张三 2个字符 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); 复制表 create table 表名 like 被复制的表名; 2,R(Retrieve):查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; 3.U（Updata）：修改 修改表名 alter table 表名 rename to 新的表名; 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; 4.D（Delete）：删除 drop table 表名; drop table if exists 表名 ; 客户端图形化工具：SQLYog DML：增删改表中的数据1.添加数据 语法 insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,…值n); 除了数字类型，其他类型需要使用引号(单双都可以)引起来 2.删除数据 语法 select * from 表名; delete from 表名 [where 条件] 注意 如果不加条件，则删除表中所有记录。 如果要删除所有记录 delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 3.修改数据 语法 update 表名 set 列名1 &#x3D; 值1, 列名2 &#x3D; 值2,… [where 条件]; 注意 如果不加任何条件，则会将表中所有记录全部修改。 DQL：查询表中的记录 select * from 表名; 语法 select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 基础查询 多个字断查询 select 字段名1，字段名2… from 表名； 注意 如果查询所有字段，则可以使用*来替代字段列表。 去除重复： distinct select distinct 字段名1 from 表名; 1234567- ​ 计算列 - 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） - ``` select name,math,english,math+english from student; - ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 如果该字段为null后的替换值 表达式2。 起别名 as：as也可以省略 1select name,math,english,math + ifnull(english,0) as 总分 from student; 条件查询 where子句后跟条件 运算符 &#x2F;&gt;、&lt; 、&lt;&#x3D; 、&gt;&#x3D; 、&#x3D; 、&lt;&gt; BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; or 或 || not 或 ! 例子 123456789101112131415161718192021222324252627-- 查询年龄大于20岁SELECT * FROM student WHERE age &gt; 20;SELECT * FROM student WHERE age &gt;= 20;-- 查询年龄等于20岁SELECT * FROM student WHERE age = 20;-- 查询年龄不等于20岁SELECT * FROM student WHERE age != 20;SELECT * FROM student WHERE age &lt;&gt; 20;-- 查询年龄大于等于20 小于等于30SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30;SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30;SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 查询年龄22岁，18岁，25岁的信息SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25;SELECT * FROM student WHERE age IN (22,18,25);-- 查询英语成绩为nullSELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断SELECT * FROM student WHERE english IS NULL;-- 查询英语成绩不为nullSELECT * FROM student WHERE english IS NOT NULL; 1234567891011-- 查询姓马的有哪些？ likeSELECT * FROM student WHERE NAME LIKE &#x27;马%&#x27;;-- 查询姓名第二个字是化的人SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;-- 查询姓名是3个字的人SELECT * FROM student WHERE NAME LIKE &#x27;___&#x27;;-- 查询姓名中包含德的人SELECT * FROM student WHERE NAME LIKE &#x27;%德%&#x27;;","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"注解","slug":"注解","date":"2022-03-21T03:06:08.000Z","updated":"2022-03-22T03:09:19.683Z","comments":true,"path":"2022/03/21/注解/","link":"","permalink":"http://example.com/2022/03/21/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解概念：说明程序的。给计算机看的 注释：用文字描述程序的。给程序员看的 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 概念描述： * JDK1.5之后的新特性 * 说明程序的 * 使用注解：@注解名称 作用分类： ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】 ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 DK中预定义的一些注解 * @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 * @Deprecated：该注解标注的内容，表示已过时 * @SuppressWarnings：压制警告 * 一般传递参数all @SuppressWarnings(“all”) 自定义注解 格式： 元注解 public @interface 注解名称{ 属性列表; } 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 * public interface MyAnno extends java.lang.annotation.Annotation {} 属性：接口中的抽象方法 属性的返回值类型有下列取值 * 基本数据类型 * String * 枚举 * 注解 * 以上类型的数组 定义了属性，在使用时需要给属性赋值 1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 元注解：用于描述注解的注解 @Target：描述注解能够作用的位置 ElementType取值： TYPE：可以作用于类上 METHOD：可以作用于方法上 FIELD：可以作用于成员变量上 @Retention：描述注解被保留的阶段 @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 参考Java运行三个阶段 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 在程序使用(解析)注解：获取注解中定义的属性值 1. 获取注解定义的位置的对象 （Class，Method,Field） 1. public class ProImpl implements Pro&#123; public String className()&#123; return &quot;cn.itcast.annotation.Demo1&quot;; &#125; public String methodName()&#123; return &quot;show&quot;; &#125; &#125; 3. 调用注解中的抽象方法获取配置的属性值 1. 2. 获取指定的注解 * getAnnotation(Class) //其实就是在内存中生成了一个该注解接口的子类实现对象 案例：简单的测试框架 小结： 以后大多数时候，我们会使用注解，而不是自定义注解 注解给谁用？ 编译器 给解析程序用 注解不是程序的一部分，可以理解为注解就是一个标签","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"MQTT基础协议（上）","slug":"MQTT基础协议（上）","date":"2022-03-20T18:37:12.000Z","updated":"2022-03-20T18:44:14.033Z","comments":true,"path":"2022/03/21/MQTT基础协议（上）/","link":"","permalink":"http://example.com/2022/03/21/MQTT%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/","excerpt":"","text":"1.1 MQTT是什么MQTT是一个客户端服务端架构的发布&#x2F;订阅模式的消息传输协议。它的设计思想是轻巧、开放、简单、规范，易于实现。这些特点使得它对很多场景来说都是很好的选择，特别是对于受限的环境如机器与机器的通信（M2M）以及物联网环境（IoT）。 易于实现 数据传输的服务质量可控 占用带宽小 传输数据内容不可预知 设备连接状态可知 目前MQTT主流版本有两个，分别是MQTT3.1.1和MQTT5。MQTT3.1.1是在2014年10月发布的，而MQTT5是在2019年3月发布的。由于MQTT3.1.1与MQTT5的时间相差了将近五年，且MQTT5的发布时间距今不久，因此在本文书写时（2020年10月），MQTT3.1.1仍然主流版本。","categories":[],"tags":[{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"}]},{"title":"Junit和反射和注解","slug":"Junit和反射和注解","date":"2022-03-20T08:54:35.000Z","updated":"2022-03-20T13:39:55.668Z","comments":true,"path":"2022/03/20/Junit和反射和注解/","link":"","permalink":"http://example.com/2022/03/20/Junit%E5%92%8C%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"Junit单元测试：测试分类： 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 白盒测试：需要写代码的。关注程序具体的执行流程。 Junit使用：白盒测试 步骤 1.定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2.定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3.给方法加@Test 4.导入junit依赖环境 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 1Assert.assertEquals(期望的结果,运算的结果); 补充： @Before: 修饰的方法会在测试方法之前被自动执行 用于资源的申请 @After: 修饰的方法会在测试方法执行之后自动被执行 用于资源的释放 反射：框架设计的灵魂框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 反射：将类的各个组成部分封装为其他对象，这就是反射机制 ​ 好处 可以在程序运行过程中，操作这些对象。代码提示也是利用特性 可以解耦，提高程序的可扩展性。 获取Class对象的方法： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 结论 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 Class对象功能： ​ 获取功能： 1. 获取成员变量们 Field[] getFields() ：获取所有public修饰的成员变量 Field getField(String name) 获取指定名称的 public修饰的成员变量 Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取构造方法们 Constructor&lt;?&gt;[] getConstructors() Constructor getConstructor(类&lt;?&gt;… parameterTypes) Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) Constructor&lt;?&gt;[] getDeclaredConstructors() 获取成员方法们： Method[] getMethods() Method getMethod(String name, 类&lt;?&gt;… parameterTypes) Method[] getDeclaredMethods() Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取全类名 String getName() 1.获取成员变量方法参数 Field：成员变量 ​ 操作： 设置值 void set(Object obj, Object value) 获取值 get(Object obj) 忽略访问权限修饰符的安全检查 setAccessible(true):暴力反射 2.获取构造方法参数 Constructor:构造方法 ​ 创建对象： T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 3.获取成员方法参数 Method：方法对象 ​ 执行方法： Object invoke(Object obj, Object… args) （参数，实参列表） 获取方法名称： String getName:获取方法名","categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"}]},{"title":"操作系统概述","slug":"操作系统概述","date":"2022-03-20T06:13:34.000Z","updated":"2022-03-20T14:08:36.978Z","comments":true,"path":"2022/03/20/操作系统概述/","link":"","permalink":"http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","excerpt":"","text":"为什么要学习操作系统 目的你体内的 “编程力量” 尚未完全觉醒 每天都在用的东西，你还没搞明白 窗口是怎么创建的？为什么 Ctrl-C 有时不能退出程序？ 组里的服务器有 128 个处理器，但你的程序却只能用一个 😂 你每天都在用的东西，你却实现不出来 浏览器、编译器、IDE、游戏&#x2F;外挂、任务管理器、杀毒软件、病毒…… 什么是操作系统 操作系统：事实上，是一个软件体系，负责使程序易于运行（甚至让你看起来可以同时运行多个程序），允许程序共享内存，允许程序与设备交互，以及其他类似的有趣事情。 管理软&#x2F;硬件资源、为程序提供服务” 的程序 理解操作系统 问出正确的问题：操作系统如何从一开始变成现在这样的？ 三个重要的线索 计算机 (硬件) 程序 (软件) 操作系统 (管理软件的软件) 本课程狭义的操作系统 例：win liunx 1940s的计算机电子计算机的实现 逻辑门：真空电子管 存储器：延迟线 (delay lines) 输入&#x2F;输出：打孔纸带&#x2F;指示灯 没有操作系统 能把程序放上去就很了不起了 程序直接用指令操作硬件 不需要画蛇添足的程序来管理它 1950s计算机更快更小的逻辑门 (晶体管)、更大的内存 (磁芯)、丰富的 I&#x2F;O 设备 I&#x2F;O 设备的速度已经严重低于处理器的速度，中断机制出现 (1953) 1960s计算机集成电路、总线出现 更快的处理器 更快、更大的内存；虚拟存储出现 可以同时载入多个程序而不用 “换卡” 了 更丰富的 I&#x2F;O 设备；完善的中断&#x2F;异常机制 1960s操作系统能载入多个程序到内存且灵活调度它们的管理程序，包括程序可以调用的 API。 同时将多个程序载入内存是一项巨大的能力 有了进程 (process) 的概念 进程在执行 I&#x2F;O 时，可以将 CPU 让给另一个进程 在多个地址空间隔离的程序之间切换 虚拟存储使一个程序出 bug 不会 crash 整个系统 操作系统中自然地增加进程管理 API 基于中断 (例如时钟) 机制 时钟中断：使程序在执行时，异步地插入函数调用 由操作系统 (调度策略) 决定是否要切换到另一个程序执行 Multics (MIT, 1965) 现代操作系统诞生 1970s+计算机和操作系统和现代大差不差 今天的操作系统通过 “虚拟化” 硬件资源为程序运行提供服务的软件。 空前复杂的系统之一 更复杂的处理器和内存 非对称多处理器 (ARM big.LITTLE; Intel P&#x2F;E-cores) Non-uniform Memory Access (NUMA) 更多的硬件机制 Intel-VT&#x2F;AMD-V, TrustZone&#x2F;SGX, TSX, … 更多的设备和资源 网卡、SSD、GPU、FPGA… 复杂的应用需求和应用环境 服务器、个人电脑、智能手机、手表、手环、IoT&#x2F;微控制器…… 理解操作系统：三个根本问题操作系统服务谁？ 程序 &#x3D; 状态机 课程涉及：多线程 Linux 应用程序 (设计&#x2F;应用视角) 操作系统为程序提供什么服务？ 操作系统 &#x3D; 对象 + API 课程涉及：POSIX + 部分 Linux 特性 (实现&#x2F;硬件视角) 如何实现操作系统提供的服务？ 操作系统 &#x3D; C 程序 完成初始化后就成为 interrupt&#x2F;trap&#x2F;fault handler 课程涉及：xv6, 自制迷你操作系统 如何学习操作系统计算机专业学生必须具备的核心素质。 是一个合格的操作系统用户 会 STFW&#x2F;RTFM 自己动手解决问题 不怕使用任何命令行工具 vim, tmux, grep, gcc, binutils, … 不惧怕写代码 能管理一定规模 (数千行) 的代码 能在出 bug 时默念 “机器永远是对的、我肯定能调出来的” 然后开始用正确的工具&#x2F;方法调试 给 “学渣” 们的贴心提示：补基础、补基础、补基础","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"模块化","slug":"模块化","date":"2022-03-19T08:51:45.000Z","updated":"2022-03-20T05:53:50.771Z","comments":true,"path":"2022/03/19/模块化/","link":"","permalink":"http://example.com/2022/03/19/%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"1.模块化1.1 模块化概述Java语言随着这些年的发展已经成为了一门影响深远的编程语言，无数平台，系统都采用Java语言编写。但是，伴随着发展，Java也越来越庞大，逐渐发展成为一门“臃肿”的语言。而且，无论是运行一个大型的软件系统，还是运行一个小的程序，即使程序只需要使用Java的部分核心功能，JVM也要加载整个JRE环境。为了给Java“瘦身”，让Java实现轻量化，Java 9正式的推出了模块化系统。Java被拆分为N多个模块，并允许Java程序可以根据需要选择加载程序必须的Java模块，这样就可以让Java以轻量化的方式来运行其实，Java 7的时候已经提出了模块化的概念，但由于其过于复杂，Java 7，Java 8都一直未能真正推出，直到Java9才真正成熟起来。对于Java语言来说，模块化系统是一次真正的自我革新，这种革新使得“古老而庞大”的Java语言重新焕发年轻的活力 1.2 模块的基本使用步骤模块的使用步骤 在项目中创建两个模块。一个是myOne,一个是myTwo 在myOne模块中创建以下包和以下类，并在类中添加方法 在myTwo模块中创建以下包和以下类，并在类中创建别的模块对象并使用 在myOne模块中src目录下，创建module-info.java，并写入exports+包名 在myTwo模块中src目录下，创建module-info.java，并写入require+模块名 如果出错，按下alt+enter 选择依赖 1.3 模块服务的使用模块服务使用使用步骤 在myOne模块中新建一个包，提供一个接口和两个实现类 在myOne模块中修改module-info.java文件，添加以下内容 导出模块：export com.itheima_03; 服务提供：provides MyService with itheima; 指定MyService的服务实现类是itheima 在myTwo这个文件的描述文件中添加如下配置 声明服务接口：uses MyService 在myTwo这个模块的类中使用MySerrive结构提供的服务 ServiceLoader：一种加载服务实现的工具","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"野格","slug":"野格","date":"2022-03-19T02:12:34.000Z","updated":"2022-03-22T15:57:02.042Z","comments":true,"path":"2022/03/19/野格/","link":"","permalink":"http://example.com/2022/03/19/%E9%87%8E%E6%A0%BC/","excerpt":"","text":"野格酒标上的单词来自德语单词 jager代表猎人 meister代表大师的意思 酿酒历史第一代酿酒人柯特*迈斯特是一位英勇的猎手，野格的前生并不是酒，而是印有鹿头的止咳药水，德国冬天异常寒冷，猎人在行动时容易染上风寒，为了解决这个问题，野格一代目在止咳水的基础上，添加了酒精，配上一些帮助消化，缓解呼吸道症状的草药来帮助猎手，猎手在行动中容易掉装备，所有选择这种最抗摔的墨绿色方瓶子，到1934年，纳粹德国颁布了帝国狩猎法，在这个法律中规定只有最杰出的猎手，才可以冠名“猎人大师“的名号，野格一代目也是在这是创建了商标，赚了一波热度 鹿头来源基督教中的两位猎人守护神，传闻中他们皈依耶稣时，看到了圣鹿出现在十字架中央 成分德国本土草本利口酒，其中成分含有56种不同的药材，水果，植物根茎以及辛香料 已公开的有杜松子，人参，甘草，肉桂，茴香，生姜，柑橘类果皮等等 制作工艺野格采用风干材料，把晒干的草本在中性酒精里浸泡三天，得到基础的香气以及颜色，整个浸泡工序要反反复复进行多次，大概要持续五个月，才进行首次过滤，放到橡木桶里进行陈年，经过365天的窖藏，药草酒得到了进一步成熟，酒液里杂醇类物质也会被逐渐分解，提高整体的口感，特别是经过橡木桶的润色之后，这个野格的酒体颜色会变更加深邃，同时减少草本植物带来的青涩味道，增强酒体结构，更加突出橡木的香气与果香，野格35度并不是来自蒸馏，它是在桶成一年后再次加入中性酒精，水，焦糖以及白砂糖，最终调整成品， 为什么加酒精光他本身的材料没有足够的糖分无法合成很多的酒精，所以要加中性酒精。 两大配方用料草本风味来自 甘草 增加天然甜味 药用价值 甘草素野格甜味之一，当年糖值钱 葑酮，香水中会用 茴香稀，遇水乳化，使酒浑浊乳白色 茴香 重要香料 大量茴香稀 拧烯，提供柠檬香气 桉油醇，樟脑丸气息","categories":[],"tags":[{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"}]},{"title":"类加载器和反射","slug":"类加载器和反射","date":"2022-03-17T07:32:30.000Z","updated":"2022-03-20T13:39:54.105Z","comments":true,"path":"2022/03/17/类加载器和反射/","link":"","permalink":"http://example.com/2022/03/17/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8D%E5%B0%84/","excerpt":"","text":"1.类加载器1.1 类加载当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化 类的加载 就是指将class文件读入内存，并为之创建一个java.lang.Class对象 任何类被使用时，系统都会为之建立一个java.lang.Class对象 类的连接 验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致 准备阶段：负责为类的类变量分配内存，并设置默认初始化值 解析阶段：将类的二进制数据中的符号引用替换为直接引用 类的初始化 在该阶段，主要就是对类变量进行初始化 类的初始化步骤 假如类还未被加载和连接，则程序先加载并连接该类 假如该类的直接父类还未被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 注意：在执行第2个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤1-3 类的初始化时机 创建类的实例 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 1.2 类加载器类加载器作用 负责将.class文件加载到内存中，并为之生成对应的java.lang.Class对象。 虽然我们不用过分关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行！ JVM的类加载机制 全盘负责：就是当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托：就是当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类 缓存机制：保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存储到缓存区 Java中内置类加载器 Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为null，并且没有父null Platform class loader：平台类加载器可以看到所有平台类，平台类包括由平台类加载器或其祖先定义的JavaSE平台API，其实现类和JDK特定的运行时类 System class loader：它也被称为应用程序类加载器，与平台类加载器不同。系统类加载器通常用于定义应用程序类路径，模块路径和JDK特定工具上的类 类加载器的继承关系：System的父加载器为Platform，而Platform的父加载器为Bootstrap ClassLoader中的两个方法 static ClassLoader getSystemClassLoader() 返回用于委派的系统类加载器 ClassLoader getParent() 返回父类加载器进行委派 1234567891011121314public class ClassLoaderDemo&#123;public static void main(String[]args)&#123; //static ClassLoader getSystemClassLoader():返回用于委派的系统类加载器 ClassLoader c = ClassLoader.getSystemClassLoader(); System.out.println(c);//AppClassLoader //ClassLoader getParent():返回父类加载器进行委派 ClassLoader c2 = c.getParent(); System.out.println(c2); //PlatformClassLoader ClassLoader c3 = c2.getParent(); System.out.println(c3);//null &#125;&#125; 2.反射2.1 反射的概述 是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以扩展 可以访问一些类的私有成员 2.2 获取class类的对象三种方法 类名.class属性 对象名.getClass()方法 该方法是Object类中方法，所有Java对象都可以调用此方法 Class.forName(全类名)方法，需要传入字符串参数，该字符串参数是某个类的全路径，也是完整包名的路径 123456789101112131415161718192021public class ReflectDemo&#123; public static void main(String[] args)throwsClassNotFoundException&#123;//使用类的class属性来获取该类对应的Class对象 Class&lt;Student&gt;c1=Student.class; System.out.println(c1); Class&lt;Student&gt;c2=Student.class; System.out.println(c1==c2); System.out.println(&quot;--------&quot;); //调用对象的getClass()方法，返回该对象所属类对应的Class对象 Student s = new Student(); Class&lt;? extends Student&gt; c3 = s.getClass(); System.out.println(c1==c3); System.out.println(&quot;--------&quot;); //使用Class类中的静态方法 forName(String className) Class&lt;?&gt; c4 = Class.forName(&quot;com.itheima_02.Student&quot;); System.out.println(c1 == c4); &#125;&#125; 2.3 反射获取构造方法并使用Class类获取构造方法对象的方法 Constructor&lt;?&gt;[] getConstructors() 返回所有公共构造方法对象的数组 Constructor&lt;?&gt;[] getDeclaredConstructors() 返回所有构造方法对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 返回单个公共构造方法对象 Constructor getDeclaredConstructor(Class&lt;?&gt;…parameterTypes) 返回单个构造方法对象 12345678910111213141516171819202122232425//获取Class对象 Class&lt;?&gt;c=Class.forName(&quot;com.itheima_02.Student&quot;);//Constructor&lt;?&gt;[] getConstructors() 返回一个包含 Constructor对象的数组，Constructor对象反映了由该Class对象表示的类的所有公共构造函数、 Constructor&lt;?&gt;[]cons=c.getConstructors();//Constructor&lt;?&gt;[]getDeclaredConstructors()返回反映由该Class对象表示的类声明的所有构造函数的Constructor对象的数组 Constructor&lt;?&gt;[] cons = c.getDeclaredConstructors(); for(Constructor con : cons)&#123; System.out.println(con);&#125; System.out.println(&quot;--------&quot;);//Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;...parameterTypes) 返回一个Constructor对象，该对象反映由该Class对象表示的类的指定公共构造函数//参数：你要获取的构造方法的参数的个数和数据类型对应的字节码文件对象 Constructor&lt;?&gt; con = c.getConstructor();//Constructor提供了一个类的单个构造函数的信息和访问权限//T newInstance(Object...i nitargs) 使用由此 Constructor 对象表示的构造函数，使用指定的初始化参数来创建和初始化构造函数的声明类的新实例 Object obj = con.newInstance(); System.out.println(obj); &#125;&#125; Constructor类用于创建对象的方法 T newInstance(Object…initargs) 根据指定的构造方法创建对象 2.4 反射获取构造方法并使用练习通过反射获取构造方法并创建对象 12345678910111213public class ReflectDemo02 &#123; public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException &#123; //获取Class类型 Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); //获取带三个参数带构造方法 Constructor&lt;?&gt; con = c.getConstructor(String.class, int.class, String.class); //创造新的对象 Object obj = con.newInstance(&quot;马宏跃&quot;,&quot;20&quot;,&quot;内蒙古&quot;); System.out.println(obj); &#125;&#125; 练习2 获取私有构造方法 12345678910 Class&lt;?&gt; c = Class.forName(&quot;com.itheima_02.Student&quot;); Constructor&lt;?&gt; con =c.getDeclaredConstructor(String.class); //暴力反射//public void setAccessible(booleanflag):值为true，取消访问检查 con.setAccessible(true); Object obj = con.newInstance(&quot;林青霞&quot;); Systeam.out.println(obj); 2.5 反射获取成员变量并使用方法 Field[] getFields() 返回所有公共成员变量对象的数组 Field[] getDeclaredFields() 返回所有成员变量对象的数组 Field getField(String name) 返回单个公共成员变量对象 Field getDeclaredField(String name) 返回单个成员变量对象 1234567891011121314151617181920public class ReflectDemo01 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; //获取对象 Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Field[] fields = c.getDeclaredFields(); for(Field field : fields)&#123; System.out.println(field); &#125; System.out.println(&quot;-----------&quot;); Field addressField = c.getField(&quot;address&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); addressField.set(obj,&quot;西安&quot;); System.out.println(obj); &#125;&#125; Field类中用于给成员变量赋值的方法 void set(Object obj,Object value) 给obj对象的成员变量赋值为value 2.6 反射获取成员变量并且使用练习1234567891011121314public class ReflectDemo02 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); Field nameField = c.getDeclaredField(&quot;name&quot;); //取消限制 nameField.setAccessible(true); nameField.set(obj,&quot;马宏跃&quot;); System.out.println(obj); &#125;&#125; 2.7 反射获取成员方法并使用方法 Method[] getMethods() 返回所有公共成员方法对象的数组，包括继承的 Method[] getDeclaredMethods() 返回所有成员方法对象的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt;…parameterTypes) 返回单个公共成员方法对象 Method getDeclaredMethod(String name, Class&lt;?&gt;…parameterTypes) 返回单个成员方法对象 用于执行方法的方法 Objectinvoke(Object obj,Object… args) 调用obj对象的成员方法，参数是args,返回值是Object类型 123456789101112public class ReflectDemo01 &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, ClassNotFoundException &#123; Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Method m = c.getMethod(&quot;method1&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); m.invoke(obj); &#125;&#125; 2.8 反射获取成员方法并且使用练习12345678910111213141516171819public class ReflectDemo02 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; Class&lt;?&gt; c = Class.forName(&quot;com.itheima_01.Student&quot;); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); Method m2 = c.getMethod(&quot;method2&quot; , String.class); Object i2 = m2.invoke(obj,&quot;马宏跃&quot;); Method m3 = c.getMethod(&quot;method3&quot; , String.class, int.class); Object i3 = m3.invoke(obj,&quot;马宏跃&quot;,30); System.out.println(i3); Method f1 = c.getDeclaredMethod(&quot;function&quot;); f1.setAccessible(true); System.out.println(f1); &#125;&#125; 2.9 反射练习在Integer的集合中，加入字符串数据 1234567891011121314151617public class RelectTest_01 &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;(); array.add(10); array.add(20); Class&lt;? extends ArrayList&gt; c = array.getClass(); Method m = c.getMethod(&quot;add&quot; , Object.class); m.invoke(array,&quot;hello&quot;); m.invoke(array,&quot;world&quot;); m.invoke(array,&quot;Java&quot;); System.out.println(array); &#125;&#125; 练习2 通过配置文件来创建任何类，并且使用方法 1234567891011121314151617181920212223public class RelectTest_02 &#123; public static void main(String[] args) &#123; Properties prop = new Properties(); FileReader fr = new FileReader(&quot;MyReflect\\\\class.txt&quot;); prop.load(fr); fr.close(); String className = prop.getProperty(&quot;className&quot;); String methodName = prop.getProperty(&quot;methodName&quot;); /* className=com.itheima_05.Student methodName=study */ Class&lt;?&gt; c = Class.forName(className); Constructor&lt;?&gt; con = c.getConstructor(); Object obj = con.newInstance(); Method m = c.getMethod(methodName); m.invoke(obj); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"SUZE龙胆酒","slug":"SUZE龙胆酒","date":"2022-03-16T15:22:58.000Z","updated":"2022-03-16T15:41:31.697Z","comments":true,"path":"2022/03/16/SUZE龙胆酒/","link":"","permalink":"http://example.com/2022/03/16/SUZE%E9%BE%99%E8%83%86%E9%85%92/","excerpt":"","text":"SUZE龙胆酒一句话概括这是一种以龙胆植物作为主要原料，搭配了像香草，橙子，以及其他多种草药作为辅料的法国利口酒 味道苦中带甜，闻上去草本气息非常突出，还会有浓郁的花香，有甘草橙皮，姜黄的味道 原料龙胆植物，十年左右壮年龙胆 做法采摘后的龙胆需要切割，完了后放在食用酒精浸泡一年，然后取一部分龙胆根，挤成汁放进去一起蒸馏，最后和浸泡液一起调配，我们需要加水，加糖，大概稀释到20度左右进行装瓶 品牌故事费尔南德穆勒发明 起初接受家族酒厂生意不景气，遇到酿酒黑天鹅事件，根瘤蚜虫病，让很多葡萄酒白兰地行业受到很大打击，他和儿子进行发明，大胆使用龙胆发明 冰镇开胃，1889获得了世博会金奖，官网讲说他跟嫂子关系好，使用用嫂子的名字 推荐白尼格罗尼 喝法少数可以直接饮用，加冰块","categories":[],"tags":[{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"}]},{"title":"计算机的基本组成","slug":"计算机的基本组成","date":"2022-03-16T10:48:08.000Z","updated":"2022-03-24T07:00:45.839Z","comments":true,"path":"2022/03/16/计算机的基本组成/","link":"","permalink":"http://example.com/2022/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/","excerpt":"","text":"1.2 计算机的基本组成一. 冯.诺依曼计算机的特点 计算机由五大部件组成 运算器 控制器 存储器 输入设备 输出设备 指令和数据以同等地位存于存储器，可按地址寻址 混合存储 指令和数据用二进制表示 指令由操作码和地址码 存储程序（核心） 以运算器为中心 算数运算 逻辑运算 ![截屏2022-03-16 18.59.22](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机的基本组成&#x2F;截屏2022-03-16 18.59.22.png) 缺点：什么都要经过运算器，运算器过于繁忙 二.计算机硬件框图1.以存储器为中心的计算机硬件框图 系统复杂性管理方法（3Y） 层次化：将被设计的系统划分为多个模块或子模块 模块化：有明确定义的功能和接口 规则性：模块更容易被重用 三.计算机的工作步骤 上机前的准备 建立数学模型 确定计算方法 编制解题程序 程序–运算的全部步骤 指令–每一个步骤 指令格式：操作码+地址码 指令和数据都是保存着存储器中的 (1)存储器的基本组成存储体-存储单元-存储元件（0&#x2F;1） 大楼 - 房间 -床号 （无人&#x2F;有人） 存储单元 存放一串二进制代码 存储字 存储单元中二进制代码组合 存储字长 存储单元中二进制代码位数 ​ 每一个存储单元有一个地址 按地址寻址 MAR 地址寄存器，反映存储单元的个数 MDR 数据寄存器，反映存储字长 (2)运算器的基本组成及操作过程MQ 乘商寄存器 ACC 累加器 ALU 算术逻辑单元 X 操作寄存器 ![截屏2022-03-24 09.30.02](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机的基本组成&#x2F;截屏2022-03-24 09.30.02.png)","categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"Stream流","slug":"Stream流","date":"2022-03-16T08:42:39.000Z","updated":"2022-03-17T07:28:48.781Z","comments":true,"path":"2022/03/16/Stream流/","link":"","permalink":"http://example.com/2022/03/16/Stream%E6%B5%81/","excerpt":"","text":"1 Stream流1.1 体验Stream流使用Stream流的方式完成过滤操作 1list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println); 直接阅读代码的字面意思就可理解语意：生成流，过滤姓张，过滤长度为3，逐一打印 Stream流把真正的函数式风格引入Java中 1.2 Stream流的生成方式Stream流的使用 生成流 通过数据源（集合，数组等）生成流 list.stream() 中间操作 一个流后面可以跟随零个或多个中间操作，主要为了打开流，做出某种程度的数据过滤&#x2F;映射，然后返回一个新的流，交给下一个操作使用 filter() 终结操作 一个流只能有一个终结操作，当这个操作执行后，流就被使用“光”了，无法在被操作，所以这必定是流的最后一个操作 forEach() Stream流的常见生成方式 Collection 体系的集合可以使用默认方法stream()生成流 default Streamstream() Map体系的集合间接的生成流 数组可以通过Stream接口的静态方法of(T…..values)生成流 1234567891011121314151617181920212223public class StreamDemo &#123; public static void main(String[] args) &#123; //Collection体系集合可以使用默认stream()生成流 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); //Map体系集合间接生成流 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; IntStream = map.values().stream(); Stream&lt;Map.Entry&lt;String,Integer&gt;&gt; entryStream = map.entrySet().stream(); //数组可以通过Stream接口的静态方法of(T...values)生成流 String[] strArray = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Stream&lt;String&gt; strArrayStream = Stream.of(strArray); Stream&lt;String&gt; strArrayStream1 = Stream.of(&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;); Stream&lt;Integer&gt; inArrayStream = Stream.of(10,20,30); &#125;&#125; 1.3 Stream流的常见中间操作 Streamfilter(Predicate predicate): 用于对流中的数据进行过滤 Predicate接口中的方法 Boolean test(T t): 对给定的参数进行判断，返回一个布尔值 1list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println); Streamlimit(long maxSize): 返回此流中的元素组成的流，截取前指定参数个数数据 Streamskip(long n): 跳过指定参数个数数据，返回由该流的剩余元素组成的流 1list.stream().skip(2).limit(2).forEach(System.out::println); static Streamconcat(Stream a,Stream b): 合并a和b两个流为一个流 Stream distinct(): 返回由该流的不同元素(根据Object.equals(Object))组合的流 1Stream.concat(s1,s2).forEach(System.out::println); 1Stream.concat(s1,s2).distinct().forEach(System.out::println); Stream sorted(): 返回由此流的元素组成的流，根据自然顺序排序 Stream sorted(Comparator comparator): 返回由该流的元素组成的流，根据提供的Comparator进行排序 根据比较器来排序 1list.stream().sorted().forEach(System.out::println); 12345list.stream().sorted((s1,s2) -&gt; &#123; int num = s1.length()-s2.langth(); int num2 = num==0?s1.compareTo(s2):num; return num2;&#125;).forEach(System.out::println); Stream map(Function mapper): 返回由给定函数应用于此流的元素的结果组成的流 Function接口中的方法 R apply(T t) IntStream mapToInt(TonIntFunction mapper): 返回一个Instream其中包含将给定函数应用用于此流的元素结果 InStream：表示原始int流 ToIntFunction接口中的方法 int applyAsInt(T value) int sum(): 返回此流中元素总和 1list.stream().map(Integer::parseInt).forEach(System.out::println); 1int result = list.stream().mapTiInt(Intrger::parseInt).sum(); 1.4 Stream流的常见终结操作方法Stream流的常见终结操作方法 void forEach(Consumer action): 对此流的每一个元素执行操作 Consumer接口中的方法 void accept(T t): 对给定的参数执行此操作 ling count(): 返回此流中的元素数 1list.stream().forEach(System.out::println); 1long count = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).count(); 1.5 Stream流的收集操作Stream流的收集方法 R collect(Collector collector) 但是这个收集方法的参数是一个Collector接口 工具类Collectors提供了具体的收集方法 public static Collector toList(): 把元素收集到List集合中 public static Collector toSet(): 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper): 把元素收集到Map集合中 1list&lt;String&gt; names = listStream.collect(Collectors.tolist()); 1Map&lt;String,Integer&gt; map = arrsyStream.collect(Collectors.toMap(s -&gt; s.split(&quot;,&quot;)[0]),s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) );","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"百利甜","slug":"百利甜","date":"2022-03-15T15:06:50.000Z","updated":"2022-03-15T15:46:16.948Z","comments":true,"path":"2022/03/15/百利甜/","link":"","permalink":"http://example.com/2022/03/15/%E7%99%BE%E5%88%A9%E7%94%9C/","excerpt":"","text":"百利甜 Baileys特点 香甜滑腻，充满了奶油的风味质感 原因：酒液里添加了优质的爱尔兰奶油，顺便还搭配了一些可可，香草的提取物来丰富他们的味道层次 酒精来自爱尔兰本地的威士忌 在一众利口酒中属于酒精度偏低的一类，仅有17%左右的酒精含量 历史 由帝亚吉欧的前身国际蒸馏酒公司出品 创始人汤姆·贾戈在20世纪70年代经过一系列的调研，先后研发出两款酒，马利宝椰子朗姆酒，百利奶油甜酒 时代背景，以前威士忌不受欢迎，被吐槽为“像白水一样寡淡”，另外爱尔兰奶制品十分发达，产能过剩，启发了发明的研发团队，做出奶+酒的尝试 基酒 特别选用以玉米为主导的爱尔兰威士忌，所以会让酒液富含更多奶油香草气息 百利甜的威士忌基酒都是需要三年桶陈的，很少见 这些基酒会提前添加可可，香草提取物，并且用焦糖上色 爱尔兰奶油，牛奶会过的十分舒服 调酒过程 由于酒和奶的密度不同，百利甜需要一些专业的均质机进行混合才能保证成品不会分层 由于它本身高糖，低酒精的特点容易造成酒体不稳定 成分检验十分严格 注意事项 酒液比较娇贵，放在阴凉避光处 高糖低酒精，带有蛋奶成分的酒更加容易变质 采用深色瓶子罐装 不开封保质期两年 利口酒最好在开封后一个月内快速消灭 复杂性和平衡度 百利甜很甜，很奶，但处了奶油的口感之外没有其他的风味表达 混合鸡尾酒非常容易破坏饮品的平衡度 参考文献https://www.bilibili.com/video/BV1KK4y1S7E7?spm_id_from=333.1007.top_right_bar_window_history.content.click","categories":[],"tags":[{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"}]},{"title":"计算机系统简介","slug":"计算机系统简介","date":"2022-03-15T09:23:04.000Z","updated":"2022-03-15T10:16:06.287Z","comments":true,"path":"2022/03/15/计算机系统简介/","link":"","permalink":"http://example.com/2022/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"第一章计算机系统概论1.1计算机系统简介现代计算机系统是由哪两部分组成？ 硬件 计算机实体，如主机，外设 软件 由具有各类特殊功能的信息(程序)组成 软件分类 软件：用来管理整个计算机系统 语言处理程序 操作系统 服务性程序 数据库管理系统 网络软件 应用软件 按任务需要编制成各种程序 ![截屏2022-03-15 17.42.26](&#x2F;Users&#x2F;mhy&#x2F;blog&#x2F;source&#x2F;_posts&#x2F;计算机系统简介&#x2F;截屏2022-03-15 17.42.26.png) 系统复杂性管理的方法—–抽象：指高级的模型，和低级的实体相对，隐藏系统中不重要的细节 二 计算机系统的层次结构 计算机体系结构：程序员所见到的计算机系统的属性概念性的结构与功能特性 （指令系统，数据类型，寻找技术，I&#x2F;O机理） 例：有无乘法指令 计算机组成：实现计算机体系结构所体现的属性 （具体指令的实现） 例：如何实现乘法指令","categories":[],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"函数式接口","slug":"函数式接口","date":"2022-03-15T07:01:28.000Z","updated":"2022-03-16T08:41:59.322Z","comments":true,"path":"2022/03/15/函数式接口/","link":"","permalink":"http://example.com/2022/03/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"1 函数式接口有且仅有一个抽象方法接口 Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口，只有确保接口中有且只有一个抽象方法，Java中的Lambda才能顺利地进行推导 command+B 可以看源码 看注解判断是否为函数式接口 option+command+v 补足代码 1234@FunctionalInterface//函数式接口注解public interface myInterface &#123; void show();&#125; 123456public class myInterfaceDemo &#123; public static void main(String[] args) &#123; myInterface my = () -&gt; System.out.println(&quot;函数式接口&quot;); my.show(); &#125;&#125; 1.2 函数式接口作为方法的参数如果方法的参数是一个函数式接口，我们可以使用Lambda表达式作为参数传递 1startThread(() -&gt; System.out.println(Thread.currentTgread&#123;&#125;.getname()+&quot;线程启动了&quot;)) 1.3 函数式接口作为方法的返回值12345678910111213141516private static Comparator&lt;String&gt; getComparator()&#123; //方法一 return new Comparator&lt;String&gt;()&#123; @Override public int compare(String s1,String s2)&#123; return s1.length()-s2.length(); &#125; &#125; //方法二 return (String s1,String s2) -&gt; &#123; return s1.length()-s2.length(); &#125;; //方法三 return (s1,s2) -&gt; s1.length() - s2.length();&#125; 如果方法的返回值是一个函数式接口，我们可以使用Lambda表达式作为结果返回 1.4常用的函数式接口重点有以下几个 Supplier接口 Consumer接口 Predicate接口 Function接口 1.5 SupplierSupplier：包含一个无参的方法 T get():获得结果 要导包 该方法不需要参数，他会按照某种实现逻辑（由Lambda表达式实现）返回一个数据 Supplier接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会生成什么类型的数据供我们使用 1234//定义一个方法，返回一个整数数据private static Integer getInteger(Supplier&lt;Integer&gt; sup)&#123; return sup.get();&#125; Tips： 装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型 直观的使用上的区别：基本数据类型不能为null，而包装器类可以为null 1234567891011121314151617181920public class SupplierText &#123; public static void main(String[] args) &#123; int[] arr = &#123;19,50,28,37,46&#125;; int Maxx = getMax(() -&gt; &#123; int Max = arr[0]; for (int i=1;i&lt;arr.length;i++)&#123; if(arr[i]&gt;Max)&#123; Max = arr[i]; &#125; &#125; return Max; &#125;); System.out.println(Maxx); &#125; private static int getMax(Supplier&lt;Integer&gt; sub)&#123; return sub.get(); &#125;&#125; 1.6 Consumer接口Consumer：包含两个方法 void accrpt：对给定的参数执行此操作 default ConsumerandThen(Consumer after)：返回一个组合的Consumer，依次执行此操作，如何执行after操作 Consumer接口也被称为消费型接口，它消费的数据的数据类型由泛型指定 1234567891011121314151617181920212223public class ConsumerDemo &#123; public static void main(String[] args) &#123; operatorString(&quot;马宏跃&quot;,(String s) -&gt; &#123; System.out.println(s); &#125;);//消费一次 operatorString(&quot;马宏跃&quot;,s -&gt; System.out.println(s));//消费两次 operatorString(&quot;马宏跃&quot;,s -&gt; System.out.println(s),s -&gt; System.out.println(new StringBuffer(s).reverse().toString())); &#125; private static void operatorString(String name,Consumer&lt;String&gt; num,Consumer&lt;String&gt; nbm)&#123; //方法一 num.accept(name); nbm.accept(name); //方法二 num.andThen(nbm).accept(name); &#125;//消费一次 private static void operatorString(String name, Consumer&lt;String&gt; sum)&#123; sum.accept(name); &#125;&#125; 练习 将字符串分离，按照格式打开 12345678910111213141516171819public class ConsumerTest &#123; public static void main(String[] args) &#123; String[] strArray = &#123;&quot;马宏跃,20&quot;,&quot;杜宇卓,19&quot;,&quot;卢世文,19&quot;&#125;; printInfo(strArray,(String str) -&gt; &#123; String name = str.split(&quot;,&quot;)[0]; System.out.print(&quot;姓名&quot;+name); &#125;,(String str) -&gt; &#123; int age = Integer.parseInt(str.split(&quot;,&quot;)[1]); System.out.println(&quot;,年龄&quot;+age); &#125;); &#125; private static void printInfo(String[] Array, Consumer&lt;String&gt; sum1,Consumer&lt;String&gt; sum2)&#123; for(String str : Array)&#123; sum1.andThen(sum2).accept(str); &#125; &#125;&#125; 1.7 Predicate接口Predicate: 常用的四个方法 boolean test(T t): 对给定的参数进行判断(判断逻辑由Lambda表达式实现)，返回一个布尔值。 default Predicatenegate: 返回一个逻辑的否定，对应逻辑非 default Predicateand(Predicate other): 返回一个组合判断，对应短路与 default Predicateor(Predicate other): 返回一个组合判断，对应短路或 Predicate接口通常用于判断参数是否满足指定的条件 12345678910111213public class PreducateDemo &#123; public static void main(String[] args) &#123; boolean b1 = checkString(&quot;hello&quot;,s -&gt; s.length()&gt;5); System.out.println(b1); &#125; private static boolean checkString(String s, Predicate&lt;String&gt; pr)&#123; //正常逻辑 //return pr.test(s); //逻辑非 return pr.negate().test(s); &#125;&#125; 1234567891011public class PreductDemo_01 &#123; public static void main(String[] args) &#123; boolean b1 = checkString(&quot;hello&quot;,s -&gt; s.length()&gt;5,s -&gt; s.length()&lt;12); System.out.println(b1); &#125; private static boolean checkString(String s, Predicate&lt;String&gt; pr1,Predicate&lt;String&gt; pr2)&#123; // return pr1.and(pr2).test(s); return pr1.or(pr2).test(s); &#125;&#125; 练习 筛选满足条件的数据 1234567891011121314151617181920public class PreductTest &#123; public static void main(String[] args) &#123; String[] str0 = &#123;&quot;马宏跃,187&quot;,&quot;雷惊讶,160&quot;,&quot;龙宇凡,183&quot;,&quot;张被轮,183&quot;,&quot;李瑞,158&quot;,&quot;卢世文,184&quot;&#125;; ArrayList&lt;String&gt; Str4 = checkString(str0,s -&gt;s.split(&quot;,&quot;)[0].length()&gt;2, s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1])&gt;180); System.out.println(Str4); &#125; private static ArrayList&lt;String&gt; checkString(String[] strArray, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)&#123; ArrayList&lt;String&gt; str1 = new ArrayList&lt;String&gt;(); for(String str2:strArray)&#123; if(pre1.and(pre2).test(str2))&#123; str1.add(str2); &#125; &#125; return str1; &#125;&#125; 1.8 Function接口Funtion&lt;T,R&gt;: 常用的两种方法 R apply(T t): 将此函数应用于给定的参数 default Function andThen(Function after): 返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果 Function&lt;T,R&gt; 函数通常用于对参数进行处理，转换(处理逻辑由Lambda表达式实现)，然后返回一个新的值 12345678910public class FunctionDemo &#123; public static void main(String[] args) &#123; convert(&quot;110&quot;,s -&gt; Integer.parseInt(s)); &#125; private static void convert(String A, Function&lt;String,Integer&gt; fun1)&#123; int i = fun1.apply(A); System.out.println(i); &#125;&#125; 1String ss = fun1.andThen(fun2).apply(s); 练习 按照要求转换 加数字 1234567891011public class FunctionTest &#123; public static void main(String[] args) &#123; String s = &quot;马宏跃,20&quot;; convert(s,ss -&gt; ss.split(&quot;,&quot;)[1],ss -&gt; Integer.parseInt(ss),i -&gt; i+80); &#125; private static void convert(String s, Function&lt;String,String&gt; fun1,Function&lt;String,Integer&gt; fun2,Function&lt;Integer,Integer&gt; fun3)&#123; int i = fun1.andThen(fun2).andThen(fun3).apply(s); System.out.println(i); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"方法引用","slug":"方法引用","date":"2022-03-14T11:30:40.000Z","updated":"2022-03-15T06:42:31.767Z","comments":true,"path":"2022/03/14/方法引用/","link":"","permalink":"http://example.com/2022/03/14/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"1 方法引用1.1体验方法引用![截屏2022-03-14 下午7.33.44](&#x2F;方法引用&#x2F;截屏2022-03-14 下午7.33.44.png) 12345usePrintable(s -&gt; System.out.println(s));//方法引用符 ：：usePrintable(System.out::Println);//可推导就是可以省略的//上面两条语句输出内容相同 1.2方法引用符方法引用符 ::该符号为引用运算符，而它所在的表达式被称为方法引用 推导与省略 如果使用方法引用，和Lambda一样，可以进行上下文进行推导 方法引用是Lambda的孪生兄弟 1.3 Lambda表达式支持的方法引用常见的引用方法 引用类方法 引用对象的实例方法 引用类的实例方法 引用构造器 1.4 引用类方法引用类方法，其实就是引用类的静态方法 格式：类名::静态方法 范例：Integer::parseInt ​ Integer类的方法：public static int parsenInt(String s) 将String转换为int数据类型 练习![截屏2022-03-15 上午9.11.42](&#x2F;方法引用&#x2F;截屏2022-03-15 上午9.11.42.png) 1234接口Converterpublic interface Converter &#123; int convert(String s);&#125; 1234567891011121314测试类ConverterDemo.javapublic class ConverterDemo &#123; public static void main(String[] args) &#123; useConverter(s -&gt; Integer.parseInt(s)); //用引用类方法 useConverter(Integer::parseInt); &#125; private static void useConverter(Converter c)&#123; int number = c.convert(&quot;666&quot;); System.out.println(number); &#125;&#125; Lambda表达式被类方法替代的时候，他的形式参数全部传递给静态方法作为参数 1.5引用对象的实例方法 格式：对象::成员方法 范例：“HelloWorld”::toUpperCase 1usePrinter(s -&gt; Systrm.out.println(s.toUppercase())) 12PrintString ps = new printString();usePrinter(ps::printUpper); Lambda表达式被对象的实例方法替代的时候，他的形式参数全部传递给该方法作为参数 1.6引用类的实例方法 格式：类名::成员方法 范例：String::substring String类中的substring方法 1useMyString((s,x,y) -&gt; s.substring(x,y)); 12//引用类的实例方法useMyString(String::substring); Lambda表达式被类的实例方法替代的时候，第一个参数作为调用者，后面的参数全部传递给该方法作为参数 1.7引用构造器引用构造方法 格式：类名::new 范例：Student::new Student是一个类 1useStudentBuilder((name,age) -&gt; new Student(name,age)); 12//引用构造器useStudentBuilder(Student::new); Lambda表达式被构造器替代时，他的形式参数全部传递给构造器作为参数","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"接口的组成更新","slug":"接口的组成更新","date":"2022-03-14T10:33:49.000Z","updated":"2022-03-14T11:29:42.210Z","comments":true,"path":"2022/03/14/接口的组成更新/","link":"","permalink":"http://example.com/2022/03/14/%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0/","excerpt":"","text":"1.接口的组成更新1.1 接口组成更新概述接口的组成 常量 ​ -public static final 抽象方法 ​ -public abstract 默认方法（Java 8） 静态方法（Java 8） 私有方法（Java 9） 1.2接口中默认方法定义格式 格式：public default 返回值类型 方法名(参数列表){ } 范例：public default void show3(){ } 注意事项 默认方法不是抽象方法，所有不强制被重写，但可以被重写，重写时要去掉default关键字。 public可以被省略，但default不可以被省略。 案例：实际开发中更新接口中的抽象方法，有些不用更新但如果使用此接口就必须写更新的抽象方法，如果创建新的接口来继承上一个接口，这样更新多的话就会使系统变得非常复杂，所有接口中的默认方法可以解决此问题。 1.3接口中的静态方法定义格式 格式：public static 返回值类型 方法名(参数列表){ } 范例：public static void show(){ } 注意事项 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 1.4接口中私有方法定义格式 格式1：private 返回值类型 方法名(参数列表){ } 范例1：private void show(){ } 格式2：private static 返回值类型 方法名(参数列表){ } 范例2：private static void method(){ } 注意事项 默认方法可以调用私有的静态方法和非静态方法 静态方法只可以调用私有的静态方法 案例：当两个默认方法或者静态方法中含有一段相同的代码，可以将这段相同的代码合成一个私有方法，但是在默认方法或静态方法中可以调用此私有方法避免重复。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Lambdab表达式","slug":"Lambda-方法引用","date":"2022-03-13T10:19:44.000Z","updated":"2022-03-15T06:43:42.662Z","comments":true,"path":"2022/03/13/Lambda-方法引用/","link":"","permalink":"http://example.com/2022/03/13/Lambda-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/","excerpt":"","text":"1.Lambda表达式1.1 函数式编程思想概述强调做什么，而不是以什么形式去做 1.2 体验Lambda表达式12345678public class LambdaDemo &#123; public static void main(String[] args) &#123; //Lanbda表达式 new Thread(()-&gt;&#123; System.out.println(&quot;多线程程序启动了&quot;); &#125;).start(); &#125;&#125; 1.3 Lambda表达式的标准格式![截屏2022-03-14 上午9.48.26](&#x2F;Lambda-方法引用&#x2F;截屏2022-03-14 上午9.48.26.png) 1.4Lambda表达式练习Lambda表达式使用前提 有一个接口 有且只有一个抽象方法 练习1![截屏2022-03-14 上午10.10.24](&#x2F;Lambda-方法引用&#x2F;截屏2022-03-14 上午10.10.24.png) 1234接口类Eatable.javapublic interface Eatable &#123; void eat();&#125; 123456789101112测试类EatableDemo.javapublic class EatableDemo &#123; public static void main(String[] args) &#123; useEatable(()-&gt;&#123; System.out.println(&quot;一天一苹果，医生远离我&quot;); &#125;); &#125; private static void useEatable(Eatable e)&#123; e.eat(); &#125;&#125; 练习2![截屏2022-03-14 上午10.29.40](&#x2F;Lambda-方法引用&#x2F;截屏2022-03-14 上午10.29.40.png) 1234接口类Addable.javapublic interface Addable &#123; int add(int a,int b);&#125; 12345678910111213测试类AddableDemo.javapublic class AddableDemo &#123; public static void main(String[] args) &#123; useAddable((int x,int y)-&gt;&#123; return x+y; &#125;); &#125; private static void useAddable(Addable a)&#123; int sum = a.add(10,20); System.out.println(sum); &#125;&#125; 相当于在调用useAddable方法是重写的接口中add方法 1.5Lambda省略模式12345参考练习2public static void main(String[] args) &#123; useAddable((int x,int y)-&gt;&#123; return x+y; &#125;); \u0015参数的类型可以省略 但是有多个参数的情况下，不能只省略一个 12参考练习2useAddable((x,y) -&gt; x+y) 如果参数有且仅有一个，那么小括号可以省略 如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉 1.6 Lambda表达式的注意事项 使用Lambda必须要有接口，并且要求接口中有且只有一个抽象方法 必须要有上下文环境，才能推导出Lambda表达式对应接口 ​ -局部变量的赋值 ​ -调用方法的参数 1.7 Lambda表达式与匿名内部类的区别匿名内部类 可以说接口，抽象类，具体了 接口中有且只有一个抽象方法可以使用Lambda表达式，也可以使用匿名内部类 编译之后会产生一个单独的.class文件 Lambda表达式 只能是接口 如果接口中多了一个抽象方法就只能使用匿名内部类 编译之后没有单独的.class字节码文件，对应的字节码会在运行的时候动态生成","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"在mac搭建个人博客并且部署到github上","slug":"在mac搭建个人博客并且部署到github上","date":"2022-03-13T08:37:42.000Z","updated":"2022-03-15T08:03:42.731Z","comments":true,"path":"2022/03/13/在mac搭建个人博客并且部署到github上/","link":"","permalink":"http://example.com/2022/03/13/%E5%9C%A8mac%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E4%B8%94%E9%83%A8%E7%BD%B2%E5%88%B0github%E4%B8%8A/","excerpt":"","text":"MAC搭建博客大体步骤 安装Node.js 安装Git 安装Hexo 本地运行测试 注册github并创建仓库 部署到github中去 1.安装Node.js在终端里运行命令 1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 安装后 1brew install node 验证 12node -vnpm -v 有版本号代表成功 更新 123456//单独运行brew updatebrew upgrade nodenpm install -g npm//一条运行brew update &amp;&amp; brew upgrade node &amp;&amp; npm install -g npm 2.安装Git终端里输入 1brew install git 验证 1git --version 3.安装Hexo打开终端 输入 1pwd 看自己所在路径 在&#x2F;Userse&#x2F;你的用户名 输入 1mkdir blog 在输入 1cd blog 进入该文件 在此输入pwd 检查路径是不是在 &#x2F;Userse&#x2F;你的用户名&#x2F;blog 确定的话 输入 12345npm install -g hexo-cli//每条分别输入hexo init//分别输入npm install 本地启动 1234//分别输入hexo g//分别输入hexo s 访问本地链接 http://localhost:4000 这是你会发现一个网址 恭喜你 你已经创建了一个博客了 控制台这时什么都操作不了 按control+c 结束 4.注册github并创建仓库没有就现在注册一个 来得及 自己从网上查 ![截屏2022-03-13 下午5.02.51](&#x2F;在mac搭建个人博客并且部署到github上&#x2F;截屏2022-03-13 下午5.02.51.png) 点 New reposiory ![截屏2022-03-13 下午5.04.05](&#x2F;在mac搭建个人博客并且部署到github上&#x2F;截屏2022-03-13 下午5.04.05.png) 名字严格按照 Name.github.io 创建 我的意见创建过了 所有有感叹号 Name是你github的名字 5.配置SSH并且生成SSH key1ssh-keygen -t rsa -C 你的邮箱 1cd ../../../ 到跟目录 1cd var 1sudo su 输入密码 1cd root 1cd .ssh 1vim id_rsa.pub 把里面的所有东西都复制出来 不要修改 从文件出来 按esc 1:wq 登录Github，右上角 头像 -&gt; Settings —&gt; SSH nd GPG keys —&gt; New SSH key 。把复制的内容粘贴到key中，填好title并点击 Add SSH key 验证一下 1ssh -T git@github.com 出现hello….. 就代表成功 在设置一下 12git config --global user.name your namegit config --global user.email your_email@youremail.com 名字是你git的名字 邮箱是你绑定git邮箱 6.部署到git上1npm install hexo-deployer-git --save 重启终端 1cd blog 1vim _config.yml 找到最底下 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:youname/youname.github.io.git branch: master 修改repo 找到刚刚创建的git仓库 选择ssh 将链接复制到 repo 要有空格 按a进行修改 修改完后按esc 输入 1:wq 最后输入 123hexo cleanhexo ghexo d 部署完成后可在浏览器输入 yourname.github.io 这样就能看到自己一个属于自己的博客了，由于github是属于国外的服务器，访问起来有点慢，你也可以部署到coding中去，步骤类似，如果失败不要灰心 多试几次 多查查资料 我也忙活了一下午才整好 加油 以后上传更新博客 必须要进管理员模式 参考文献https://www.jianshu.com/p/0c545b6f601a https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.recommend_more_video.-1 https://zhuanlan.zhihu.com/p/111014448","categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"}]},{"title":"Markdown使用介绍","slug":"Markdown使用介绍","date":"2022-03-13T06:45:30.000Z","updated":"2022-03-14T10:10:58.200Z","comments":true,"path":"2022/03/13/Markdown使用介绍/","link":"","permalink":"http://example.com/2022/03/13/Markdown%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"一.创建文章进入hexo的文件夹中 hexo n &quot;要取的文章名字&quot; 不要用管理员进行创建 否则没有权限编辑不了文章 这个问题困扰我好久 二.编写文章(1)标题#一级标题 ##二级标题 …… ######六级标题 Typora 快捷键： 一级标题：*（⌘ + 1）* 二级标题：*（⌘ + 2）* 三级标题：*（⌘ + 3）* 四级标题：*（⌘ + 4）* … 六级标题：*（⌘+6）* (2)粗体、斜体、删除线和下划线斜体粗体加粗斜体删除线 下划线 *斜体* **粗体** ***加粗斜体*** ~~删除线~~ Typora 快捷键： （⌘ + i）：斜体 （⌘ + b）：粗体 （^ + ⇧ + &#96;）：删除线（⌘ + u）下划线(3)引用块&gt;文字引用 这个就是一个引用 Typora 快捷键： （⌥ + ⌘ + q） (4)代码块1234`行内代码````多行代码``` Typora 快捷键： （⌘ + ⌥ + c）(5) 公式块123$$数学公式$$ （⌘ + ⌥ + B）(6) 分割线123451.---2.+++3.*** （— + enter 或 ⌘ + ⌥ + -）(7) 列表12345671. 有序列表项* 无序列表项+ 无序列表项- 无序列表项 Typora 快捷键： 有序列表项：（⌥ + ⌘ + o） 无序列表项：（⌥ + ⌘ + u） 任务列表：（⌥ + ⌘ + x） (8) 表格Typora 快捷键： (⌘ + ⌥ + T） (9)超链接12345方法一：[链接文字](链接地址 &quot;链接描述&quot;)例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt; 快捷键：（⌘ + k） (10)插入图片12![图片文字](图片地址 &quot;图片描述&quot;)例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;) （鼠标直接拖拽） hexo博客 1![想输入的提示名字，可不输入](/images/xx.jpg) (11)文章跳转跳转至文章开头（⌘ + 向上箭头）跳转至文章结尾（⌘ + 向下箭头） (12)选中英文单词&#x2F;中文单词选中英文单词或连续的中文 （⌘ + d）选中光标左边英文单词&#x2F;中文 （⌘+⌥+左方向）选中光标左边英文单词&#x2F;中文 （⌘+⌥+右方向） (13)按行选中（⌘ + l）(14)查找替换（⌘ + f）(15)插入表情mac输入 *⌃ + ⌘ + space* 弹出符号对话框 (16)新建文件（⌘ + n）(17)显示和隐藏侧边栏（⇧ + ⌘ + L）(18)标题居中支持html语言 h1表示一级标题，h6表示六级标题 1&lt;h1 align = &quot;center&quot;&gt;居中的标题&lt;h1&gt; (19)文本居中1&lt;div align = &quot;center&quot;&gt;文本居中&lt;/div&gt; 小总结从网上查的文章结合自己使用的写出来的 日后还有补充 方便自己复习看 参考文献https://blog.csdn.net/wsmrzx/article/details/81478945 https://zhuanlan.zhihu.com/p/354088977","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-03-13T06:28:23.857Z","updated":"2022-03-13T06:33:07.383Z","comments":true,"path":"2022/03/13/hello-world/","link":"","permalink":"http://example.com/2022/03/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating ssDeploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java-web","slug":"Java-web","permalink":"http://example.com/tags/Java-web/"},{"name":"英语四级","slug":"英语四级","permalink":"http://example.com/tags/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/"},{"name":"算法题","slug":"算法题","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"},{"name":"计算机系统基础","slug":"计算机系统基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"物联网","slug":"物联网","permalink":"http://example.com/tags/%E7%89%A9%E8%81%94%E7%BD%91/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"酒","slug":"酒","permalink":"http://example.com/tags/%E9%85%92/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"经验","slug":"经验","permalink":"http://example.com/tags/%E7%BB%8F%E9%AA%8C/"}]}